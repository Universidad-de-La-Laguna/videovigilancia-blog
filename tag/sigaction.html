<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>sigaction - Sistema de Videovigilancia from Scratch</title>
    <meta name="description" content="">
    <meta name="author" content="Jesús Torres">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="../theme/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../theme/bootstrap.min.css" rel="stylesheet">
    <link href="../theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="../theme/local.css" rel="stylesheet">
    <link href="../theme/pygments.css" rel="stylesheet">

</head>

<body>

<div class="navbar">
    <div class="navbar-inner">
    <div class="container">

         <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
         </a>

        <a class="brand" href="..">Sistema de Videovigilancia from Scratch</a>

        <div class="nav-collapse">
        <ul class="nav">
                    
                            <li><a href="../pages/acerca-de.html">Acerca de...</a></li>
                    <li><a href="../pages/seminarios.html">Seminarios</a></li>
                        </ul>
        </div>
        
    </div>
    </div>
</div>

<div class="container">
    <div class="content">
    <div class="row">

        <div class="span9">
                

        


    <div class='article'>
        <div class="content-title">
            <a href="../aplicaciones-de-consola-con-qt.html"><h1>Aplicaciones de consola con Qt</h1></a>
            jue 11 abril 2013

by <a class="url fn" href="../author/jesus-torres.html" rel="author">Jesús Torres</a>
 


 
        </div>
        
        <div><p><a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> es un <em>framework</em> utilizado fundamentalmente para desarrollar aplicaciones
con interfaz gráfica. Sin embargo nada impide que también sea utilizado para crear
aplicaciones de linea de comandos.</p>
<h1>QCoreApplication</h1>
<p>Al crear un proyecto de aplicación para consola, el asistente de Qt Creator
crea un archivo <code>main.cpp</code> con un contenido similar al siguiente:</p>
<div class="codehilite"><pre><span class="cp">#include &lt;QCoreApplication&gt;</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">QCoreApplication</span> <span class="n">a</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>


<p><a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication">QCoreApplication</a> es una clase que provee un bucle de mensaje para aplicaciones
de consola, mientras que para aplicaciones gráficas lo adecuado es usar <a href="http://qt-project.org/doc/qt-5.0/qtcore/qapplication.html" title="QApplication">QApplication</a>.
El bucle de mensajes es iniciado con la invocación del método
<a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication">QCoreApplication</a>::<a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#exec" title="QApplication::exec">exec</a>(), que no retorna hasta que la aplicación finaliza.
Por ejemplo cuando el método <a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication">QCoreApplication</a>::<a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#quit" title="QApplication::quit">quit</a>() es llamado.</p>
<p>Si la aplicación no necesita de un bucle de mensajes, no es necesario instanciar
<a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication">QCoreApplication</a>, pudiendo desarrollarla como cualquier programa convencional
en C++, sólo que beneficiándonos de las facilidades ofrecidas por las clases de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a>.</p>
<p>Las clases de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> que requieren disponer de un bucle de mensajes son:</p>
<ul>
<li><strong>Controles, ventanas y en general todas las relacionadas con el GUI</strong>.</li>
<li><strong>Temporizadores</strong>.</li>
<li><strong>Comunicación entre hilos mediante señales</strong>.</li>
<li><strong>Red</strong>. Si se usan los métodos síncronos <code>waitFor*</code> se puede evitar el uso
del bucle de mensajes, pero hay que tener en cuenta que las clases de comunicaciones
de alto nivel (<code>QHttp</code>, <code>QFtp</code>, etc.) no ofrecen dicho API.</li>
</ul>
<h1>Entrada estándar</h1>
<p>Muchas aplicaciones de consola interactúan con el usuario a través de la
<em>entrada estándar</em>, para lo cual se pueden usar tanto las clases de la librería
estándar de C++:</p>
<div class="codehilite"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">line</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">getline</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cint</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
</pre></div>


<p>como los flujos de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a>:</p>
<div class="codehilite"><pre><span class="n">QTextStream</span> <span class="n">qtin</span><span class="p">(</span><span class="n">stdin</span><span class="p">);</span>
<span class="n">QString</span> <span class="n">line</span> <span class="o">=</span> <span class="n">qtin</span><span class="p">.</span><span class="n">readLine</span><span class="p">();</span>
</pre></div>


<p>Sin embargo es necesario tener presente que en ambos casos el hilo principal
se puede bloquear durante la lectura (hasta que hayan datos que leer) lo que
impediría la ejecución del bucle de mensajes.</p>
<p>Para evitarlo se puede delegar la lectura de la <em>entrada estándar</em> a otro hilo,
que se comunicaría con el principal para informar de las acciones del usuario
a través del mecanismo de señales y <em>slots</em> de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a>. El procedimiento sería muy
similar al que comentamos en
<a href="../hilos-de-trabajo-usando-senales-y-slots.html">una entrada anterior</a>, sólo que
para leer la <em>entrada estándar</em> en lugar de para ordenar un vector de enteros.</p>
<h1>Manejo de señales</h1>
<p>Los sistemas operativos compatibles POSIX implementan un tipo de interrupción
por software conocido como <em>señales POSIX</em>. Estas son enviadas a los procesos
para informar de situaciones excepcionales durante la ejecución del programa, como
por ejemplo:</p>
<dl>
<dt><strong>SIGSEGV</strong></dt>
<dd>Acceso a una dirección de memoria no válida.</dd>
<dt><strong>SIGFPE</strong></dt>
<dd>Intento de ejecutar una operación aritmética inválida, como por ejemplo una
división por cero.</dd>
<dt><strong>SIGILL</strong></dt>
<dd>Intento de ejecutar una instrucción ilegal.</dd>
<dt><strong>SIGCHLD</strong></dt>
<dd>Notificación de terminación de algún proceso hijo.</dd>
<dt><strong>SIGTERM</strong></dt>
<dd>Notificación de que se ha solicitado la terminación del proceso.</dd>
<dt><strong>SIGINT</strong></dt>
<dd>Notificación de que el proceso está controlado por una terminal y el usuario
quiere interrumpirlo. Generalmente esta señal es motivada por la pulsación de
la combinación de teclas <code>Ctrl-C</code> en la terminal desde la que se controla el
proceso.</dd>
</dl>
<p>Todas éstas sólo son una pequeña muestra de una <a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals">lista</a>
mucho más larga.</p>
<p>Para cada tipo de señal el proceso puede especificar una <a href="http://pubs.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_04.html#tag_02_04_03" title="Signal Actions">acción</a> diferente:</p>
<dl>
<dt><strong>SIG_DFL</strong></dt>
<dd>Ejecutar la acción por defecto, lo que en ocasiones implica terminar el proceso.</dd>
<dt><strong>SIG_IGN</strong></dt>
<dd>Ignorar la señal, lo que no es posible para todos los tipos de señales.</dd>
<dt><strong>Invocar un manejador de señal</strong></dt>
<dd>Invocar una función concreta del programa que actua como <em>manejador de la señal</em>
para realizar las acciones que el programador considere oportunas.</dd>
</dl>
<p>Esto último es interesante porque permite realizar las acciones necesarias para
que el programa termine en condiciones seguras. Por ejemplo: borrar archivos
temporales, asegurar que los datos se escriben en disco y su estructura es
consistente, terminar procesos hijo a los que se les haya delegado parte del
trabajo, etc.</p>
<div class="codehilite"><pre><span class="kt">void</span> <span class="n">signalHandler</span><span class="p">(</span><span class="kt">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Señal (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">signum</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;) recibida.&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="c1">// Terminar el programa</span>
    <span class="n">exit</span><span class="p">(</span><span class="n">signum</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<h2>Seguridad respecto a las señales</h2>
<p>Sin embargo debemos de tener presente que las <em>señales POSIX</em> pueden llegar en
cualquier momento, interrumpiendo la secuencia normal de instrucciones del
proceso. Por lo tanto los <em>manejadores de señal</em> son invocados de forma asíncrona
respecto a la ejecución del proceso, lo que introduce problemas de concurrencia
debido al posible acceso del manejador a datos que estén siendo manipulados por
el programa.</p>
<p>Por ello:</p>
<ul>
<li>El estándar POSIX establece que desde una manejador de señal sólo se pueden
invocar funciones seguras respecto a la asincronicidad de las señales:<ul>
<li>Estas funciones son aquellas que o son <em>reentrantes</em><sup id="fnref:1"><a class="footnote-ref" href="#fn:1" rel="footnote">1</a></sup> o no interrumpibles<sup id="fnref:2"><a class="footnote-ref" href="#fn:2" rel="footnote">2</a></sup>
respecto a las señales.</li>
<li>Sólo <a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals">unas pocas</a>
funciones de la librería del sistema cumplen con dicho requisito.</li>
</ul>
</li>
<li>
<p>Incluso si se usan variables como banderas para notificar desde el manejador
al programa principal que ha ocurrido una señal, con el objeto de que éste último
ejecute las acciones necesarias, debemos especificar al compilador que no
utilice con esas variables optimizaciones que puedan dar problemas de la
concurrencia.</p>
<div class="codehilite"><pre><span class="sr">//</span> <span class="n">volatile</span> <span class="n">informa</span> <span class="n">al</span> <span class="n">compilador</span> <span class="n">que</span> <span class="nb">no</span> <span class="n">optimice</span> <span class="n">el</span> <span class="n">acceso</span> <span class="n">a</span> <span class="n">la</span>
<span class="sr">//</span> <span class="n">variable</span> <span class="n">porque</span> <span class="n">su</span> <span class="n">valor</span> <span class="n">puede</span> <span class="n">cambiar</span> <span class="n">en</span> <span class="n">cualquier</span> <span class="n">momento</span><span class="o">.</span>
<span class="n">volatile</span> <span class="n">sig_atomic_t</span> <span class="n">waitingForQuit</span><span class="p">;</span>

<span class="n">void</span> <span class="n">signalHandler</span><span class="p">(</span><span class="nb">int</span> <span class="n">signum</span><span class="p">)</span>
<span class="p">{</span>
    <span class="sr">//</span> <span class="n">Indicar</span> <span class="n">al</span> <span class="n">programa</span> <span class="n">principal</span> <span class="n">que</span> <span class="n">debe</span> <span class="n">terminar</span>
    <span class="n">waitingForQuit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nb">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="o">...</span>
    <span class="n">waitingForQuit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">...</span>
    <span class="sr">//</span> <span class="n">Configurar</span> <span class="n">el</span> <span class="n">manejador</span> <span class="n">de</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">signalHandler</span><span class="p">);</span>
    <span class="n">signal</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">signalHandler</span><span class="p">);</span>
    <span class="o">...</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">waitingForQuit</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="sr">//</span> <span class="n">Terminar</span> <span class="n">el</span> <span class="n">proceso</span> <span class="n">en</span> <span class="n">condiciones</span> <span class="n">seguras</span>
            <span class="o">...</span>
            <span class="nb">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>En programas multihilo cualquier hilo en el que no se haya bloqueado una
señal puede ser utilizado para atenderla. Eso introduce problemas adicionales
de concurrencia que obligan al uso de <a href="../introduccion-al-uso-de-hilos-en-qt.html">cerrojos, semáforos y otros elementos
de sincronización</a>.</p>
</li>
</ul>
<p>Obviamente no hay seguridad de que las funciones del API de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> cumplan con
los requisitos comentados anteriormente, por lo que no podemos invocarlas
directamente desde los <em>manejadores de señal</em>.</p>
<p>Además <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> no integra ninguna solución que encapsule y simplifique la gestión
de <em>señales POSIX</em>, puesto que éstas no están disponibles en sistemas operativos
que no soporten dicha especificación.</p>
<h2>Usando manejadores de señales POSIX con Qt</h2>
<p>Aun así en la documentación de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> se describe una forma de usar manejadores de
señales POSIX. Realmente basta con que el <em>manejador de señal</em> haga algo
que provoque que <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> emita una señal y después retorne. Al volver a la
secuencia normal de ejecución del programa, se emitiría la señal de <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a>
invocando el <em>slot</em> al que está conectada, desde donde se ejecutarían de forma
segura las operaciones que fueran necesarias.</p>
<p>Concretamente en el artículo
<a href="http://doc.qt.digia.com/4.7/unix-signals.html">Calling Qt Functions From Unix Signal Handlers</a>
se propone lo siguiente:</p>
<ol>
<li>
<p>Declarar una clase que contenga los <em>manejadores de señal</em>, los <em>slots</em> y
otros elementos que comentaremos a continuación.</p>
<div class="codehilite"><pre><span class="n">class</span> <span class="n">MyDaemon</span> <span class="p">:</span> <span class="n">public</span> <span class="n">QObject</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

    <span class="n">public:</span>
        <span class="n">MyDaemon</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
        <span class="o">~</span><span class="n">MyDaemon</span><span class="p">();</span>

        <span class="sr">//</span> <span class="n">Manejadores</span> <span class="n">de</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">POSIX</span>
        <span class="n">static</span> <span class="n">void</span> <span class="n">hupSignalHandler</span><span class="p">(</span><span class="nb">int</span> <span class="n">unused</span><span class="p">);</span>
        <span class="n">static</span> <span class="n">void</span> <span class="n">termSignalHandler</span><span class="p">(</span><span class="nb">int</span> <span class="n">unused</span><span class="p">);</span>

    <span class="n">public</span> <span class="n">slots:</span>
        <span class="sr">//</span> <span class="n">Slots</span> <span class="n">Qt</span> <span class="n">donde</span> <span class="n">atender</span> <span class="n">las</span> <span class="n">se</span><span class="err">ñ</span><span class="n">ales</span> <span class="n">POSIX</span>
        <span class="n">void</span> <span class="n">handleSigHup</span><span class="p">();</span>
        <span class="n">void</span> <span class="n">handleSigTerm</span><span class="p">();</span>

    <span class="n">private:</span>
        <span class="sr">//</span> <span class="n">Pares</span> <span class="n">de</span> <span class="n">sockets</span><span class="o">.</span> <span class="n">Un</span> <span class="n">par</span> <span class="n">por</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">a</span> <span class="n">manejar</span>
        <span class="n">static</span> <span class="n">qintptr</span> <span class="n">sigHupSd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="n">static</span> <span class="n">qintptr</span> <span class="n">sigTermSd</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

        <span class="sr">//</span> <span class="n">Objetos</span> <span class="n">para</span> <span class="n">monitorizar</span> <span class="n">los</span> <span class="n">pares</span> <span class="n">de</span> <span class="n">sockets</span>
        <span class="n">QSocketNotifier</span> <span class="o">*</span><span class="n">sigHupNotifier</span><span class="p">;</span>
        <span class="n">QSocketNotifier</span> <span class="o">*</span><span class="n">sigTermNotifier</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


</li>
<li>
<p>En el constructor, para cada señal que se quiere manejar, se usa la llamada
al sistema <a href="http://linux.die.net/man/2/socketpair" title="socketpair(2)">socketpair</a>() para crear una pareja de
<a href="http://es.wikipedia.org/wiki/Socket_Unix">sockets de dominio UNIX</a> anónimos
conectados entre sí. Al estar conectados desde el principio, lo que se escribe
en uno de los <em>sockets</em> de la pareja se puede leer en el otro. Además se crea un
objeto <a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier">QSocketNotifier</a> para uno de los sockets de cada pareja, con el objeto de
monitorizar cuando hay datos disponibles para ser leidos, en cuyo caso envía
la señal <a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier">QSocketNotifier</a>::<a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html#activated" title="QSocketNotifier::activated()">activated</a>().</p>
<div class="codehilite"><pre><span class="nn">MyDaemon::</span><span class="n">MyDaemon</span><span class="p">(</span><span class="n">QObject</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="p">:</span> <span class="n">QObject</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="sr">//</span> <span class="n">Crear</span> <span class="n">las</span> <span class="n">parejas</span> <span class="n">de</span> <span class="n">sockets</span> <span class="n">UNIX</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="nb">socketpair</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigHupSd</span><span class="p">))</span>
        <span class="n">qFatal</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create HUP socketpair&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="nb">socketpair</span><span class="p">(</span><span class="n">AF_UNIX</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sigTermSd</span><span class="p">))</span>
        <span class="n">qFatal</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t create TERM socketpair&quot;</span><span class="p">);</span>

    <span class="sr">//</span> <span class="n">Crear</span> <span class="n">los</span> <span class="n">objetos</span> <span class="n">para</span> <span class="n">monitorizar</span> <span class="n">uno</span> <span class="n">de</span> <span class="n">los</span> <span class="nb">socket</span>
    <span class="sr">//</span> <span class="n">de</span> <span class="n">cada</span> <span class="n">pareja</span><span class="o">.</span>
    <span class="n">sigHupNotifier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSocketNotifier</span><span class="p">(</span><span class="n">sigHupFd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="nn">QSocketNotifier::</span><span class="n">Read</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
    <span class="n">sigTermNotifier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSocketNotifier</span><span class="p">(</span><span class="n">sigTermSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="nn">QSocketNotifier::</span><span class="n">Read</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>

    <span class="sr">//</span> <span class="n">Conectar</span> <span class="n">la</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">activated</span><span class="p">()</span> <span class="n">de</span> <span class="n">cada</span> <span class="n">objeto</span>
    <span class="sr">//</span> <span class="n">QSocketNotifier</span> <span class="n">con</span> <span class="n">el</span> <span class="n">slot</span> <span class="n">correspondiente</span><span class="o">.</span> <span class="n">Esta</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span>
    <span class="sr">//</span> <span class="n">ser</span><span class="err">á</span> <span class="n">emitida</span> <span class="n">cuando</span> <span class="n">hayan</span> <span class="n">datos</span> <span class="n">para</span> <span class="n">ser</span> <span class="n">leidos</span> <span class="n">en</span> <span class="n">el</span>
    <span class="sr">//</span> <span class="nb">socket</span> <span class="n">monitorizado</span><span class="o">.</span>
    <span class="nb">connect</span><span class="p">(</span><span class="n">sigHupNotifier</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">activated</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">this</span><span class="p">,</span>
        <span class="n">SLOT</span><span class="p">(</span><span class="n">handleSigHup</span><span class="p">()));</span>
    <span class="nb">connect</span><span class="p">(</span><span class="n">sigTermNotifier</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">activated</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">this</span><span class="p">,</span>
        <span class="n">SLOT</span><span class="p">(</span><span class="n">handleSigTerm</span><span class="p">()));</span>

    <span class="o">...</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>Entonces los manejadores de señal lo único que tienen que hacer cuando son
invocados es escribir <em>algo</em> en el <em>socket</em> correspondiente. Nótese que los
métodos de los manejadores se declaran como <code>static</code> para que puedan ser pasados
como un puntero de función de C a la llamada al sistema <a href="http://linux.die.net/man/2/sigaction" title="sigaction(2)">sigaction</a>(), cuando
va a ser establecido el manejador de cada señal concreta:</p>
<div class="codehilite"><pre><span class="sr">//</span>
<span class="sr">//</span> <span class="n">Manejador</span> <span class="n">de</span> <span class="n">la</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">SIGHUP</span>
<span class="sr">//</span>
<span class="n">void</span> <span class="nn">MyDaemon::</span><span class="n">hupSignalHandler</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">char</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">::</span><span class="nb">write</span><span class="p">(</span><span class="n">sigHupSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="sr">//</span>
<span class="sr">//</span> <span class="n">Manejador</span> <span class="n">de</span> <span class="n">la</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">SIGTERM</span>
<span class="sr">//</span>
<span class="n">void</span> <span class="nn">MyDaemon::</span><span class="n">termSignalHandler</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
<span class="p">{</span>

    <span class="n">char</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">::</span><span class="nb">write</span><span class="p">(</span><span class="n">sigTermSd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="sr">//</span>
<span class="sr">//</span> <span class="n">Configurar</span> <span class="n">los</span> <span class="n">manejadores</span> <span class="n">de</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span>
<span class="sr">//</span>
<span class="nb">int</span> <span class="n">setupUnixSignalHandlers</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">struct</span> <span class="o">::</span><span class="n">sigaction</span> <span class="n">hup</span><span class="p">,</span> <span class="n">term</span><span class="p">;</span>

    <span class="n">hup</span><span class="o">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">MyDaemon::</span><span class="n">hupSignalHandler</span><span class="p">;</span>
    <span class="o">::</span><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hup</span><span class="o">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">hup</span><span class="o">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">;</span>

    <span class="sr">//</span> <span class="n">Establecer</span> <span class="n">manejador</span> <span class="n">de</span> <span class="n">la</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">SIGHUP</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGHUP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hup</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

    <span class="n">term</span><span class="o">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="o">&amp;</span><span class="nn">MyDaemon::</span><span class="n">termSignalHandler</span><span class="p">;</span>
    <span class="o">::</span><span class="n">sigemptyset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">term</span><span class="o">.</span><span class="n">sa_mask</span><span class="p">);</span>
    <span class="n">term</span><span class="o">.</span><span class="n">sa_flags</span> <span class="o">=</span> <span class="n">SA_RESTART</span><span class="p">;</span>

    <span class="sr">//</span> <span class="n">Establecer</span> <span class="n">manejador</span> <span class="n">de</span> <span class="n">la</span> <span class="n">se</span><span class="err">ñ</span><span class="n">al</span> <span class="n">SIGTERM</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">::</span><span class="n">sigaction</span><span class="p">(</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">term</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


</li>
<li>
<p>Finalmente en los <em>slots</em> a los que conectamos la señal <a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier">QSocketNotifier</a>::<a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html#activated" title="QSocketNotifier::activated()">activated</a>()
se lee <em>lo escrito</em> desde el <em>manejador de señal</em>, para después hacer todo
aquello que no se puede hacer desde dicho manejador de señal POSIX.</p>
<div class="codehilite"><pre><span class="n">void</span> <span class="nn">MyDaemon::</span><span class="n">handleSigHup</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">hupNotifier</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">false</span><span class="p">);</span>
    <span class="n">char</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="o">::</span><span class="nb">read</span><span class="p">(</span><span class="n">sigHupSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

    <span class="sr">//</span> <span class="o">...</span><span class="n">tu</span> <span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">aqu</span><span class="err">í</span><span class="o">...</span>

    <span class="n">hupNotifier</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">void</span> <span class="nn">MyDaemon::</span><span class="n">handleSigTerm</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">termNotifier</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">false</span><span class="p">);</span>
    <span class="n">char</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="o">::</span><span class="nb">read</span><span class="p">(</span><span class="n">sigTermSd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">sizeof</span><span class="p">(</span><span class="n">tmp</span><span class="p">));</span>

    <span class="sr">//</span> <span class="o">...</span><span class="n">tu</span> <span class="n">c</span><span class="err">ó</span><span class="n">digo</span> <span class="n">aqu</span><span class="err">í</span><span class="o">...</span>

    <span class="n">termNotifier</span><span class="o">-&gt;</span><span class="n">setEnabled</span><span class="p">(</span><span class="n">true</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


</li>
</ol>
<h1>Referencias</h1>
<ol>
<li><a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication">QCoreApplication</a>.</li>
<li><a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier">QSocketNotifier</a>.</li>
<li><a href="http://doc.qt.digia.com/4.7/unix-signals.html">Calling Qt Functions From Unix Signal Handlers</a></li>
<li>Wikipedia - <a href="http://en.wikipedia.org/wiki/Unix_signal">Unix signal</a></li>
</ol>
<div class="footnote">
<hr />
<ol>
<li id="fn:1">
<p>Una función es reentrante si puede ser interrumpida en medio de su ejecución
y vuelta a llamar con total seguridad. En general una función es reentrante si
no modifica variables estáticas o globales, no modifica su propio código y no
llama a otras funciones que no sean reentrantes.&#160;<a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Una función puede ser no interrumpible respecto a las señales si al entrar
en la función el programa las bloquea, desbloqueándolas antes de salir.&#160;<a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
</ol>
</div></div>
        <hr />
    </div>
		
            <div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Anterior</a></li>

    <li class="active"><a href="../tag/sigaction.html">1</a></li>

    <li class="next disabled"><a href="#">&rarr; Siguiente</a></li>

</ul>
</div>    
 
  
        </div>
        
        <div class="span3">

            
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Sitio
                </li>
            
                <li><a href="../archives.html">Archivos</a>
                <li><a href="../tags.html">Etiquetas</a>
                <li><a href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/atom.xml" rel="alternate">Fuente Atom</a></li>
                                <li><a href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/rss.xml" rel="alternate">Fuente RSS</a></li>
                            </ul>
            </div>


                        <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Categorias
                </li>
                
                                <li><a href="../category/comunicaciones.html">Comunicaciones</a></li>
                                <li><a href="../category/desarrollo.html">Desarrollo</a></li>
                                <li><a href="../category/hardware.html">Hardware</a></li>
                                <li><a href="../category/linux.html">Linux</a></li>
                                <li><a href="../category/overviews.html">Overviews</a></li>
                                <li><a href="../category/qt.html">Qt</a></li>
                                <li><a href="../category/vision.html">Visión</a></li>
                                   
            </ul>
            </div>
            

            

                        <div class="social">
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Social
                </li>
           
                                <li><a href="http://github.com/ull-etsii-sistemas-operativos/">github</a></li>
                                <li><a href="http://plus.google.com/u/0/communities/112085352199958768374">google+</a></li>
                                <li><a href="http://flattr.com/thing/1171169/Sistema-de-videovigilancia-from-scratch">flattr</a></li>
                                <li><a href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/atom.xml">atom</a></li>
                                <li><a href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/rss.xml">rss</a></li>
                            </ul>
            </div>
            </div>
            
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
<ul class="nav nav-list">
    <li class="nav-header">
    Búsqueda de Google
    </li>

    <script type="text/javascript">
    (function() {
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.es/cse/cse.js?cx=' + '013894742475483232300:q2-5a1zlira';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
    })();
    </script>
    <gcse:search>Cargando...</gcse:search>
</ul>
</div>

        </div>  
    </div>     </div> 
<footer>
<br />
<p><a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.es"><img alt="Licencia Creative Commons" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br />Este obra está bajo una <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.es">Licencia Creative Commons Atribución 3.0 Unported</a>.</p>
</footer>

</div> <!-- /container -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="http://twitter.github.com/bootstrap/assets/js/bootstrap-collapse.js"></script>
 
</body>
</html>