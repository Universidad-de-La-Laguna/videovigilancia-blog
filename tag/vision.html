<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>visión - Sistema de Videovigilancia from Scratch</title>
    <meta name="description" content="">
    <meta name="author" content="Jesús Torres">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Le HTML5 shim, for IE6-8 support of HTML elements -->
    <!--[if lt IE 9]>
    <script src="../theme/html5.js"></script>
    <![endif]-->

    <!-- Le styles -->
    <link href="../theme/bootstrap.min.css" rel="stylesheet">
    <link href="../theme/bootstrap.min.responsive.css" rel="stylesheet">
    <link href="../theme/local.css" rel="stylesheet">
    <link href="../theme/pygments.css" rel="stylesheet">

</head>

<body>

<div class="navbar">
    <div class="navbar-inner">
    <div class="container">

         <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
             <span class="icon-bar"></span>
         </a>

        <a class="brand" href="..">Sistema de Videovigilancia from Scratch</a>

        <div class="nav-collapse">
        <ul class="nav">
                    
                            <li><a href="../pages/acerca-de.html">Acerca de...</a></li>
                        </ul>
        </div>
        
    </div>
    </div>
</div>

<div class="container">
    <div class="content">
    <div class="row">

        <div class="span9">
                

        


    <div class='article'>
        <div class="content-title">
            <a href="../deteccion-de-movimiento.html"><h1>Detección de movimiento</h1></a>
            mar 19 febrero 2013

by <a class="url fn" href="../author/jesus-torres.html" rel="author">Jesús Torres</a>
 


 
        </div>
        
        <div><p>Detectar movimiento en una secuencia de vídeo es una tarea relativamente simple
que puede abordarse en unos pocos pasos:</p>
<ol>
<li>
<p><strong>Supresión del fondo</strong>. Consiste en estimar un modelo del fondo y comparalo
con el <em>frame</em> actual para detectar cambios. El resultado es una imagen binaria
donde los píxeles se clasifican entre si son del fondo o del primer plano.</p>
</li>
<li>
<p><strong>Operaciones morfológicas</strong>. En la imagen resultado de la operación anterior
suelen aparecer regiones de pequeño tamaño marcadas como de primer plano debido
al ruido en el <em>frame</em> original. Una solución muy común en estos casos es aplicar
operaciones de dilatación y erosión con el objeto de suprimirlas.</p>
</li>
<li>
<p><strong>Extracción de blobs</strong>. Los píxeles clasificados como de primer plano
suelen agruparse en regiones que corresponden a objetos en movimiento en el
<em>frame</em> original. La <em>extracción de blobs</em> permite identificar estas regiones
para, por ejemplo, marcarlas con un cuadro delimitador en la imagen original.</p>
</li>
</ol>
<h2>OpenCV</h2>
<p>Los pasos a realizar son relativamente sencillos, por lo que no nos costaría
mucho desarrollar nuestra propia implementación, ya que la mayor parte de ellos
están perfectamente documentados de manera muy comprensible en Internet:</p>
<ul>
<li>
<p><strong>Supresión del fondo</strong>:</p>
<ul>
<li>Wikipedia - <a href="http://es.wikipedia.org/wiki/Detecci%C3%B3n_de_primer_plano">Detección de primer plano</a></li>
</ul>
</li>
<li>
<p><strong>Operaciones morfológicas</strong></p>
<ul>
<li>Wikipedia - <a href="http://es.wikipedia.org/wiki/Morfolog%C3%ADa_matem%C3%A1tica">Morfología matemática</a></li>
<li>Universidad Carlos III de Madrid - <a href="es/imagine/Curso_ProcesadoMorfologico/Contenido/Operaciones/OperacionesMorfologicas.html">Operaciones Morfológicas</a></li>
</ul>
</li>
<li>
<p><strong>Extracción de blobs</strong></p>
<ul>
<li>Wikipedia - <a href="http://en.wikipedia.org/wiki/Blob_extraction">Connected-component labeling</a></li>
</ul>
</li>
</ul>
<p>Sin embargo existe una librería de visión por computador, denominada <a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a>,
que permite que nos ahorremos todo este trabajo.</p>
<p>Además en estos casos siempre debemos tener presente que aunque se trate de
algoritmos sencillos, siempre existen pequeñas cuestiones que deben ser tenidas
en cuenta, fundamentalmente desde el punto de vista de la precisión de los
algoritmos y del rendimiento, lo que puede dificultar el desarrollo. Por eso
suele ser preferible utilizar una librería madura en lugar de hacer nuestra
propia implementación.</p>
<h2>OpenCV y Qt</h2>
<p>Si estamos desarrollando una aplicación gráfica en <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a> debemos tomar una serie
de medidas para poder emplear la librería <a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a> desde ella:</p>
<h3>Conversión de QImage en cv::Mat</h3>
<p>Las imágenes de las que haremos uso son instancias de la clase <a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage">QImage</a>, propia
del <em>framework</em> <a href="../proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt">Qt</a>. Sin embargo las funciones, clases y métodos de <a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a>
esperan objetos <code>cv::Mat</code>. Para convertir entre un formato y otro podemos emplear
el proyecto <a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV">QtOpenCV</a> de <a href="https://github.com/dbzhang800">Debao Zhang</a> (licencia
<a href="http://es.wikipedia.org/wiki/MIT_License">MIT</a>)</p>
<p>Para utilizarlo sólo necesitamos:</p>
<ol>
<li>
<p>Descargar en el directorio del proyecto los archivos:</p>
<ul>
<li><a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.cpp" title="cvmatandqimage.cpp">cvmatandqimage.cpp</a></li>
<li><a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.h" title="cvmatandqimage.h">cvmatandqimage.h</a></li>
<li><a href="https://github.com/dbzhang800/QtOpenCV/blob/master/opencv.pri" title="opencv.pri">opencv.pri</a></li>
<li><a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri">QtOpenCV.pri</a></li>
</ul>
</li>
<li>
<p>Abrir el archivo <code>.pro</code> del proyecto y añadir al final la línea:</p>
<div class="codehilite"><pre><span class="n">include</span><span class="p">(</span><span class="n">QtOpenCV</span><span class="p">.</span><span class="n">pri</span><span class="p">)</span>
</pre></div>


</li>
</ol>
<p>Los archivos <code>.pri</code> tienen el mismo formato que los <code>.pro</code> pero están pensados
para ser incluidos por estos últimos. En nuestro caso el archivo <a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri">QtOpenCV.pri</a>
contiene información sobre como incorporar los archivos <a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.cpp" title="cvmatandqimage.cpp">cvmatandqimage.cpp</a>
y <a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.h" title="cvmatandqimage.h">cvmatandqimage.h</a> al proyecto, haciendo que las funciones por ellos
definidas estén disponibles para nuestra aplicación.</p>
<p>Tal y como se comenta en el archivo <code>README.md</code> de <a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV">QtOpenCV</a>, en el proyecto
se definen dos funciones:</p>
<div class="codehilite"><pre><span class="k">namespace</span> <span class="n">QtOcv</span> <span class="p">{</span>
    <span class="c1">// channels == 0 significa autodetección</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">image2Mat</span><span class="p">(</span><span class="k">const</span> <span class="n">QImage</span> <span class="o">&amp;</span><span class="n">img</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">channels</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="n">MatChannelOrder</span> <span class="n">rgbOrder</span> <span class="o">=</span> <span class="n">MCO_BGR</span><span class="p">);</span>
    <span class="c1">// format == QImage::Format_Invalid significa autodetección</span>
    <span class="n">QImage</span> <span class="nf">mat2Image</span><span class="p">(</span><span class="k">const</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="o">&amp;</span><span class="n">mat</span><span class="p">,</span>
                     <span class="n">QImage</span><span class="o">::</span><span class="n">Format</span> <span class="n">format</span> <span class="o">=</span> <span class="n">QImage</span><span class="o">::</span><span class="n">Format_Invalid</span><span class="p">,</span>
                     <span class="n">MatChannelOrder</span> <span class="n">rgbOrder</span> <span class="o">=</span> <span class="n">MCO_BGR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>que podemos usar para convertir objetos <a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage">QImage</a> a <code>cv::Mat</code> y viceversa.</p>
<h3>Añadir la librería OpenCV al proyecto</h3>
<p>Aunque ya hemos incorporado <a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV">QtOpenCV</a> a nuestro proyecto para la conversión
entre formatos de imagen, aun no hemos añadido la librería OpenCV propiamente
dicha:</p>
<ul>
<li>
<p>El archivo <a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri">QtOpenCV.pri</a> incluido anteriormente a su vez incluye a
<a href="https://github.com/dbzhang800/QtOpenCV/blob/master/opencv.pri" title="opencv.pri">opencv.pri</a>, cuya labor es facilitar el añadir <a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a> al proyecto. Lo único
que tenemos que hacer es editar el archivo <code>.pro</code> e incorporar al final la línea:</p>
<div class="codehilite"><pre><span class="n">add_opencv_modules</span><span class="p">(</span><span class="n">core</span> <span class="n">video</span> <span class="n">imgproc</span><span class="p">)</span>
</pre></div>


<p>En la <a href="http://docs.opencv.org/modules/core/doc/intro.html">introducción</a> de
<a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a> se explica que el paquete está divido a su vez en distintos módulos
o librerías, cada uno de los cuales está dedicado a un tipo de tarea específico.
En nuestro caso concreto el módulo <em>video</em> incluye las clases y funciones de
supresión del fondo que nos interesa utilizar, mientras que <em>imgproc</em> contiene
las operaciones morfológicas y de detección de contornos.</p>
</li>
<li>
<p>Si por cualquier motivo no estuviéramos haciendo uso de los archivos <code>.pri</code>
tendríamos que incorporar la librería al proyecto manualmente:</p>
<ul>
<li>
<p>En Linux y Mac OS X esto se puede hacer como un <em>paquete instalado en el sistema</em>:</p>
<ol>
<li>
<p>En el menú contextual del proyecto (botón derecho sobre el proyecto)
seleccionar <strong>Add Library.../System package</strong>.</p>
</li>
<li>
<p>En el paso posterior indicar <strong>opencv</strong> como nombre del paquete. Obviamente
la librería tiene que haber sido instalada previamente usando el procedimiento
usual de nuestra distribución.</p>
</li>
</ol>
</li>
<li>
<p>En Windows este recurso no existe, por lo que la librería suele incorporarse
al proyecto como <em>librería externa</em>:</p>
<ol>
<li>
<p>En el menú contextual del proyecto (botón derecho sobre el proyecto)
seleccionar <strong>Add Library.../External library</strong>.</p>
</li>
<li>
<p>Indicar el archivo de la librería (<em>Library file</em>) que queremos
incorporar y el directorio de cabeceras (<em>Include Path</em>). Como lo estamos
haciendo para Windows, sólo tenemos que tener marcada dicha opción en la lista
de plataformas soportadas. Por lo general:</p>
<ul>
<li>Librerías en <code>C:\opencv\build\&lt;ARQUITECTURA&gt;\mingw\lib</code>: <code>libopencv_core&lt;VERSION&gt;.dll.a</code> y <code>libopencv_video&lt;VERSION&gt;.dll.a</code></li>
<li>Ruta de las cabeceras: <code>C:\opencv\build\include</code></li>
</ul>
</li>
</ol>
</li>
</ul>
<p>Para ambos sistemas, al terminar se nos abrirá el archivo <code>.pro</code> del proyecto con
los cambios correspondientes realizados. Debemos guardarlo para dar por
finalizada la incorporación de la librería.</p>
</li>
</ul>
<h2>Detección de movimiento</h2>
<p>Con acceso a las clases y funciones de <a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a> desde nuestra aplicación,
podemos pasar a resolver el problema que nos habíamos propuesto; detectar
movimiento en una secuencia de vídeo.</p>
<p>Como ocurre con muchas otras tareas en el campo de la visión por computador,
esta se puede resolver de múltiples maneras. Además es muy común que en cada
técnica posible haya una decena de parámetros que den resultados diferentes
según como los ajustemos.</p>
<p>Nosotros nos centraremos en solución concreta:</p>
<div class="codehilite"><pre><span class="c1">// std::vector&lt;cv::Mat&gt; images = &lt;vector de imágenes en cv::Mat&gt;</span>

<span class="c1">// Definimos algunos tipos para que el código se lea mejor</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="o">&gt;</span> <span class="n">ImagesType</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">cv</span><span class="o">::</span><span class="n">Point</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">ContoursType</span><span class="p">;</span>

<span class="c1">// Instancia de la clase del sustractor de fondo</span>
<span class="n">cv</span><span class="o">::</span><span class="n">BackgroundSubtractorMOG2</span> <span class="n">backgroundSubtractor</span><span class="p">;</span>
<span class="n">backgroundSubtractor</span><span class="p">.</span><span class="n">nmixtures</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="c1">// Desactivar la detección de sombras</span>
<span class="n">backgroundSubtractor</span><span class="p">.</span><span class="n">bShadowDetection</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  

<span class="k">for</span> <span class="p">(</span><span class="n">ImagesTypes</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">images</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">images</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Sustracción del fondo:</span>
    <span class="c1">//  1. El objeto sustractor compara la imagen en i con su</span>
    <span class="c1">//     estimación del fondo y devuelve en foregroundMask una</span>
    <span class="c1">//     máscara (imagen binaria) con un 1 en los píxeles de</span>
    <span class="c1">//     primer plano.</span>
    <span class="c1">//  2. El objeto sustractor actualiza su estimación del fondo</span>
    <span class="c1">//     usando la imagen en i.</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span> <span class="n">foregroundMask</span><span class="p">;</span>
    <span class="n">backgroundSubtractor</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">,</span> <span class="n">foregroundMask</span><span class="p">);</span>

    <span class="c1">// Operaciones morfolóficas para eliminar las regiones de</span>
    <span class="c1">// pequeño tamaño. Erode() las encoge y dilate() las vuelve a</span>
    <span class="c1">// agrandar.</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">erode</span><span class="p">(</span><span class="n">foregroundMask</span><span class="p">,</span> <span class="n">foregroundMask</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">());</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">dilate</span><span class="p">(</span><span class="n">foregroundMask</span><span class="p">,</span> <span class="n">foregroundMask</span><span class="p">,</span> <span class="n">cv</span><span class="o">::</span><span class="n">Mat</span><span class="p">());</span>

    <span class="c1">// Obtener los contornos que bordean las regiones externas</span>
    <span class="c1">// (CV_RETR_EXTERNAL) encontradas. Cada contorno es un vector</span>
    <span class="c1">// de puntos y se devuelve uno por región en la máscara.</span>
    <span class="n">ContoursType</span> <span class="n">contours</span><span class="p">;</span>
    <span class="n">cv</span><span class="o">::</span><span class="n">findContours</span><span class="p">(</span><span class="n">foregroundMask</span><span class="p">,</span> <span class="n">contours</span><span class="p">,</span> <span class="n">CV_RETR_EXTERNAL</span><span class="p">,</span>
                     <span class="n">CV_CHAIN_APPROX_NONE</span><span class="p">);</span>

    <span class="c1">// Aquí va el código ódigo que usa los contornos encontrados...</span>
    <span class="c1">// P. ej. usar cv::boundingRect() para obtener el cuadro</span>
    <span class="c1">// delimitador de cada uno y pintarlo en la imagen original</span>
<span class="p">}</span>
</pre></div>


<p>Donde suponemos que previamente hemos convertido todas las imágenes de
<a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage">QImage</a> a cv::Mat y las hemos almacenado en un vector.</p>
<p>Al final de cada iteración del bucle tenemos para cada imagen un vector de
contornos, donde cada uno es un vector de puntos. Con los contornos se pueden
hacer múltiples operaciones. Por ejemplo calcular el rectángulo que contiene
a cada uno (<em>bounding box</em>) con <a href="http://opencv.willowgarage.com/documentation/cpp/structural_analysis_and_shape_descriptors.html#cv-boundingrect" title="cv::boundingRect">cv::boundingRect</a>() para pintarlos sobre
la imagen antes de mostrársela al usuario.</p>
<h2>Referencias</h2>
<ol>
<li><a href="http://opencv.willowgarage.com/wiki/" title="OpenCV">OpenCV</a></li>
<li><a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV">QtOpenCV</a></li>
</ol></div>
        <hr />
    </div>
		
            <div class="pagination">
<ul>
    <li class="prev disabled"><a href="#">&larr; Anterior</a></li>

    <li class="active"><a href="../tag/vision.html">1</a></li>

    <li class="next disabled"><a href="#">&rarr; Siguiente</a></li>

</ul>
</div>    
 
  
        </div>
        
        <div class="span3">

            
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Sitio
                </li>
            
                <li><a href="../archives.html">Archivos</a>
                <li><a href="../tags.html">Etiquetas</a>
                <li><a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/atom.xml" rel="alternate">Fuente Atom</a></li>
                                <li><a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/rss.xml" rel="alternate">Fuente RSS</a></li>
                            </ul>
            </div>


                        <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Categorias
                </li>
                
                                <li><a href="../category/hardware.html">Hardware</a></li>
                                <li><a href="../category/linux.html">Linux</a></li>
                                <li><a href="../category/overviews.html">Overviews</a></li>
                                <li><a href="../category/qt.html">Qt</a></li>
                                <li><a href="../category/vision.html">Visión</a></li>
                                   
            </ul>
            </div>
            

            

                        <div class="social">
            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
            <ul class="nav nav-list">
                <li class="nav-header"> 
                Social
                </li>
           
                                <li><a href="http://github.com/ull-etsii-sistemas-operativos/">github</a></li>
                                <li><a href="http://plus.google.com/u/0/communities/112085352199958768374">google+</a></li>
                                <li><a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/atom.xml">atom</a></li>
                                <li><a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/rss.xml">rss</a></li>
                            </ul>
            </div>
            </div>
            

            <div class="well" style="padding: 8px 0; background-color: #FBFBFB;">
<ul class="nav nav-list">
    <li class="nav-header">
    Búsqueda de Google
    </li>

    <script type="text/javascript">
    (function() {
    var gcse = document.createElement('script'); gcse.type = 'text/javascript'; gcse.async = true;
    gcse.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') +
        '//www.google.es/cse/cse.js?cx=' + '013894742475483232300:q2-5a1zlira';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(gcse, s);
    })();
    </script>
    <gcse:search>Cargando...</gcse:search>
</ul>
</div>

        </div>  
    </div>     </div> 
<footer>
<br />
<p><a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.es"><img alt="Licencia Creative Commons" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/80x15.png" /></a><br />Este obra está bajo una <a rel="license" href="http://creativecommons.org/licenses/by/3.0/deed.es">Licencia Creative Commons Atribución 3.0 Unported</a>.</p>
</footer>

</div> <!-- /container -->
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
<script src="http://twitter.github.com/bootstrap/assets/js/bootstrap-collapse.js"></script>
 
</body>
</html>