<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Sistema de Videovigilancia from Scratch</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/</link><description></description><atom:link href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/rss.xml" rel="self"></atom:link><lastBuildDate>Sun, 05 May 2013 00:00:00 +0100</lastBuildDate><item><title>Conversión de tipos en C++</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/conversion-de-tipos-en-c.html</link><description>&lt;p&gt;En C, cuando una conversión entre dos tipos no es realizada por el compilador de
forma automática —esto sólo ocurre cuando la conversión es segura, como ir de
&lt;code&gt;char&lt;/code&gt; a &lt;code&gt;int&lt;/code&gt; o de éste a &lt;code&gt;float&lt;/code&gt;— se puede forzar utilizando una expresión de
&lt;em&gt;typecast&lt;/em&gt; de la forma &lt;code&gt;(type)object&lt;/code&gt; —o &lt;code&gt;type(object)&lt;/code&gt;— para convertir el
elemento &lt;code&gt;object&lt;/code&gt; al tipo especificado por &lt;code&gt;type&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En C++, aunque entre los programadores sigue siendo muy común la conversión de
&lt;em&gt;estilo C&lt;/em&gt;, existen diversos operadores de &lt;em&gt;typecast&lt;/em&gt; cuyo uso es más adecuado y
menos peligroso.&lt;/p&gt;
&lt;h1&gt;static_cast&lt;/h1&gt;
&lt;p&gt;El operador:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;static_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;es el primero que se debe intentar utilizar.&lt;/p&gt;
&lt;p&gt;Puede hacer conversiones implícitas entre tipos —como de &lt;code&gt;int&lt;/code&gt; a &lt;code&gt;float&lt;/code&gt; o de
un puntero a &lt;code&gt;void*&lt;/code&gt;— así como llamar a los métodos de conversión explícitos
definidos en las clases:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;operator&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;static_cast&lt;/strong&gt; convierte de clases bases a derivadas en una jerarquía de clases
—la conversión de clases derivadas a clases bases es automática— siempre que no
haya polimorfismo&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;. En cualquier caso las conversiones &lt;strong&gt;static_cast&lt;/strong&gt; se
resuelven en &lt;strong&gt;tiempo de compilación&lt;/strong&gt; y no comprueban si el tipo al que se
convierte coincide con el tipo real del objeto. El estándar indica que queda
indefinido lo que pueda pasar si se convierte de un tipo base a uno derivado
cuando este último no es el tipo real del objeto.&lt;/p&gt;
&lt;h1&gt;dynamic_cast&lt;/h1&gt;
&lt;p&gt;El operador:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;dynamic_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;se utiliza exclusivamente para manejar el polimorfismo ya que permite convertir
un puntero o referencia de un tipo polimórfico a cualquier otro tipo. Esto no
sólo permite convertir de clases base a derivadas, sino también desplazarnos
lateralmente e incluso movernos a una cadena de herencia diferente dentro de
una misma jerarquía de clases.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;dynamic_cast&lt;/strong&gt; busca &lt;strong&gt;en tiempo de ejecución&lt;/strong&gt; el objeto del tipo deseado
en la jerarquía, devolviéndolo en caso de encontrarlo. Si los tipos no son
compatibles, devuelve &lt;code&gt;NULL&lt;/code&gt; para punteros o lanza una excepción
&lt;code&gt;std::bad_cast&lt;/code&gt; si lo que se convierten son referencias a objetos.&lt;/p&gt;
&lt;h1&gt;const_cast&lt;/h1&gt;
&lt;p&gt;El operador:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;const_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;se usa exclusivamente para eliminar o añadir &lt;code&gt;const&lt;/code&gt; a una variable, ya que esto
es algo que no pueden hacer los otros operadores de &lt;em&gt;typecast&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Es importante destacar que su uso queda indefinido si la variable original
realmente es constante. Por ejemplo, algunos compiladores optimizan las constantes
reemplazándolas donde son utilizadas directamente por el valor que contienen. En
casos como ese, intentar modificar la variable tiene un resultado indefinido
según indica el estándar del lenguaje.&lt;/p&gt;
&lt;h1&gt;reinterpret_cast&lt;/h1&gt;
&lt;p&gt;El operador:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;permite convertir un tipo directamente en otro, por lo que es el más peligroso
de los operadores de conversión. Por ejemplo permite convertir punteros de un
tipo a otro o convertir un puntero en un entero para su manipulación. Se utiliza
fundamentalmente para convertir un flujo de bytes en el tipo definitivo con
el que se van a manipular los datos.&lt;/p&gt;
&lt;p&gt;La única garantía ofrecida por el estándar de C++ es que si se hace un
&lt;strong&gt;reinterpret_cast&lt;/strong&gt; y posteriormente se realiza un conversión al tipo original,
se obtiene el mismo resultado si el tipo intermedio tiene el tamaño suficiente.&lt;/p&gt;
&lt;h1&gt;Conversión estilo C&lt;/h1&gt;
&lt;p&gt;En C++ una conversión de &lt;em&gt;estilo C&lt;/em&gt; se define como la primera que tenga éxito
intentándolo en el siguiente orden:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;const_cast&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;static_cast&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;static_cast&lt;/strong&gt; y después &lt;strong&gt;const_cast&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reinterpret_cast&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;reinterpret_cast&lt;/strong&gt; y después &lt;strong&gt;const_cast&lt;/strong&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Obviamente este tipo de &lt;em&gt;typecast&lt;/em&gt; es peligroso porque se puede convertir en un
&lt;strong&gt;reinterpret_cast&lt;/strong&gt;, siendo preferible que si este tipo de conversión es
necesaria se indique de forma explícita, quedando como tal reflejada en el
código.&lt;/p&gt;
&lt;p&gt;Además la conversión &lt;em&gt;estilo C&lt;/em&gt; ignora el control de acceso cuando realiza un
&lt;strong&gt;static_cast&lt;/strong&gt; por lo que que este tipo de conversión permite hacer
operaciones que con las otras no se puede. Diversos ejemplos de esto se pueden encontrar en
&lt;a href="http://stackoverflow.com/questions/8548667/static-cast-%20restricts-access-to-public-member-function"&gt;stackoverflow&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/332030/when-should-static-cast-dynamic-cast-and-reinterpret-cast-be-used"&gt;When should static_cast, dynamic_cast and reinterpret_cast be used?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/8548667/static-cast-restricts-access-to-public-member-function"&gt;static_cast restricts access to public member function?&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Un tipo polimórfico es aquel que tiene al menos una función virtual, ya sea
declarada directamente en el o heredada de una clase base.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 05 May 2013 00:00:00 +0100</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-05-05:conversion-de-tipos-en-c.html</guid><category>typecast</category><category>c++</category><category>cpp</category><category>static_cast</category><category>dynamic_cast</category><category>const_cast</category><category>reinterpret_cast</category></item><item><title>Resource Interchange File Format</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/resource-interchange-file-format.html</link><description>&lt;p&gt;El &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format"&gt;Resource Interchange File Format&lt;/a&gt; o &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format" title="Resource Interchange File Format"&gt;RIFF&lt;/a&gt; es un formato contenedor genérico diseñado para almacenar datos en forma
de fragmentos etiquetados o &lt;a href="http://en.wikipedia.org/wiki/Chunk_(information)" title="Chunk (information)"&gt;chunks&lt;/a&gt;. Siendo usado en la actualidad como formato
contenedor de los conocidos formatos de archivo AVI, ANI y WAV de Microsoft, es
indudable que resulta especialmente útil para almacenar contenidos multimedia,
aunque realmente puede almacenar cualquier tipo de información.&lt;/p&gt;
&lt;h1&gt;Tipos de fragmentos&lt;/h1&gt;
&lt;p&gt;Hay dos tipos de fragmentos en un archivo &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format" title="Resource Interchange File Format"&gt;RIFF&lt;/a&gt;. El más básico son los
&lt;a href="http://en.wikipedia.org/wiki/Chunk_(information)" title="Chunk (information)"&gt;chunks&lt;/a&gt; o fragmentos de datos propiamente dichos:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Chunk&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;// contiene datos en general&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;donde &lt;code&gt;type&lt;/code&gt; sirve para identificar el tipo y el formato de los datos que
almacena el fragmento y &lt;code&gt;size&lt;/code&gt; para especificar su tamaño —sin incluir ni el
tamaño del campo &lt;code&gt;type&lt;/code&gt; ni el de &lt;code&gt;size&lt;/code&gt;—.&lt;/p&gt;
&lt;p&gt;El otro tipo de fragmento son las listas:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;listType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;      &lt;span class="c1"&gt;// contiene otros Chunk o List&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;que son aquellos que contienen una colección de otros fragmentos o listas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Las listas se identifican y distinguen de otros fragmentos porque su campo
&lt;code&gt;type&lt;/code&gt; contiene o los 4 caracteres de &lt;code&gt;RIFF&lt;/code&gt; o de &lt;code&gt;LIST&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;Para este tipo de fragmentos el tamaño en el campo &lt;code&gt;size&lt;/code&gt; incluye tanto el
 de los datos almacenados dentro del fragmento como el del campo &lt;code&gt;listType&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Dentro de la lista los fragmentos que contiene se disponen unos detrás de
otros, pero siempre asegurando que cada fragmento comienza en una dirección
par —es decir, que se alinean a 16 bits—.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El archivo contenedor en si mismo es una gran fragmento de lista tipo &lt;code&gt;RIFF&lt;/code&gt; que
contiene otros fragmentos. Estos pueden ser &lt;em&gt;chunks&lt;/em&gt; o listas de tipo &lt;code&gt;LIST&lt;/code&gt;.
Por lo tanto en una archivo RIFF sólo existe una lista de este tipo, que hace
las veces de contenedor de todos los fragmentos del archivo. El valor del campo
&lt;code&gt;listType&lt;/code&gt; del fragmento &lt;code&gt;RIFF&lt;/code&gt; es una secuencia de 4 bytes que identifica el
formato del archivo y se lo conoce como el &lt;a href="http://www.fourcc.org/codecs.php" title="FourCC"&gt;FourCC&lt;/a&gt; del mismo.&lt;/p&gt;
&lt;h1&gt;Estructura general&lt;/h1&gt;
&lt;p&gt;Para hacernos una idea del formato este sería el esquema de un archivo AVI
convencional:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;RIFF &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;AVI &amp;#39;&lt;/span&gt;
      LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hdr1&amp;#39;&lt;/span&gt;
            AVIH &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;cabecera principal del AVI&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
            LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;str1&amp;#39;&lt;/span&gt;
                  STRH &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;cabecera del flujo&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
                  STRF &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;formato del flujo&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
                  ...
                 &lt;span class="o"&gt;)&lt;/span&gt;
            ...
           &lt;span class="o"&gt;)&lt;/span&gt;
      LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;movi&amp;#39;&lt;/span&gt;
            &lt;span class="o"&gt;{&lt;/span&gt;Chunk | LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rec &amp;#39;&lt;/span&gt;
                           Chunk1
                           Chunk2
                           ...
                          &lt;span class="o"&gt;)&lt;/span&gt;
             ...
            &lt;span class="o"&gt;}&lt;/span&gt;
            ...
           &lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;[&lt;/span&gt;IDX1 &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;índice AVI&amp;gt;&lt;span class="o"&gt;)]&lt;/span&gt;
     &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Donde los identificadores en mayúsculas denotan el valor del campo &lt;code&gt;type&lt;/code&gt; al
comienzo de un fragmento. Este siempre es seguido por el campo &lt;code&gt;size&lt;/code&gt;, que no se
muestra en el esquema anterior. Por otro lado el valor de los campos &lt;code&gt;listType&lt;/code&gt;
de los fragmentos de tipo lista se indica entre comillas simples.&lt;/p&gt;
&lt;p&gt;Para observar una estructura real de archivo RIFF se puede utilizar el
programa &lt;a href="http://manpages.ubuntu.com/manpages/lucid/man1/rifftree.1.html" title="Ubuntu Manpage: rifftree"&gt;rifftree&lt;/a&gt; del paquete &lt;code&gt;gigtools&lt;/code&gt; con cualquier archivo &lt;code&gt;.avi&lt;/code&gt; o
&lt;code&gt;.wav&lt;/code&gt; que tengamos a mano.&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format"&gt;Resource Interchange File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MSDN - &lt;a href="http://msdn.microsoft.com/en-us/library/ms779636(VS.85).aspx"&gt;AVI RIFF File Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.alexander-noe.com/video/documentation/avi.pdf"&gt;AVI File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.fourcc.org/codecs.php" title="FourCC"&gt;FourCC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Si bien en el archivo se almacenan los caracteres &lt;code&gt;'R'&lt;/code&gt;, &lt;code&gt;'R'&lt;/code&gt;, &lt;code&gt;'I'&lt;/code&gt;, &lt;code&gt;'F'&lt;/code&gt;
en ese orden, hay que tener en cuenta que al interpretarlo como &lt;code&gt;uint32_t&lt;/code&gt; en
una máquina &lt;em&gt;little-endian&lt;/em&gt; no veremos el número 0x52494646 sino 0x46464952.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Wed, 24 Apr 2013 00:00:00 +0100</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-24:resource-interchange-file-format.html</guid><category>RIFF</category><category>AVI</category><category>WAV</category></item><item><title>Make install con qmake</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/make-install-con-qmake.html</link><description>&lt;p&gt;Cada entorno de desarrollo y/o lenguaje de programación maneja por sus propios
medios la manera de definir un proyecto de software y el proceso de construcción
del mismo. Sin embargo &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; sigue siendo ámpliamente utilizado para este
propósito, especialmente en los sistemas UNIX y derivados.&lt;/p&gt;
&lt;h1&gt;Make&lt;/h1&gt;
&lt;p&gt;Para usar &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; cada proyecto debe ir acompañado de un fichero &lt;code&gt;Makefile&lt;/code&gt; donde
se incluyen las reglas para la compilación y enlazado de las librerías y
ejecutables del mismo. Estas reglas fijan que es lo que hay que hacer —que
comandos ejecutar y como hacerlo— para obtener cada producto del proceso de
construcción, así como las dependencias de estos con respecto a otros productos
o a los distintos archivos de código fuente del proyecto. Además se pueden
incluir reglas para automatizar tareas tales como generar la documentación;
instalar o desplegar los programas, las librerías, la documentación y otros
productos generados; o limpiar el proyecto, borrando archivos temporales y
subproductos de la compilación.&lt;/p&gt;
&lt;p&gt;Cuando la construcción de un proyecto ha sido automatizada adecuadamente con
&lt;code&gt;make&lt;/code&gt;, la compilación del mismo se reduce a ejecutar el comando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;en el directorio del proyecto. Siendo su instalación igual de sencilla:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Obviamente entornos integrados de desarrollo como Eclise, KDevelop, Code::Blocks
o Visual Studio incorporan sus propias herramientas para automatizar la
compilación de proyectos, que además se integran perfectamente con estos
entornos gráficos. Sin embargo &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; suele estar disponible en cualquier
sistema y puede ser utilizado independientemente de las preferencias de cada
desarrollador acerca del entorno integrado con el que trabajar.&lt;/p&gt;
&lt;p&gt;Además &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; es una herramienta que fácilmente puede ser utilizada desde otras
de más alto nivel. Por ejemplo, un sistema de construcción de paquetes como el
que utilizan las distribuciones basadas en Debian automatiza todos los pasos,
desde la descarga del código fuente hasta la generación del archivo &lt;code&gt;.deb&lt;/code&gt;,
pasando por invocar a &lt;code&gt;make&lt;/code&gt; para compilar y a &lt;code&gt;make install&lt;/code&gt; para que los
productos de dicha construcción se instalen en su ubicación definitiva&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, de
donde son tomados para conformar el contenido del paquete del proyecto. De forma
muy similar funciona &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Bitbake&lt;/a&gt;, la herramienta de construcción que utiliza el
proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; para generar distribuciones de Linux para sistemas empotrados,
y así una larga lista de herramientas similares. Para todas ellas el poder
automatizar la construcción de proyectos de software es fundamental, siendo éste
un campo donde la solución orientada a línea de comandos de &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; se muestra
mucho más flexible que las soluciones de interfaz gráfica integradas de los 
distintos entornos de desarrollo.&lt;/p&gt;
&lt;h1&gt;Qmake&lt;/h1&gt;
&lt;p&gt;Aunque &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; es una herramienta muy flexible, resulta muy compleja de utilizar,
si no imposible, cuando se quiere crear software portable. Diferentes sistemas
operativos pueden tener distintos compiladores, ya sean de diferentes
fabricantes o en distintas versiones, u ofrecer a las aplicaciones diferentes
funcionalidades —o las mismas pero de manera distintas—. Además un proyecto de
software puede depender de otras librerías o programas, que nuevamente pueden
ser de versiones diferentes o distintos desarrolladores. Y a todo eso hay que
unir que según el sistema operativo la ubicación de librerías, programas y
herramientas de desarrollo puede diferir.&lt;/p&gt;
&lt;p&gt;Enfrentar estas situaciones con &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; es extremadamente difícil, por lo que los
desarrolladores suelen utilizar otras utilidades que se encarguen de buscar las
herramientas de desarrollo y las dependencias del programa, detectar las
funcionalidades del sistema y generar un archivo &lt;code&gt;Makefile&lt;/code&gt; ajustado al sistema
concreto donde se va a compilar.&lt;/p&gt;
&lt;p&gt;Herramientas de este tipo existen muchas. Por ejemplo Autotools&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;, CMake,
SCons y &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt;. Siendo esta última la que se usa preferentemente con las
aplicaciones desarrolladas en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, ya que sabe manejar perfectamente las
singularidades de este &lt;em&gt;framework&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Con &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; las información requerida para construir un proyecto se define en un
&lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt; que generalmente tienen extensión &lt;code&gt;.pro&lt;/code&gt;. Al ejecutar
&lt;code&gt;qmake&lt;/code&gt; dentro del directorio de un proyecto, éste interpreta los archivos de
proyecto y genera el &lt;code&gt;Makefile&lt;/code&gt; correspondiente. Después sólo es necesario
ejecutar el comando &lt;code&gt;make&lt;/code&gt; para iniciar la compilación del mismo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;qmake
&lt;span class="nv"&gt;$ &lt;/span&gt;make
&lt;span class="nv"&gt;$ &lt;/span&gt;make install
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Reglas para make install&lt;/h1&gt;
&lt;p&gt;Realmente el último &lt;code&gt;make install&lt;/code&gt; no sirve de mucho porque &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; por defecto
no añade tareas a dicha regla en el archivo &lt;code&gt;Makefile&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Si queremos que al ejecutar &lt;code&gt;make install&lt;/code&gt; se instalen los archivos de nuestra
aplicación en las ubicaciones adecuadas&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;, debemos instruir a &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; a través
del &lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt; acerca de como se hace:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;unix {          # Esta configuración específica de Linux y UNIX
    # Variables
    #
    isEmpty(PREFIX) {
        PREFIX = /usr/local
    }
    BINDIR  = $$PREFIX/bin
    DATADIR = $$PREFIX/share
    CONFDIR = /etc
    isEmpty(VARDIR) {
        VARDIR  = /var/lib/$${TARGET}
    }

    # Install
    #
    INSTALLS += target config desktop icon32 vardir

    ## Instalar ejecutable
    target.path = $$BINDIR

    ## Instalar archivo de configuración
    config.path = $$CONFDIR
    config.files += $${TARGET}.ini

    ## Instalar acceso directo en el menú del escritorio
    desktop.path = $$DATADIR/applications
    desktop.files += $${TARGET}.desktop

    ## Instalar icono de aplicación
    icon32.path = $$DATADIR/icons/hicolor/32x32/apps
    icon32.files += ./data/32x32/$${TARGET}.png

    ## Crear directorio de archivos variables
    vardir.path = $$VARDIR
    vardir.commands = :
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La variable &lt;code&gt;INSTALLS&lt;/code&gt; debe contener una lista de los recursos que queremos que
sean instalados con &lt;code&gt;make install&lt;/code&gt;. De tal forma que cada elemento de la lista
incorpora atributos que proporcionan información sobre dónde van a ser
instalados.&lt;/p&gt;
&lt;p&gt;Por ejemplo, el elemento &lt;code&gt;target&lt;/code&gt; representa a los ficheros resultado de la
construcción del proyecto. Asignando una ruta a &lt;code&gt;target.path&lt;/code&gt; estamos indicando
donde queremos que sean instalados. De forma similar, el elemento &lt;code&gt;icon32&lt;/code&gt;
representa al icono de la aplicación en el escritorio. Asignando un valor a
&lt;code&gt;icon32.path&lt;/code&gt; estamos diciendo donde queremos que sea instalado, mientras que el
valor del atributo &lt;code&gt;icon32.files&lt;/code&gt; indica donde podemos encontrar el archivo o
archivos del icono respecto al directorio del proyecto.&lt;/p&gt;
&lt;h1&gt;Definición de macros del preprocesador&lt;/h1&gt;
&lt;p&gt;Las variables que hemos definido dentro del &lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt; establecen la
ubicación de los recursos del programa tras su instalación. Sería más complicado
cometer errores si en nuestro código fuente usáramos directamente las rutas tal
y como se definen en el &lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt;, sin tener que volver a definirlas
en C++. Además eso daría pie a modificar la ruta de los archivos mediante la
redefinición de variables en la línea de comandos de &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt;, sin tener por ello
que modificar el código fuente. Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;qmake &lt;span class="nv"&gt;PREFIX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ejecuta &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; usando el valor indicado para la variable &lt;code&gt;PREFIX&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir esto sólo tenemos que utilizar la variable &lt;code&gt;DEFINES&lt;/code&gt;, que nos
permite listar un conjunto de macros del preprocesador&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt; que queremos que sean
pasadas al compilador.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;unix {          # Esta configuración específica de Linux y UNIX
    # Variables
    #
    isEmpty(PREFIX) {
        PREFIX = /usr/local
    }
    BINDIR  = $$PREFIX/bin
    DATADIR = $$PREFIX/share
    CONFDIR = /etc
    isEmpty(VARDIR) {
        VARDIR  = /var/lib/$${TARGET}
    }

    DEFINES += APP_DATADIR=\\\&amp;quot;$$DATADIR\\\&amp;quot;
    DEFINES += APP_VARDIR=\\\&amp;quot;$$VARDIR\\\&amp;quot;
    DEFINES += APP_CONFFILE=\\\&amp;quot;$$CONFDIR/$${TARGET}.ini\\\&amp;quot;

    # Install
    #
    INSTALLS += target config desktop icon32 vardir

    ## Instalar ejecutable
    target.path = $$BINDIR

    ## Instalar archivo de configuración
    config.path = $$CONFDIR
    config.files += $${TARGET}.ini

    ## Instalar acceso directo en el menú del escritorio
    desktop.path = $$DATADIR/applications
    desktop.files += $${TARGET}.desktop

    ## Instalar icono de aplicación
    icon32.path = $$DATADIR/icons/hicolor/32x32/apps
    icon32.files += ./data/32x32/$${TARGET}.png

    ## Crear directorio de archivos variables
    vardir.path = $$VARDIR
    vardir.commands = :
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así, por ejemplo, dentro del código fuente se puede usar la macro &lt;code&gt;APP_CONFFILE&lt;/code&gt;
con la ruta al archivo de configuración de la aplicación para acceder a él
mediante &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsettings.html" title="QSettings"&gt;QSettings&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QSettings&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APP_CONFFILE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QSettings&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IniFormat&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html"&gt;qmake Project
Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://es.wikipedia.org/wiki/Filesystem_Hierarchy_Standard"&gt;Filesystem Hierarchy Standard&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Durante el proceso de construcción de un paquete &lt;code&gt;.deb&lt;/code&gt; el proyecto, una
vez compilado, se instala, pero no en la raíz del sistema donde está teniendo
lugar la compilación, sino que se confina el comando &lt;code&gt;make install&lt;/code&gt; a un
subdirectorio temporal. Así &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; deposita los archivos en sus ubicaciones
predefinidas (p. ej. &lt;code&gt;/usr/bin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt;, &lt;code&gt;/etc&lt;/code&gt;, &lt;code&gt;/var/lib&lt;/code&gt;, etc.) solo que
relativas a dicho subdirectorio (p .ej. &lt;code&gt;/ruta/al/subdirectorio/usr/bin&lt;/code&gt;,
&lt;code&gt;/ruta/al/subdirectorio/etc&lt;/code&gt;, &lt;code&gt;/ruta/al/subdirectorio/usr/lib&lt;/code&gt;,
&lt;code&gt;/ruta/al/subdirectorio/var/lib&lt;/code&gt;, etc.). Para obtener el contenido del paquete
sólo hace falta tomar el contenido del subdirectorio temporal, evitando que el
proceso de construcción ensucie el sistema donde se está ejecutando.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;GNU Autotools es la herramienta que está detrás de tener que ejecutar
&lt;code&gt;./configure&lt;/code&gt; antes de compilar muchos programas y librerías libres con &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;En los sistemas Linux, UNIX y derivados éstas ubicaciones vienen definidas
por el &lt;a href="http://es.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" title="Filesystem Hierarchy Standard"&gt;Filesystem Hierarchy Standard&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Las macros del preprocesador son aquellas que generalmente se definen en
C/C++ mediante la directiva &lt;code&gt;#define&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Mon, 22 Apr 2013 00:00:00 +0100</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-22:make-install-con-qmake.html</guid><category>qt</category><category>make</category><category>qmake</category><category>INSTALLS</category><category>DEFINES</category></item><item><title>Aplicaciones de consola con Qt</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/aplicaciones-de-consola-con-qt.html</link><description>&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; es un &lt;em&gt;framework&lt;/em&gt; utilizado fundamentalmente para desarrollar aplicaciones
con interfaz gráfica. Sin embargo nada impide que también sea utilizado para crear
aplicaciones de linea de comandos.&lt;/p&gt;
&lt;h1&gt;QCoreApplication&lt;/h1&gt;
&lt;p&gt;Al crear un proyecto de aplicación para consola, el asistente de Qt Creator
crea un archivo &lt;code&gt;main.cpp&lt;/code&gt; con un contenido similar al siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;QCoreApplication&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QCoreApplication&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt; es una clase que provee un bucle de mensaje para aplicaciones
de consola, mientras que para aplicaciones gráficas lo adecuado es usar &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qapplication.html" title="QApplication"&gt;QApplication&lt;/a&gt;.
El bucle de mensajes es iniciado con la invocación del método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#exec" title="QApplication::exec"&gt;exec&lt;/a&gt;(), que no retorna hasta que la aplicación finaliza.
Por ejemplo cuando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#quit" title="QApplication::quit"&gt;quit&lt;/a&gt;() es llamado.&lt;/p&gt;
&lt;p&gt;Si la aplicación no necesita de un bucle de mensajes, no es necesario instanciar
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;, pudiendo desarrollarla como cualquier programa convencional
en C++, sólo que beneficiándonos de las facilidades ofrecidas por las clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Las clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; que requieren disponer de un bucle de mensajes son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controles, ventanas y en general todas las relacionadas con el GUI&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Temporizadores&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunicación entre hilos mediante señales&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;. Si se usan los métodos síncronos &lt;code&gt;waitFor*&lt;/code&gt; se puede evitar el uso
del bucle de mensajes, pero hay que tener en cuenta que las clases de comunicaciones
de alto nivel (&lt;code&gt;QHttp&lt;/code&gt;, &lt;code&gt;QFtp&lt;/code&gt;, etc.) no ofrecen dicho API.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Entrada estándar&lt;/h1&gt;
&lt;p&gt;Muchas aplicaciones de consola interactúan con el usuario a través de la
&lt;em&gt;entrada estándar&lt;/em&gt;, para lo cual se pueden usar tanto las clases de la librería
estándar de C++:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;como los flujos de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QTextStream&lt;/span&gt; &lt;span class="n"&gt;qtin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;QString&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;qtin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readLine&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo es necesario tener presente que en ambos casos el hilo principal
se puede bloquear durante la lectura (hasta que hayan datos que leer) lo que
impediría la ejecución del bucle de mensajes.&lt;/p&gt;
&lt;p&gt;Para evitarlo se puede delegar la lectura de la &lt;em&gt;entrada estándar&lt;/em&gt; a otro hilo,
que se comunicaría con el principal para informar de las acciones del usuario
a través del mecanismo de señales y &lt;em&gt;slots&lt;/em&gt; de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;. El procedimiento sería muy
similar al que comentamos en
&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html"&gt;una entrada anterior&lt;/a&gt;, sólo que
para leer la &lt;em&gt;entrada estándar&lt;/em&gt; en lugar de para ordenar un vector de enteros.&lt;/p&gt;
&lt;h1&gt;Manejo de señales&lt;/h1&gt;
&lt;p&gt;Los sistemas operativos compatibles POSIX implementan un tipo de interrupción
por software conocido como &lt;em&gt;señales POSIX&lt;/em&gt;. Estas son enviadas a los procesos
para informar de situaciones excepcionales durante la ejecución del programa, como
por ejemplo:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;SIGSEGV&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Acceso a una dirección de memoria no válida.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGFPE&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Intento de ejecutar una operación aritmética inválida, como por ejemplo una
división por cero.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGILL&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Intento de ejecutar una instrucción ilegal.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Notificación de terminación de algún proceso hijo.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Notificación de que se ha solicitado la terminación del proceso.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGINT&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Notificación de que el proceso está controlado por una terminal y el usuario
quiere interrumpirlo. Generalmente esta señal es motivada por la pulsación de
la combinación de teclas &lt;code&gt;Ctrl-C&lt;/code&gt; en la terminal desde la que se controla el
proceso.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Todas éstas sólo son una pequeña muestra de una &lt;a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals"&gt;lista&lt;/a&gt;
mucho más larga.&lt;/p&gt;
&lt;p&gt;Para cada tipo de señal el proceso puede especificar una &lt;a href="http://pubs.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_04.html#tag_02_04_03" title="Signal Actions"&gt;acción&lt;/a&gt; diferente:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;SIG_DFL&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Ejecutar la acción por defecto, lo que en ocasiones implica terminar el proceso.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIG_IGN&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Ignorar la señal, lo que no es posible para todos los tipos de señales.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Invocar un manejador de señal&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Invocar una función concreta del programa que actua como &lt;em&gt;manejador de la señal&lt;/em&gt;
para realizar las acciones que el programador considere oportunas.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Esto último es interesante porque permite realizar las acciones necesarias para
que el programa termine en condiciones seguras. Por ejemplo: borrar archivos
temporales, asegurar que los datos se escriben en disco y su estructura es
consistente, terminar procesos hijo a los que se les haya delegado parte del
trabajo, etc.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;signum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Señal (&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;signum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;) recibida.&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// Terminar el programa&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Seguridad respecto a las señales&lt;/h2&gt;
&lt;p&gt;Sin embargo debemos de tener presente que las &lt;em&gt;señales POSIX&lt;/em&gt; pueden llegar en
cualquier momento, interrumpiendo la secuencia normal de instrucciones del
proceso. Por lo tanto los &lt;em&gt;manejadores de señal&lt;/em&gt; son invocados de forma asíncrona
respecto a la ejecución del proceso, lo que introduce problemas de concurrencia
debido al posible acceso del manejador a datos que estén siendo manipulados por
el programa.&lt;/p&gt;
&lt;p&gt;Por ello:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;El estándar POSIX establece que desde una manejador de señal sólo se pueden
invocar funciones seguras respecto a la asincronicidad de las señales:&lt;ul&gt;
&lt;li&gt;Estas funciones son aquellas que o son &lt;em&gt;reentrantes&lt;/em&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; o no interrumpibles&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;
respecto a las señales.&lt;/li&gt;
&lt;li&gt;Sólo &lt;a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals"&gt;unas pocas&lt;/a&gt;
funciones de la librería del sistema cumplen con dicho requisito.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Incluso si se usan variables como banderas para notificar desde el manejador
al programa principal que ha ocurrido una señal, con el objeto de que éste último
ejecute las acciones necesarias, debemos especificar al compilador que no
utilice con esas variables optimizaciones que puedan dar problemas de la
concurrencia.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;volatile&lt;/span&gt; &lt;span class="n"&gt;informa&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;compilador&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="nb"&gt;no&lt;/span&gt; &lt;span class="n"&gt;optimice&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;acceso&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;porque&lt;/span&gt; &lt;span class="n"&gt;su&lt;/span&gt; &lt;span class="n"&gt;valor&lt;/span&gt; &lt;span class="n"&gt;puede&lt;/span&gt; &lt;span class="n"&gt;cambiar&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;cualquier&lt;/span&gt; &lt;span class="n"&gt;momento&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;volatile&lt;/span&gt; &lt;span class="n"&gt;sig_atomic_t&lt;/span&gt; &lt;span class="n"&gt;waitingForQuit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;signum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Indicar&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;programa&lt;/span&gt; &lt;span class="n"&gt;principal&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="n"&gt;debe&lt;/span&gt; &lt;span class="n"&gt;terminar&lt;/span&gt;
    &lt;span class="n"&gt;waitingForQuit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;waitingForQuit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Configurar&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;
    &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGINT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGTERM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;waitingForQuit&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Terminar&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;proceso&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;condiciones&lt;/span&gt; &lt;span class="n"&gt;seguras&lt;/span&gt;
            &lt;span class="o"&gt;...&lt;/span&gt;
            &lt;span class="nb"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En programas multihilo cualquier hilo en el que no se haya bloqueado una
señal puede ser utilizado para atenderla. Eso introduce problemas adicionales
de concurrencia que obligan al uso de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;cerrojos, semáforos y otros elementos
de sincronización&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Obviamente no hay seguridad de que las funciones del API de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; cumplan con
los requisitos comentados anteriormente, por lo que no podemos invocarlas
directamente desde los &lt;em&gt;manejadores de señal&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Además &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; no integra ninguna solución que encapsule y simplifique la gestión
de &lt;em&gt;señales POSIX&lt;/em&gt;, puesto que éstas no están disponibles en sistemas operativos
que no soporten dicha especificación.&lt;/p&gt;
&lt;h2&gt;Usando manejadores de señales POSIX con Qt&lt;/h2&gt;
&lt;p&gt;Aun así en la documentación de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; se describe una forma de usar manejadores de
señales POSIX. Realmente basta con que el &lt;em&gt;manejador de señal&lt;/em&gt; haga algo
que provoque que &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; emita una señal y después retorne. Al volver a la
secuencia normal de ejecución del programa, se emitiría la señal de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;
invocando el &lt;em&gt;slot&lt;/em&gt; al que está conectada, desde donde se ejecutarían de forma
segura las operaciones que fueran necesarias.&lt;/p&gt;
&lt;p&gt;Concretamente en el artículo
&lt;a href="http://doc.qt.digia.com/4.7/unix-signals.html"&gt;Calling Qt Functions From Unix Signal Handlers&lt;/a&gt;
se propone lo siguiente:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declarar una clase que contenga los &lt;em&gt;manejadores de señal&lt;/em&gt;, los &lt;em&gt;slots&lt;/em&gt; y
otros elementos que comentaremos a continuación.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MyDaemon&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="n"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;MyDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;MyDaemon&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Manejadores&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;POSIX&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;hupSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;termSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;slots:&lt;/span&gt;
        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Slots&lt;/span&gt; &lt;span class="n"&gt;Qt&lt;/span&gt; &lt;span class="n"&gt;donde&lt;/span&gt; &lt;span class="n"&gt;atender&lt;/span&gt; &lt;span class="n"&gt;las&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;ales&lt;/span&gt; &lt;span class="n"&gt;POSIX&lt;/span&gt;
        &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;handleSigHup&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;handleSigTerm&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;private:&lt;/span&gt;
        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Pares&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;sockets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Un&lt;/span&gt; &lt;span class="n"&gt;par&lt;/span&gt; &lt;span class="n"&gt;por&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;manejar&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;qintptr&lt;/span&gt; &lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;qintptr&lt;/span&gt; &lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Objetos&lt;/span&gt; &lt;span class="n"&gt;para&lt;/span&gt; &lt;span class="n"&gt;monitorizar&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="n"&gt;pares&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;sockets&lt;/span&gt;
        &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sigHupNotifier&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sigTermNotifier&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el constructor, para cada señal que se quiere manejar, se usa la llamada
al sistema &lt;a href="http://linux.die.net/man/2/socketpair" title="socketpair(2)"&gt;socketpair&lt;/a&gt;() para crear una pareja de
&lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;sockets de dominio UNIX&lt;/a&gt; anónimos
conectados entre sí. Al estar conectados desde el principio, lo que se escribe
en uno de los &lt;em&gt;sockets&lt;/em&gt; de la pareja se puede leer en el otro. Además se crea un
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt; para uno de los sockets de cada pareja, con el objeto de
monitorizar cuando hay datos disponibles para ser leidos, en cuyo caso envía
la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html#activated" title="QSocketNotifier::activated()"&gt;activated&lt;/a&gt;().&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;MyDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Crear&lt;/span&gt; &lt;span class="n"&gt;las&lt;/span&gt; &lt;span class="n"&gt;parejas&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;sockets&lt;/span&gt; &lt;span class="n"&gt;UNIX&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;socketpair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_UNIX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;qFatal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Couldn&amp;#39;t create HUP socketpair&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;socketpair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_UNIX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;qFatal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Couldn&amp;#39;t create TERM socketpair&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Crear&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="n"&gt;objetos&lt;/span&gt; &lt;span class="n"&gt;para&lt;/span&gt; &lt;span class="n"&gt;monitorizar&lt;/span&gt; &lt;span class="n"&gt;uno&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="nb"&gt;socket&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;cada&lt;/span&gt; &lt;span class="n"&gt;pareja&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
    &lt;span class="n"&gt;sigHupNotifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupFd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="nn"&gt;QSocketNotifier::&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;sigTermNotifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="nn"&gt;QSocketNotifier::&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Conectar&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;activated&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;cada&lt;/span&gt; &lt;span class="n"&gt;objeto&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt; &lt;span class="n"&gt;con&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;slot&lt;/span&gt; &lt;span class="n"&gt;correspondiente&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Esta&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="err"&gt;á&lt;/span&gt; &lt;span class="n"&gt;emitida&lt;/span&gt; &lt;span class="n"&gt;cuando&lt;/span&gt; &lt;span class="n"&gt;hayan&lt;/span&gt; &lt;span class="n"&gt;datos&lt;/span&gt; &lt;span class="n"&gt;para&lt;/span&gt; &lt;span class="n"&gt;ser&lt;/span&gt; &lt;span class="n"&gt;leidos&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="nb"&gt;socket&lt;/span&gt; &lt;span class="n"&gt;monitorizado&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupNotifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;activated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handleSigHup&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermNotifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;activated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handleSigTerm&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;

    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Entonces los manejadores de señal lo único que tienen que hacer cuando son
invocados es escribir &lt;em&gt;algo&lt;/em&gt; en el &lt;em&gt;socket&lt;/em&gt; correspondiente. Nótese que los
métodos de los manejadores se declaran como &lt;code&gt;static&lt;/code&gt; para que puedan ser pasados
como un puntero de función de C a la llamada al sistema &lt;a href="http://linux.die.net/man/2/sigaction" title="sigaction(2)"&gt;sigaction&lt;/a&gt;(), cuando
va a ser establecido el manejador de cada señal concreta:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGHUP&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;hupSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGTERM&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;termSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Configurar&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="n"&gt;manejadores&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;setupUnixSignalHandlers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;hupSignalHandler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigemptyset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SA_RESTART&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Establecer&lt;/span&gt; &lt;span class="n"&gt;manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGHUP&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigaction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGHUP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;termSignalHandler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigemptyset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SA_RESTART&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Establecer&lt;/span&gt; &lt;span class="n"&gt;manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGTERM&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigaction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGTERM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finalmente en los &lt;em&gt;slots&lt;/em&gt; a los que conectamos la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html#activated" title="QSocketNotifier::activated()"&gt;activated&lt;/a&gt;()
se lee &lt;em&gt;lo escrito&lt;/em&gt; desde el &lt;em&gt;manejador de señal&lt;/em&gt;, para después hacer todo
aquello que no se puede hacer desde dicho manejador de señal POSIX.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;handleSigHup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;hupNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="n"&gt;tu&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;hupNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;handleSigTerm&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;termNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="n"&gt;tu&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;termNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://doc.qt.digia.com/4.7/unix-signals.html"&gt;Calling Qt Functions From Unix Signal Handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Unix_signal"&gt;Unix signal&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Una función es reentrante si puede ser interrumpida en medio de su ejecución
y vuelta a llamar con total seguridad. En general una función es reentrante si
no modifica variables estáticas o globales, no modifica su propio código y no
llama a otras funciones que no sean reentrantes.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Una función puede ser no interrumpible respecto a las señales si al entrar
en la función el programa las bloquea, desbloqueándolas antes de salir.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Thu, 11 Apr 2013 00:00:00 +0100</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-11:aplicaciones-de-consola-con-qt.html</guid><category>qt</category><category>qcoreapplication</category><category>consola</category><category>terminal</category><category>señales</category><category>hilos</category><category>signal</category><category>sigaction</category><category>qsocketnotifier</category><category>volatile</category></item><item><title>Paralelismo y concurrencia</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/paralelismo-y-concurrencia.html</link><description>&lt;p&gt;El paralelismo no debe confundirse con la &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;concurrencia&lt;/a&gt;,
aunque es común que así ocurra. El paralelismo se preocupa de analizar como
superponer operaciones con el objeto de mejorar el rendimiento al realizar una
tarea concreta.&lt;/p&gt;
&lt;p&gt;Normalmente un programa lanza un conjunto de subtareas que se ejecutan en
paralelo para realizar un trabajo determinado, mientras la tarea principal no
continua hasta que todas las subtareas han terminado. El reto desde el punto
de vista del paralelismo es determinar las optimizaciones necesarias con
respecto a cuestiones tales como la granularidad y el coste de la comunicación.&lt;/p&gt;
&lt;p&gt;Sin embargo la concurrencia es necesaria para implementar el paralelismo.
Concretamente, en el ejemplo anterior, se hace cargo de establecer como se
definen las distintas tareas, que características tienen y como se implementan
sobre un hardware en concreto. También establece los mecanismos de
coordinación y sincronización necesarios para lidiar con la indeterminación, ya
que no sabemos cuando terminarán las tareas ni cuando accederán a las estructuras
de datos compartidas.&lt;/p&gt;
&lt;p&gt;En ese sentido podemos decir que el paralelismo es una abstracción útil para
mejorar el rendimiento de una tarea. Sin embargo no debe confundirse dicha
abstracción con su implementación, que entraría en el campo de la concurrencia.
Así un programa con dos hilos concurrentes que se ejecute en un sistema
monoprocesador sin múltiples núcleos ni físicos ni lógicos (&lt;a href="http://en.wikipedia.org/wiki/Simultaneous_multithreading" title="Simultaneous Multithreading"&gt;SMT&lt;/a&gt;) puede ser
concurrente pero no paralelo. Obviamente el paralelismo sólo es posible en
sistemas multinúcleo, multiprocesador o distribuidos.&lt;/p&gt;
&lt;p&gt;A continuación complementaremos lo hablado anteriormente sobre &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;concurrencia&lt;/a&gt;
considerando que ahora el contexto es el de programas donde pretendemos
descomponer y paralelizar tareas &lt;em&gt;limitadas por la CPU&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Multihilo&lt;/h2&gt;
&lt;p&gt;El uso de múltiples hilos dentro de un programa paralelo es un enfoque muy
común. Sin embargo, a diferencia de lo que ocurre &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;en los casos de los que
hemos hablado anteriormente&lt;/a&gt;, por lo
general se crean tantos hilos como núcleos diferentes dispone el sistema y
se divide entre ellos la tarea que deseamos realizar.&lt;/p&gt;
&lt;p&gt;Obviamente tiene poco sentido crear más hilos que secuencias de instrucciones
pueden ejecutarse paralelamente en el sistema.&lt;/p&gt;
&lt;h2&gt;Agrupamiento de hilos&lt;/h2&gt;
&lt;p&gt;Como acabamos de comentar, en un problema de &lt;strong&gt;programación paralela&lt;/strong&gt; el
número de hilos adecuado viene determinado por el de núcleos, lo que obliga a
dividir el problema de manera diferente según las características del hardware
donde el programa se va a ejecutar. Esto no es sencillo si la aplicación va a
ser distribuida al público y por lo tanto será utilizada en ordenadores con
características diversas.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://commons.wikimedia.org/wiki/File:Thread_pool.svg"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/500px-Thread_pool.svg.png" alt="Sencillo esquema de un agrupamiento de hilos" class="right-float"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;El patrón &lt;em&gt;agrupamiento de hilos&lt;/em&gt; comentado en el artículo sobre &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;concurrencia&lt;/a&gt;
nos puede ayudar a enfrentar este problema. Básicamente nos permite dividir
las tareas &lt;em&gt;limitadas por la CPU&lt;/em&gt; tanto como queramos. Y que estas sean
ejecutadas sobre un agrupamiento configurado con el mismo número de hilos que
núcleos de procesador hay en el sistema donde se está ejecutando la aplicación.&lt;/p&gt;
&lt;p&gt;De esta manera los programas se pueden adaptar al paralelismo del hardware
subyacente, aprovechando de forma sencilla las ventajas de los sistemas
multinúcleo.&lt;/p&gt;
&lt;p&gt;Como ya hemos comentado, las plataformas Java y .NET incorporan una
implementación de este patrón. Mientras que para C/C++ existen diversas librerías,
entre las que no sólo está &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; y su clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthreadpool.html" title="QThreadPool"&gt;QThreadPool&lt;/a&gt;, si no que fundamentalmente
tenemos que destacar la &lt;a href="http://es.wikipedia.org/wiki/Intel_Threading_Building_Blocks" title="Intel Threading Building Blocks"&gt;Threading Building Blocks&lt;/a&gt; de Intel (TBB).&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html"&gt;Concurrence is no parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Concurrency_pattern"&gt;Concurrency pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Thread_pool_pattern"&gt;Thread pool pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 07 Apr 2013 00:00:00 +0100</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-07:paralelismo-y-concurrencia.html</guid><category>concurrencia</category><category>paralelismo</category><category>hilos</category><category>multihilo</category><category>qthreadpool</category></item><item><title>Concurrencia</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html</link><description>&lt;p&gt;La concurrencia tiene que ver con manejar múltiples eventos que se superponen
en el tiempo fuera del control del programa. Por lo tanto debe preocuparse de
manejar la creciente complejidad que surge de la necesidad de un control de
flujo no determinista. Los programas concurrentes vienen con frecuencia
&lt;em&gt;limitados por la E/S&lt;/em&gt;, como por ejemplo es el caso de las arañas usadas por
los buscadores de Internet para explorar la web. Estos programas inician
varias peticiones HTTP para obtener diversas páginas y aceptan de forma
concurrente las respuestas con su contenido, acumulándolas en el conjunto de
páginas visitadas. El control del flujo es no determinista porque las respuestas
no se reciben necesariamente en el mismo orden en el que el programa hizo las
correspondientes peticiones.&lt;/p&gt;
&lt;p&gt;En general existen aplicaciones que son fundamentalmente concurrentes, como
los servidores web, los de archivos, los de base de datos y otros programas
similares que deben manejar al mismo tiempo la conexión con diversos clientes.
También son concurrentes las &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/paralelismo-y-concurrencia.html"&gt;aplicaciones paralelas&lt;/a&gt;,
donde una tarea se descompone en otras más pequeñas que se ejecutan al mismo
tiempo para obtener el máximo rendimiento, porque en muchas ocasiones no se sabe
de antemano cuando van a terminar estas subtareas o van a intentar acceder a las
estructuras de datos compartidas. Así mismo son concurrentes las aplicaciones
para las GUI modernas, ya que peticiones tales como atender un click de ratón o
actualizar el contenido de una ventana pueden llegar en cualquier momento fuera
del control del programa.&lt;/p&gt;
&lt;p&gt;Por su naturaleza no determinista, los programas concurrentes son difíciles de
depurar. &lt;/p&gt;
&lt;h2&gt;Manejar la concurrencia&lt;/h2&gt;
&lt;p&gt;Hasta el momento hemos dejado entrever las dos motivos más comunes por los que
necesitamos gestionar la concurrencia:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Si nuestro programa deben manejar eventos externos que escapan a su control,
como es el caso de un servidor que deben aceptar peticiones de múltiples
clientes o una aplicación interactiva que debe responder ante los eventos
notificados por el sistema a causa de las acciones del usuario, necesitamos
manejar la concurrencia.&lt;/p&gt;
&lt;p&gt;Las tareas de estos programas con frecuencia están &lt;em&gt;limitadas por la E/S&lt;/em&gt;,
aunque no siempre es así. Por ejemplo, los recolectores de basura concurrentes
presentes en algunas plataformas (p. ej. Java y .NET) están enteramente
&lt;em&gt;limitados por la CPU&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Obviamente todo sería mucho más sencillo si optáramos por ignorar la
concurrencia, manejando en turno una solicitud cada vez. Pero entonces una
petición o un evento bloquearía a los otros hasta que hubiera terminado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Si en nuestro programa queremos usar &lt;strong&gt;programación paralela&lt;/strong&gt; para descomponer
ciertas tareas en otras más pequeñas que se puedan ejecutar al mismo tiempo con
el objeto de obtener el máximo rendimiento, también es necesario gestionar la
concurrencia. Sin embargo, por lo general, este tipo de tareas están
&lt;em&gt;limitadas por la CPU&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En la actualidad existen diferentes maneras de tratar la concurrencia, que
pueden ser más o menos convenientes según el tipo de problemas a resolver.
Nosotros nos centraremos por el momento en el primer tipo, dejando los detalles
relacionados con la &lt;strong&gt;programación paralela&lt;/strong&gt; para un
&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/paralelismo-y-concurrencia.html"&gt;artículo posterior&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Multihilo&lt;/h2&gt;
&lt;p&gt;El uso de múltiples hilos dentro de un mismo programa es uno de los enfoques
más comunes cuando se plantea resolver un problema de concurrencia. En las
mayor parte de los sistemas modernos los hilos creados por la aplicación son
conocidos y gestionados por el núcleo (&lt;a href="http://en.wikipedia.org/wiki/Thread_(computing)#1:1_.28Kernel-
level_threading.29"&gt;modelo uno a
uno&lt;/a&gt;), lo que les permite acceder simultáneamente al mismo y
ser planificados en diferentes procesadores, pudiendo así aprovechar el
paralelismo ofrecido por el hardware en los sistemas multiprocesador y/o
multinúcleo.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1oViFjM7lI5jCoWx4uM9xD_8DRz9d2mOETWQuzjf3AU4/pub?w=606&amp;amp;h=534" alt="Modelo de hilo 1:1" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;Obviamente la manera en la que se utilizan los hilos dependen del tipo de problema.
Si lo que se pretende es gestionar eventos o peticiones externas, lo más habitual
es crear un hilo por cliente conectado. Así cada hilo funcionará de manera
independiente procesando y atendiendo las peticiones de su cliente.&lt;/p&gt;
&lt;h3&gt;Características&lt;/h3&gt;
&lt;p&gt;Las principales características de la programación multihilo son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Es muy sencilla, ya que permite gestionar diferentes hilos de ejecución
dentro del espacio de direcciones virtual de un mismo proceso, lo que facilita
la compartición de datos y otros recursos comunes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Se puede volver muy compleja, debido al cuidadoso control que es necesario
hacer sobre el acceso a los recursos compartidos, a poco que el problema crezca.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Modelos basados en paso de mensajes&lt;/h3&gt;
&lt;p&gt;Debido a que muchos de los problemas de la programación multihilo provienen de
la compartición de recursos, se ha extendido el uso de modelos basados en paso
de mensajes para resolver problemas concurrentes complejos.&lt;/p&gt;
&lt;p&gt;En estos modelos los hilos no acceden directamente a los datos sino que se los
transfieren entre si por medio de mensajes. Así se evita compartir recursos y,
por tanto, el uso de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;cerrojos, semáforos y variables de condición&lt;/a&gt;.
Lamentablemente así se pierde sencillez.&lt;/p&gt;
&lt;p&gt;Para estos lenguajes como Scala o Erlang implementan el modelo &lt;a href="http://en.wikipedia.org/wiki/Actor_model" title="Actor model"&gt;Actor&lt;/a&gt;, mientras
que Go se basa en en el modelo &lt;a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes" title="Communicating sequential processes"&gt;CSP&lt;/a&gt;. Ambos casos, pese a &lt;a href="http://www.informit.com/articles/article.aspx?p=1768317"&gt;sus diferencias&lt;/a&gt;,
fundamentalmente operan tal y como hemos descrito. También entraría dentro de
este tipo de modelos el &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html"&gt;mecanismo de comunicación entre hilos&lt;/a&gt; que implementa &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; a través del uso de señales y &lt;em&gt;slots&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Multiproceso&lt;/h2&gt;
&lt;p&gt;En los sistemas operativos que implementan una llamada al sistema tipo
&lt;a href=""&gt;fork&lt;/a&gt; se pueden crear de forma sencilla múltiples procesos, en lugar de
hilos, para manejar la concurrencia. La forma de hacerlo no difiere mucho de
la programación multihilo, aunque es necesario tener en cuenta los siguientes
aspectos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Escala peor, ya que soportar cientos de clientes implica la creación de
cientos de procesos y estos son más costosos que los hilos, en lo que respecta
al consumo de recursos del sistema.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No es tan sencilla como la programación multihilo, porque hay que
indicar explícitamente que regiones de la memoria se desea compartir entre
procesos. Además, normalmente sólo se puede establecer que recursos van a
ser compartidos durante la creación de cada proceso, no pudiendo compartir
otros recursos posteriormente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Los procesos ofrecen mejor aislamiento que los hilos y por tanto mayor
robustez y seguridad.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Respecto a esto último debemos de tener en cuenta que un acceso indebido a la
memoria en uno de los procesos, quizás ocasionada por una petición de un
cliente mal formateada, no tiene por qué provocar la caída de toda la aplicación;
a diferencia de lo que pasaría en una aplicación multihilo. De igual manera,
si un atacante tomara el control de uno de los procesos tendría más difícil tener
acceso a los otros. Además, los procesos tienen características interesantes de
las que carecen los hilos, como la posibilidad de ejecutarse como un usuario
concreto del sistema o en un jaula &lt;a href="http://es.wikipedia.org/wiki/Chroot" title="chroot"&gt;chroot&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Agrupamiento de hilos&lt;/h2&gt;
&lt;p&gt;Aunque más baratos que los procesos, los hilos tienen un coste que llegado el
momento puede hacer que nuestra aplicación no pueda escalar ya que no se puedan
crear más hilos.&lt;/p&gt;
&lt;p&gt;Para evitarlo se puede hacer uso del patrón &lt;a href="http://en.wikipedia.org/wiki/Thread_pool_pattern"&gt;agrupamiento de hilos&lt;/a&gt;
(o &lt;em&gt;thread pool&lt;/em&gt;) que básicamente consiste en:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crear un grupo de hilos, una cola con las tareas que deben ser ejecutadas en
dichos hilos y otra cola donde almacenar los resultados de las tareas ejecutadas.
&lt;a href="http://commons.wikimedia.org/wiki/File:Thread_pool.svg"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/500px-Thread_pool.svg.png" alt="Sencillo esquema de un agrupamiento de hilos" class="right-float"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cada vez que un hilo del agrupamiento queda libre, toma la siguiente tarea
de la cola y la ejecuta hasta que es completada, insertando los resultados en
la cola correspondiente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cuando la cola de tareas está vacía, los hilos pueden morir o dormir hasta
que hayan más tareas.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Número de hilos&lt;/h3&gt;
&lt;p&gt;Obviamente el número concreto de hilos del agrupamiento se debe ajustar con
el objeto de conseguir el mayor rendimiento posible. Con tareas &lt;em&gt;limitadas por
la E/S&lt;/em&gt; el número generalmente depende de la capacidad del sistema y del tipo de
tarea, por lo que suele ser necesario determinarlo experimentalmente.&lt;/p&gt;
&lt;p&gt;Además, en ocasiones el número de hilos en el agrupamiento puede ser ajustado
por el programa dinámicamente, en base al número de tareas pendientes de ser
ejecutadas. Así la aplicación podría incorporar hilos al agrupamiento sólo si la
cantidad de tareas a la espera supera cierto umbral, y únicamente hasta el
máximo por encima del cual hemos determinado que el rendimiento se vería penalizado.&lt;/p&gt;
&lt;h3&gt;Soporte&lt;/h3&gt;
&lt;p&gt;Debido a la proliferación de los procesadores multinúcleo, es cada vez más
común que los diferentes lenguajes dispongan de alguna implementación del
patrón &lt;em&gt;agrupamiento de hilos&lt;/em&gt;, ya sea en la librería que lo acompaña o a
través de librerías de terceros, con el fin de facilitar la programación
paralela.&lt;/p&gt;
&lt;p&gt;Plataformas como Java y .NET lo incorporan, así como el sistema operativo Mac
OS X bajo el nombre de &lt;a href="http://en.wikipedia.org/wiki/Grand_Central_Dispatch"&gt;Grand Central Dispatch&lt;/a&gt; (GCD).
En el caso de C++ existen múltiples librerías, como por ejemplo Intel &lt;a href="http://es.wikipedia.org/wiki/Intel_Threading_Building_Blocks" title="Intel Threading Building Blocks"&gt;TBB&lt;/a&gt;, diseñada
específicamente para facilitar que los programas aprovechen las ventajas de
los sistemas multinúcleo, o &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, que incorpora su propia implementación del
patrón a través de la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthreadpool.html" title="QThreadPool"&gt;QThreadPool&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloWorldTask&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QRunnable&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello world from thread&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="n"&gt;HelloWorldTask&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HelloWorldTask&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
 &lt;span class="c1"&gt;// QThreadPool takes ownership and deletes &amp;#39;hello&amp;#39; automatically&lt;/span&gt;
 &lt;span class="n"&gt;QThreadPool&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;globalInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Ejecución basada en eventos&lt;/h2&gt;
&lt;p&gt;Como ya hemos comentado, los hilos tienen un coste que no se puede despreciar
cuando el número que necesitamos es alto. Además, en muchos problemas de
concurrencia las tareas están muy &lt;em&gt;limitadas por la E/S&lt;/em&gt;, por lo que a penas se
obtiene beneficio alguno de la posibilidad de ejecutarlas en paralelo. En esos
casos la forma de gestionar la concurrencia que se ha demostrado más eficaz es
la ejecución basada en eventos.&lt;/p&gt;
&lt;p&gt;Simplificando, sus principales características son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Generalmente sólo se usa un hilo de ejecución. Por tanto no es posible la
ejecución paralela de código, lo que implica que si se ejecutan tareas &lt;em&gt;limitadas
por la CPU&lt;/em&gt; se podría estar bloqueando las peticiones de otros clientes al
ocupar el hilo de ejecución.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Toda la E/S es asíncrona, para evitar el bloqueo de las peticiones de los
clientes y que las operaciones de E/S se ejecuten en paralelo, tanto entre sí
como respecto al código en el hilo de ejecución.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hace uso de un bucle de mensajes a donde llegan los eventos de E/S
notificados por el sistema operativo. Desde este bucle se llama a las rutinas
de &lt;em&gt;callback&lt;/em&gt; correspondientes, donde la aplicación tiene el código que da
respuesta a dichos eventos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1vr_1x_UQAW905hjxALQE0hGB6ii55dIiKOsqFD9lw_M/pub?w=809&amp;amp;h=367" alt="Ejecución basada en eventos" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;Estas rutinas de &lt;em&gt;callback&lt;/em&gt; pueden tener nombres predefinidos, como es el caso
del sistema de señales de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, o especificarse a través de un argumento
adicional indicado cuando se solicitó la E/S.&lt;/p&gt;
&lt;p&gt;Por lo general los programas que gestionan la concurrencia de esta manera
tiene muchos menos requerimientos de memoria que los que usan múltiples hilos
o procesos, lo que les permite escalar mejor. Este es por ejemplo el caso del
servidor web Nginx o el servidor de aplicaciones en Javascript Node.js cuando
se los compara con Apache, un servidor web que según la configuración utiliza
un hilo o un proceso por conexión.&lt;/p&gt;
&lt;h2&gt;Corrutinas&lt;/h2&gt;
&lt;p&gt;Aunque eficiente, la ejecución basada en eventos puede ser más compleja de
implementar ya que el control del flujo de ejecución se invierte. Es decir, en
un patrón procedural normal la interacción se expresa de forma imperativa,
haciendo llamadas a procedimientos, funciones o métodos. En su lugar, en la
ejecución basada en eventos se especifican las respuestas deseadas a los
eventos notificados, siendo imposible desarrollar una función que contenga
todo el código implicado en una tarea concreta.&lt;/p&gt;
&lt;p&gt;Esto se puede resolver incorporando el uso de &lt;a href="http://en.wikipedia.org/wiki/Coroutine"&gt;corrutinas&lt;/a&gt;.
Estas son una generalización de los procedimientos o subrutinas convencionales
de las que se puede salir por diversos puntos para posteriormente volver y
reiniciar la ejecución desde el último punto de retorno.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1CiGFeo02uYTWL3Y31u-RpIKBjlLUDrIEaXj8e1_geLw/pub?w=851&amp;amp;h=330" alt="Ejemplo de corrutina" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;En el contexto de la ejecución basada en eventos, las distintas tareas que deben
ser ejecutadas pueden programarse como corrutinas, mientras que las operaciones
de E/S, a parte de solicitar la operación correspondiente de manera asíncrona,
forzarían la salida de la corrutina. Así el bucle de mensajes, en lugar de
invocar el &lt;em&gt;callback&lt;/em&gt; de una operación completada, sólo tiene que restablecer
la ejecución de la corrutina allí donde fue interrumpida.&lt;/p&gt;
&lt;p&gt;Los corrutinas son soportadas por algunos lenguajes de alto nivel como Ruby,
Lua o Go. Este último incluso permite planificar su ejecución en paralelo
dentro de un agrupamiento de hilos, dando lugar a lo que sus desarrolladores
ha denominado &lt;em&gt;goroutines&lt;/em&gt;. Otro ejemplo destacable es Python, que si bien no
las soporta en el intérprete estándar, si lo hacen a través de &lt;a href="http://en.wikipedia.org/wiki/Stackless_Python" title="Stackless Python"&gt;Stackless
Python&lt;/a&gt;. Este intérprete es usado en productos como Eve Online o Second Live,
donde el número de conexiones simultáneas es muy alto. Por lo demás la mayor
parte de los lenguajes más populares no lo soportan, ni en el propio lenguaje
ni a través de su librería estándar, con la excepción de C++ a través de la
librería &lt;a href="http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html" title="Boost.Coroutine"&gt;Boost.Coroutine&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Concurrency_pattern"&gt;Concurrency pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#cms"&gt;Java SE 6 - The Concurrent Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.informit.com/articles/article.aspx?p=1768317"&gt;A Tale of Two Concurrency Models: Comparing the Go and Erlang Programming Languages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Thread_pool_pattern"&gt;Thread pool pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/"&gt;Understanding the node.js event loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Coroutine"&gt;Coroutine&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sat, 06 Apr 2013 00:00:00 +0100</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-06:concurrencia.html</guid><category>concurrencia</category><category>hilos</category><category>bucle de mensajes</category><category>multiproceso</category><category>multihilo</category><category>callbacks</category><category>qthreadpool</category></item><item><title>Uso de la memoria como un dispositivo de E/S</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/uso-de-la-memoria-como-un-dispositivo-de-es.html</link><description>&lt;p&gt;Algunas libreras se diseñan específicamente para leer y/o escribir datos en
dispositivos de entrada/salida. Por ejemplo, una librería desarrollada en C++ para
codificar y decodificar archivos MP3 recibiría objetos &lt;a href="http://www.cplusplus.com/reference/istream/istream/" title="std::istream"&gt;std::istream&lt;/a&gt; o
&lt;a href="http://www.cplusplus.com/reference/ostream/ostream/" title="std::ostream"&gt;std::ostream&lt;/a&gt; para indicar el flujo del que leer o en el que escribir los datos
respectivamente:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/istream/istream/" title="std::istream"&gt;std::istream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Clase de flujo de entrada. Los objetos de esta clase pueden leer e interpretar
la entrada de datos a partir de secuencias de caracteres.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/ostream/ostream/" title="std::ostream"&gt;std::ostream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Clase de flujo de salida. Los objetos de esta clase pueden escribir secuencias
de caracteres y representar como cadenas otras clases de datos.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Por lo tanto, si deseáramos guardar o recuperar audio codificado en MP3 en un
medio de almacenamiento concreto, necesitaríamos disponer de una clase que nos
ofrezca el acceso al mismo a través de la interfaz de flujos de C++ de
entrada/salida descrita por las clases anteriores.&lt;/p&gt;
&lt;p&gt;Objetos como &lt;a href="http://www.cplusplus.com/reference/iostream/cin/" title="std::cin"&gt;std::cin&lt;/a&gt; y &lt;a href="http://www.cplusplus.com/reference/iostream/cout/" title="std::cout"&gt;std::cout&lt;/a&gt; son instancias de estas clases, lo que
permitiría que nuestra aplicación codificara y decodificara audio hacia y
desde la entrada/salida estándar del proceso. Lo mismo ocurre con
&lt;a href="http://www.cplusplus.com/reference/fstream/ifstream/" title="std::ifstream"&gt;std::ifstream&lt;/a&gt;, &lt;a href="http://www.cplusplus.com/reference/fstream/ofstream/" title="std::ofstream"&gt;std::ofstream&lt;/a&gt; y &lt;a href="http://www.cplusplus.com/reference/fstream/fstream/" title="std::fstream"&gt;std::fstream&lt;/a&gt;; que heredan de las clases
anteriores e implementan la interfaz de flujos de C++ para los archivos. De
esta manera nuestra hipotética librería de MP3 podría codificar y decodificar
datos en este formato hacia y desde dichos archivos.&lt;/p&gt;
&lt;p&gt;En este punto la cuestión que se nos plantea es ¿qué podríamos hacer si,
por ejemplo, quisiéramos codificar el audio para posteriormente transmitirlo
a otro ordenador a través de una red? Teniendo en cuenta lo comentado hasta
ahora, una opción sería codificarlo almacenándolo en un archivo y posteriormente
leer del mismo para transmitir los datos por la red. Obviamente esto dista
de ser ideal ya que sería preferible disponer de una clase que implementara
la interfaz de &lt;a href="http://www.cplusplus.com/reference/ostream/ostream/" title="std::ostream"&gt;std::ostream&lt;/a&gt; para almacenar los datos codificados directamente
en la memoria, evitando tener que dar pasos intermedios como guardarlos y
leerlos de un archivo temporal.&lt;/p&gt;
&lt;p&gt;Por fortuna la librería estándar de C++ nos provee de las clases:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/sstream/istringstream/" title="std::istringstream"&gt;std::istringstream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Flujo de entrada para operar sobre cadenas. Los objetos de esta clase
permiten leer los caracteres del flujo de entrada a partir del contenido
de un objeto &lt;code&gt;std::string&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/sstream/ostringstream/" title="std::ostringstream"&gt;std::ostringstream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Flujo de salida para operar sobre cadenas. Los objetos de esta clase
permiten escribir los caracteres del flujo de salida en un objeto &lt;code&gt;std::string&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/sstream/stringstream/" title="std::stringstream"&gt;std::stringstream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Flujo para operar sobre cadenas. Los objetos de esta clase permiten leer
y escribir en un objeto &lt;code&gt;std::string&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;ofreciéndonos una forma sencilla de almacenar o leer de la memoria del proceso
los datos codificados en MP3, lo que facilitaría cuaĺquier tarea que quisiéramos
realizar con ellos posteriormente.&lt;/p&gt;
&lt;h2&gt;QIODevice&lt;/h2&gt;
&lt;p&gt;En el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; ocurre algo muy parecido. Todas las clases diseñadas
para acceder a dispositivos de entrada/salida reciben un objeto de la clase
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;. Por ejemplo:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qtextstream.html" title="QTextStream"&gt;QTextStream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz adecuada para leer y escribir datos en
formato texto desde un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qdatastream.html" title="QDataStream"&gt;QDataStream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz adecuada para leer y escribir datos binarios
desde un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz independiente del formato para leer archivos de
imágenes desde un dispositivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagewriter.html" title="QImageWriter"&gt;QImageWriter&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz independiente del formato para escribir archivos de
imágenes desde un dispositivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/como-usar-qmovie-en-qt.html" title="QMovie"&gt;QMovie&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase diseñada para reproducir películas leidas con &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;
desde un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;La clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; no se instancia directamente para crear objetos, sino que
su función es definir una interfaz genérica válida para todo tipo de
dispositivos de entrada/salida. En el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; diversas clases
heredan de esta, implementando la interfaz &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; para un dispositivo
concreto:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html" title="QTcpSocket"&gt;QTcpSocket&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; que permite establecer una conexión
TCP y transferir flujos de datos a través de ella.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; para leer y escribir archivos de texto
y binarios, así como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/resources.html"&gt;recursos de la aplicación&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html" title="QProcess"&gt;QProcess&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; que permite ejecutar un programa externo
y comunicarnos con él.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; que implementa dicha interfaz de
dispositivos sobre un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbytearray.html" title="QByteArray"&gt;QByteArray&lt;/a&gt;. Ésta es una clase que provee una interfaz
para manipular un &lt;em&gt;array&lt;/em&gt; de bytes en la memoria.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Ejemplos con imágenes&lt;/h2&gt;
&lt;p&gt;Para ilustrar lo comentado vamos a codificar y decodificar una imagen &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;
directamente desde la memoria.&lt;/p&gt;
&lt;h3&gt;Codificando una imagen en la memoria&lt;/h3&gt;
&lt;p&gt;Supongamos que &lt;code&gt;image&lt;/code&gt; es un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; que queremos codificar en formato
PNG, guardando el resultado en un &lt;em&gt;array&lt;/em&gt; en la memoria para su procesamiento
posterior (p. ej. para transmitirlo a través de una red de comunicaciones).&lt;/p&gt;
&lt;p&gt;Hacerlo es tan sencillo como incorporar las siguientes líneas al programa:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;png&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como hemos comentado, &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt; es un clase heredada de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;, por lo
que podemos usarla allí donde se requiera un dispositivo de entrada/salida.
Por defecto los objetos de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt; se crean con un &lt;em&gt;buffer&lt;/em&gt; interno de tipo
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbytearray.html" title="QByteArray"&gt;QByteArray&lt;/a&gt;, al que podemos acceder directamente invocando el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html#buffer" title="QBuffer::buffer()"&gt;buffer&lt;/a&gt;(). Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QByteArray&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Guardamos en un string los primeros 6 bytes de la imagen en PNG&lt;/span&gt;
&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;pngHeader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constData&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pngHeader&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;lo que mostraría por la salida estándar algo como lo siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;�&lt;/span&gt;&lt;span class="n"&gt;PNG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta forma de guardar los datos es adecuada cuando no necesitamos más control
sobre las opciones del formato en cuestión. Si por el contrario queremos
controlar el nivel de compresión, el de gamma o algunos otros parámetros
específicos del formato, tendremos que emplear un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagewriter.html" title="QImageWriter"&gt;QImageWriter&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QImageWriter&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;jpeg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setCompression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Decodificando una imagen almacenada en la memoria&lt;/h3&gt;
&lt;p&gt;Ahora hagámoslo en sentido inverso. Si tenemos un puntero &lt;code&gt;const char *bytes&lt;/code&gt;
a una zona de memoria con &lt;code&gt;size&lt;/code&gt; bytes donde se almacena una imagen en formato
PNG y queremos cargarla en un objeto &lt;code&gt;QImage&lt;/code&gt;, sólo tenemos que asignar los
datos a un objeto &lt;code&gt;QBuffer&lt;/code&gt; y leer desde el:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDevice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;png&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;o lo que es equivalente y mucho más simple:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;png&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbytearray.html" title="QByteArray"&gt;QByteArray&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagewriter.html" title="QImageWriter"&gt;QImageWriter&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Wed, 13 Mar 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-13:uso-de-la-memoria-como-un-dispositivo-de-es.html</guid><category>qt</category><category>qbuffer</category><category>qiodevice</category><category>qimagewriter</category><category>qimagereader</category></item><item><title>Implementando un protocolo con Protocol Buffers</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/implementando-un-protocolo-con-protocol-buffers.html</link><description>&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt; es un mecanismo sencillo para serializar estructuras de
datos, de tal forma que los datos así codificados pueden ser almacenados
o enviados a través de una red de comunicaciones. Esto nos ofrece una forma
sencilla de crear nuestro propio protocolo de comunicaciones, adaptado a las
necesidades de un problema concreto.  &lt;/p&gt;
&lt;p&gt;Los pasos concretos para usar &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt; son lo siguientes:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Especificar la estructura de datos del mensaje del nuevo protocolo en un
 archivo &lt;code&gt;.proto&lt;/code&gt;. Estos archivos se escriben utilizando un &lt;a href="https://developers.google.com/protocol-buffers/docs/proto"&gt;lenguaje de
 descripción de interfaz&lt;/a&gt;
 que es propio de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ejecutar el compilador de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt;, para el lenguaje de la
 aplicación, sobre el archivo &lt;code&gt;.proto&lt;/code&gt; con el objeto de generar las clases
 de acceso a los datos. Estas proporcionan &lt;em&gt;accesores&lt;/em&gt; para cada campo, así
 como métodos para serializar y deserializar los mensajes a y desde
 una secuencia de bytes. &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Incluir las clases generadas en nuestra aplicación y usarlas para generar
 instancias del mensaje, serializarlas y enviar los mensajes codificados o
 leer dichos mensajes, deserializarlos y reconstruir las instancias de los
 mensajes para acceder a sus campos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Definir la estructura del mensaje&lt;/h2&gt;
&lt;p&gt;Supongamos que conectados a una red tenemos un conjunto de &lt;a href="http://www.arduino.cc/" title="Arduino"&gt;Arduinos&lt;/a&gt; equipados
con varios sensores de diferente tipo: temperatura, humedad, luminosidad,
movimiento, etc. Cada &lt;a href="http://www.arduino.cc/" title="Arduino"&gt;Arduino&lt;/a&gt; tiene un nombre que lo identifica y su función
es leer el estado de dichos sensores, a intervalos regulares, y enviar mensajes
con los datos de los mismos a un servidor.&lt;/p&gt;
&lt;p&gt;Teniendo esto presente, el archivo &lt;code&gt;.proto&lt;/code&gt; podría ser el siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;sensorsreport&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proto&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Protocolo&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;comunicaciones&lt;/span&gt; &lt;span class="n"&gt;con&lt;/span&gt; &lt;span class="n"&gt;Arduino&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="n"&gt;SensorsReport&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;deviceName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Nombre&lt;/span&gt; &lt;span class="n"&gt;del&lt;/span&gt; &lt;span class="n"&gt;Arduino&lt;/span&gt;
    &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;uint64&lt;/span&gt; &lt;span class="n"&gt;timestamp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Seg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;desde&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="sr"&gt;/1/&lt;/span&gt;&lt;span class="mi"&gt;1970&lt;/span&gt;

    &lt;span class="n"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;SensorType&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;HUMIDITY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;LUMINOSITY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;MOTION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;TEMPERATURE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="n"&gt;SensorStatus&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;SensorType&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;SensorStatus&lt;/span&gt; &lt;span class="n"&gt;sensors&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Vector&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;estados&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt;
                                        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;sensores&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se puede observar el lenguaje usado en los archivos &lt;code&gt;.proto&lt;/code&gt; es muy
sencillo. Solamente hay que indicar el nombre y el tipo de cada campo,
así como si es opcional (&lt;em&gt;optional&lt;/em&gt;), requerido (&lt;em&gt;required&lt;/em&gt;) o se repite
(&lt;em&gt;repeated&lt;/em&gt;).&lt;/p&gt;
&lt;p&gt;En &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt; los campos se etiquetan de manera única con un entero
que después es utilizado en la codificación binaria para identificarlos.&lt;/p&gt;
&lt;h2&gt;Clases de acceso a los datos&lt;/h2&gt;
&lt;p&gt;Una vez tenemos la definición de la estructura del mensaje, podemos invocar
al compilador de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt; para generar las clases de acceso a los
datos.&lt;/p&gt;
&lt;h3&gt;Desde línea de comandos&lt;/h3&gt;
&lt;p&gt;Desde línea de comandos generar las clases es tan sencillo como:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Invocar el compilador de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;protoc --cpp_out&lt;span class="o"&gt;=&lt;/span&gt;. sensorsreport.proto
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;que genera los archivos &lt;code&gt;sensorsreport.pb.cc&lt;/code&gt; y &lt;code&gt;sensorsreport.pb.h&lt;/code&gt; en el
directorio actual.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Incluir el archivo de cabecera en nuestro código fuente allí donde vaya a
    ser utilizado:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;quot;sensorsreport.pb.h&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Compilar el ejecutable junto con el archivo &lt;code&gt;sensorsreport.pb.cc&lt;/code&gt; y enlazar
    con la librería &lt;code&gt;protobuf&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Con qmake&lt;/h3&gt;
&lt;p&gt;Si estamos usando &lt;code&gt;qmake&lt;/code&gt; para construir nuestro proyecto (como es el caso cuando
desarrollamos con el IDE Qt Creator) lo más cómodo es que este se encargue de
invocar al compilador &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt; para generar las clases de acceso
de forma automática.&lt;/p&gt;
&lt;p&gt;En este sentido el archivo &lt;code&gt;protobuf.pri&lt;/code&gt; del proyecto &lt;a href="http://code.google.com/p/ostinato"&gt;ostinato&lt;/a&gt;
puede ser de gran ayuda con algunos cambios:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;#
# Qt qmake integration with Google Protocol Buffers compiler protoc
#
# To compile protocol buffers with qt qmake, specify PROTOS variable and
# include this file
#
# Example:
# PROTOS = a.proto b.proto
# include(protobuf.pri)
#
# By default protoc looks for .proto files (including the imported ones) in
# the current directory where protoc is run. If you need to include additional
# paths specify the PROTOPATH variable
#

PROTOPATH += . \
             ..
PROTOPATHS =
for(p, PROTOPATH):PROTOPATHS += --proto_path=$${p}

protobuf_decl.name  = protobuf header
protobuf_decl.input = PROTOS
protobuf_decl.output  = &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;QMAKE_FILE_BASE&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.pb.h
protobuf_decl.commands = protoc --cpp_out=&amp;quot;.&amp;quot; $${PROTOPATHS} &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;E&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
protobuf_decl.variable_out = GENERATED_FILES
QMAKE_EXTRA_COMPILERS += protobuf_decl

protobuf_impl.name  = protobuf implementation
protobuf_impl.input = PROTOS
protobuf_impl.output  = &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;QMAKE_FILE_BASE&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.pb.cc
protobuf_impl.depends  = &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;QMAKE_FILE_BASE&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.pb.h
protobuf_impl.commands = $$escape_expand(\n)
protobuf_impl.variable_out = GENERATED_SOURCES
QMAKE_EXTRA_COMPILERS += protobuf_impl

LIBS += -lprotobuf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para usarlo sólo tenemos que:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Crear el archivo &lt;code&gt;protobuf.pri&lt;/code&gt; con el contenido anterior en el directorio
 del proyecto.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Abrir el archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto y añadir las líneas:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;PROTOS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sensorsreport&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;proto&lt;/span&gt;
&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;protobuf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Interfaz de Protocol Buffers&lt;/h2&gt;
&lt;p&gt;Si abrimos el archivo &lt;code&gt;sensorsreport.pb.h&lt;/code&gt; veremos que la clase &lt;code&gt;SensorsReport&lt;/code&gt;
nos ofrece los siguientes &lt;em&gt;accesores&lt;/em&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// required string deviceName = 1;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;has_devicename&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;clear_devicename&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;devicename&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set_devicename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set_devicename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set_devicename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mutable_devicename&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;release_devicename&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// required uint64 timestamp = 2;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;has_timestamp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;clear_timestamp&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;google&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;protobuf&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;uint64&lt;/span&gt; &lt;span class="n"&gt;timestamp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;set_timestamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;google&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;protobuf&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;uint64&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// repeated .SensorsReport.SensorStatus sensors = 3;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sensors_size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;clear_sensors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SensorsReport_SensorStatus&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;sensors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SensorsReport_SensorStatus&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;mutable_sensors&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;index&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SensorsReport_SensorStatus&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;add_sensors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;google&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;protobuf&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RepeatedPtrField&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SensorsReport_SensorStatus&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt;
    &lt;span class="n"&gt;sensors&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;google&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;protobuf&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;RepeatedPtrField&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;SensorsReport_SensorStatus&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;*&lt;/span&gt;
    &lt;span class="n"&gt;mutable_sensors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;a los campos del mensaje. Además  se define el &lt;code&gt;enum&lt;/code&gt; &lt;code&gt;SensorsReport::SensorStatus&lt;/code&gt;
y la clase &lt;code&gt;SensorsReport::SensorStatus&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Todos los detalles sobre el código generado por el compilador están documentados
en la &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated"&gt;referencia del código generado en C++&lt;/a&gt;.
Eso incluye &lt;a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated#fields"&gt;los accesores creados&lt;/a&gt;
según el tipo de definición de los campos.&lt;/p&gt;
&lt;h3&gt;Campos individuales&lt;/h3&gt;
&lt;p&gt;Por ejemplo, para definiciones de este tipo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;optional&lt;/span&gt; &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;required&lt;/span&gt; &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;el compilador genera los siguientes &lt;em&gt;accesores&lt;/em&gt;:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;bool has_foo() const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Devuelve &lt;code&gt;true&lt;/code&gt; si el campo &lt;code&gt;foo&lt;/code&gt; tiene un valor.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;int32 foo() const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Devuelve el valor del campo &lt;code&gt;foo&lt;/code&gt;. Si el campo no tiene valor, devuelve el
valor por defecto.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;void set_foo(int32 value)&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Fija el valor del campo. Después de llamar a este método, llamar a &lt;code&gt;has_foo()&lt;/code&gt;
devolvería &lt;code&gt;true&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;void clear_foo()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Limpia el valor del campo. Después de llamar a este método, llamar a &lt;code&gt;has_foo()&lt;/code&gt;
devolvería &lt;code&gt;false&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;que nos permiten hacer cosas tales como:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;SensorsReport&lt;/span&gt; &lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_devicename&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;ARDUINO01&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;set_timestamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1362507283&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Device name: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;devicename&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Timestamp: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;timestamp&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Campos con repeticiones&lt;/h3&gt;
&lt;p&gt;Mientras que para definiciones de este tipo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;repeated&lt;/span&gt; &lt;span class="n"&gt;int32&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El compilador genera los siguientes &lt;em&gt;accesores&lt;/em&gt;:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;int foo_size() const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Devuelve el número de elementos en el campo.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;int32 foo(int index) const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Devuelve el elemento en el índice indicado.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;void set_foo(int index, int32 value)&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Fija el valor del elemento en el índice indicado.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;void add_foo(int32 value)&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Añade un nuevo elemento con el valor indicado.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;void clear_foo()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Elimina todos los elementos del campo.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;const RepeatedField&amp;lt;int32&amp;gt;&amp;amp; foo() const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Devuelve el objeto &lt;code&gt;RepeatedField&lt;/code&gt;que almacena todos los elementos. Este
contenedor proporciona iteradores al estilo de otros contenedores de la STL.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Serialización y deserialización&lt;/h2&gt;
&lt;p&gt;Cada clase de un mensaje ofrece un conjunto de métodos para codificar
(serializar) y decodificar (deserializar) los mensajes:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;bool SerializeToString(string* output) const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Serializa el mensaje y almacena los bytes en la cadena especificada en el
argumento &lt;code&gt;output&lt;/code&gt;. Nótese que estos bytes son binarios, no texto, y que la
clase &lt;code&gt;std::string&lt;/code&gt; se usa como un mero contenedor.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;bool ParseFromString(const string&amp;amp; data)&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Deserializa un mensaje codificado en la cadena especificada en el argumento
&lt;code&gt;data&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;bool SerializeToOstream(ostream* output) const&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Escribe el mensaje serializado en el flujo &lt;code&gt;ostream&lt;/code&gt; indicado.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;bool ParseFromIstream(istream* input)&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Deserializa un mensaje leido del flujo &lt;code&gt;istream&lt;/code&gt; indicado.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Almacenamiento y transmisión por red de múltiples mensajes&lt;/h2&gt;
&lt;p&gt;El formato de codificación de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" title="Protocol Buffers"&gt;Protocol Buffers&lt;/a&gt; no está auto-limitado. Es decir,
no incluye marcas que permitan identificar el principio y fin de los mensajes.
Esto es un problema si se quieren almacenar o enviar varios mensajes en un mismo
flujo de datos.&lt;/p&gt;
&lt;p&gt;La forma más sencilla de resolverlo es:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Escribir el tamaño del mensaje codificado y después escribir el mensaje en
 si mismo.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Serializar el mensaje&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SerializeToString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;uint32&lt;/span&gt; &lt;span class="n"&gt;bufferSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Abrir el archivo de destino y escribir el mensaje&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// std::ofstream ofs(...);&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;ofs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;reinterpret_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
          &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="n"&gt;ofs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_str&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Al leer, leer primero el tamaño del mensaje, después leer los bytes
 indicados en un  &lt;em&gt;buffer&lt;/em&gt; independiente y finalmente deserializar el mensaje
 desde dicho &lt;em&gt;buffer&lt;/em&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Abrir el archivo de origen y leer el tamaño del mensaje&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="c1"&gt;// std::ifstream ifs(...);&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;uint32&lt;/span&gt; &lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="c1"&gt;// Leer el mensaje&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;resize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ifs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const_cast&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c_str&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;bufferSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Deserializar&lt;/span&gt;
&lt;span class="n"&gt;report&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ParseFromString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;En la misma documentación de la librería se nos sugiere una solución más
conveniente usando las clases &lt;code&gt;CodedInputStream&lt;/code&gt; y &lt;code&gt;CodedOutputStream&lt;/code&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href="https://developers.google.com/protocol-buffers/docs/techniques#streaming"&gt;Streaming Multiple Messages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If you want to avoid copying bytes to a separate buffer, check out the
CodedInputStream class (in both C++ and Java) which can be told to limit
reads to a certain number of bytes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/"&gt;Protocol Buffers - Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/docs/proto"&gt;Language Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated"&gt;C++ Generated Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://code.google.com/p/protobuf/"&gt;protobuf - Protocol Buffers - Google's data interchange format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/docs/techniques#streaming"&gt;Streaming Multiple Messages&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.io.coded_stream"&gt;Protocol Buffers - coded_stream.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/2340730/are-there-c-equivalents-for-the-protocol-buffers-delimited-i-o-functions-in-ja"&gt;Stackoverflow - Are there C++ equivalents for the Protocol Buffers delimited I/O functions in Java?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://stackoverflow.com/questions/11640864/length-prefix-for-protobuf-messages-in-c"&gt;Stackoverflow - Length prefix for protobuf messages in C++&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Tue, 05 Mar 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-05:implementando-un-protocolo-con-protocol-buffers.html</guid><category>protobuf</category><category>serialización</category></item><item><title>Qt Network</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/qt-network.html</link><description>&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; proporciona un conjunto de API de comunicaciones a través del módulo
&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt;. Este ofrece tanto clases de bajo nivel para comunicación
mediante protocolos de transporte, como TCP y UDP, como clases de alto nivel que
implementan operaciones usando los protocolos de nivel de aplicación más
communes, como HTTP o FTP.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; incorpora este módulo por dos motivos fundamentales:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Aunque la mayor parte de los sistemas operativos modernos proporcionan un
 API de acceso a red basado en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html"&gt;BSD sockets&lt;/a&gt;,
 algunos introducen funcionalidades adicionales para adaptarlo al modelo
 de programación preferente en el sistema en cuestión. Este, por ejemplo,
 es el caso de Windows y la librería &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html"&gt;Winsock&lt;/a&gt;
 que incorpora. Por tanto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, gracias a su módulo &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt;, nos
 proporciona una forma portable de acceder a los servicios de red de los
 sistemas operativos soportados sin tener que preocuparnos por las
 particularidades de cada uno.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Las operaciones de red suelen requerir mucho tiempo antes de completarse,
 por lo que usarlas en un &lt;em&gt;slot&lt;/em&gt; del hilo principal implica el bloqueo del bucle
 de mensajes de la aplicación. Por fortuna el API &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html"&gt;BSD sockets&lt;/a&gt;
 permite tanto el uso síncrono como asíncrono de la interfaz. Esta última
 forma de utilizarla evita el bloqueo del bucle de mensajes al impedir que las
 llamadas a la interfaz se bloqueen hasta que las operaciones de red son
 completadas. Sin embargo implican una forma de programar mucho más compleja
 para el desarrollador.&lt;/p&gt;
&lt;p&gt;El API de bajo nivel de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; es asíncrono por diseño,
 ocultando toda esa complejidad detrás del bucle de mensajes y del mecanismo
 de señales y &lt;em&gt;slots&lt;/em&gt; común a todo el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;. Aunque el API de bajo
 nivel ofrece métodos para comunicación síncrona (los métodos &lt;code&gt;waitFor*&lt;/code&gt;),
 en cuyo caso no necesitamos bucle de mensajes, su uso no está recomendado
 si no es en un hilo diferente al hilo principal. Además las clases del API
 de alto nivel no ofrecen métodos síncronos, por lo que si se usan es
 obligatorio disponer de un bucle de mensajes.&lt;/p&gt;
&lt;p&gt;Debemos tener en cuenta que las API del módulo &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; se pueden usar
 desde hilos diferentes al hilo principal ya que cada hilo gestionado por la
 clase &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html"&gt;QThread&lt;/a&gt;
 tiene su propio bucle de mensajes, que se inicia automáticamente en el método
 &lt;code&gt;QThread::run()&lt;/code&gt; por defecto.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Funcionalidad&lt;/h2&gt;
&lt;p&gt;El módulo &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; ofrece las siguientes interfaces:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;QNetworkRequest&lt;/code&gt;, &lt;code&gt;QNetworkReply&lt;/code&gt; y &lt;code&gt;QNetworkAccessManager&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Es una colección de clases que proporcionan una abstracción de alto nivel
sobre operaciones y protocolos de comunicación comunes, por ejemplo HTTP y FTP.
Cada instancia de la clase &lt;code&gt;QNetworkRequest&lt;/code&gt; representa una petición u operación
contra un servicio en red, mientras que las instancias de la clase
&lt;code&gt;QNetworkReply&lt;/code&gt; representan la respuesta a esas peticiones. La coordinación
de toda esta actividad es responsabilidad de &lt;code&gt;QNetworkAccessManager&lt;/code&gt;, que
se encarga de entregar a la red las peticiones una vez han sido creadas y de
emitir señales con la respuesta a las mismas cuando son recibidas. También
coordina el uso de &lt;em&gt;cookies&lt;/em&gt;, peticiones de autenticación y el uso de
servidores &lt;em&gt;proxy&lt;/em&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QTcpSocket&lt;/code&gt; y &lt;code&gt;QTcpServer&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;TCP es el protocolo de comunicación utilizado por diversos protocolos de
Internet, como HTTP o FTP. &lt;code&gt;QTcpSocket&lt;/code&gt; proporciona acceso de bajo nivel a
dicho protocolo. Permite establecer una conexión con una dirección IP y puerto
determinados, así como enviar y recibir datos. Estas operaciones son
asíncronas, por lo que no bloquean la ejecución del hilo, siendo la clase la
que notifica mediante señales tanto las condiciones de error como de cuándo
se dispone de nuevos datos para leer. Si lo que se desea es crear una
aplicación que reciba conexiones TCP entrantes (como un servidor), lo
conveniente es utilizar la clase &lt;code&gt;QTcpServer&lt;/code&gt;. Ésta nos permite escuchar en
una dirección IP y puerto concretos y aceptar las conexiones entrantes por parte
de los clientes. Cada vez que se acepta el intento de conexión de un cliente,
se obtiene una instancia de la clase &lt;code&gt;QTcpSocket&lt;/code&gt; con la que podemos
comunicarnos con él.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QUdpSocket&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;UDP es un protocolo de comunicación que también es utilizado por diversos
protocolos de Internet. &lt;code&gt;QUdpSocket&lt;/code&gt; proporciona acceso de bajo nivel a
dicho protocolo. Permite enviar y recibir paquetes de datos a una dirección IP
y puerto concretos, ya que a diferencia de TCP, UDP no provee un flujo continuo
de datos sino que opera mediante el envío de paquetes. Tampoco se provee una
clase específica para escuchar por conexiones entrantes (al estilo de
&lt;code&gt;QTcpServer&lt;/code&gt;), ya que UDP no es un protocolo orientado a conexión. La interfaz
de &lt;code&gt;QUdpSocket&lt;/code&gt; simplemente permite preparar el &lt;em&gt;socket&lt;/em&gt; para aceptar la
recepción de paquetes.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QLocalSocket&lt;/code&gt; y &lt;code&gt;QLocalServer&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Proporcionan una abstracción similar a la de &lt;code&gt;QTcpSocket&lt;/code&gt; y &lt;code&gt;QTcpServer&lt;/code&gt; pero
para &lt;em&gt;sockets&lt;/em&gt; locales. En Windows se implementa haciendo uso de tuberías con
nombre, mientras que en UNIX, Linux y otro sistemas POSIX se utilizan
&lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;sockets de dominio UNIX&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QHostInfo&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se utiliza para obtener la dirección IP asignada a un nombre de máquina
concreto a través del servicio DNS (Domain Name Service). Tanto la clase
&lt;code&gt;QTcpSocket&lt;/code&gt; como &lt;code&gt;QUdpSocket&lt;/code&gt; hacen esto automáticamente cuando se indica
un nombre de máquina y no una dirección IP. Sin embargo la clase &lt;code&gt;QHostInfo&lt;/code&gt;
nos permite hacerlo manualmente, si por cualquier motivo fuera necesario.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QNetworkProxy&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Cada instancia de &lt;code&gt;QNetworkProxy&lt;/code&gt; se usa para describir y configurar la
conexión a un servidor &lt;em&gt;proxy&lt;/em&gt;, que pueden dirigir o filtrar el tráfico
entre ambos extremos de una conexión. Un servidor &lt;em&gt;proxy&lt;/em&gt; puede ser activado
para un socket concreto, a través del método &lt;code&gt;QAbstractSocket::setProxy()&lt;/code&gt;,
antes de conectarlo, o a nivel de toda la aplicación a través
de la función &lt;code&gt;QNetworkProxy::setApplicationProxy()&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QNetworkConfigurationManager&lt;/code&gt; y &lt;code&gt;QNetworkConfiguration&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Estas clases constituyen la interfaz del gestor de portabilidad, que controla
el estado de conectividad del dispositivo, permitiendo iniciar y detener las
interfaces de red así como migrar transparentemente entre puntos de acceso.
La clase &lt;code&gt;QNetworkConfigurationManager&lt;/code&gt; gestiona la lista de configuraciones
de red conocidas por el dispositivo. Una configuración de red describe el
conjunto de parámetros usados al iniciar la interfaz de red y es representada
por instancias de la clase &lt;code&gt;QNetworkConfiguration&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Utilizar Qt Network&lt;/h2&gt;
&lt;p&gt;Para incorpora el módulo en nuestra aplicación, sólo tenemos que incluir la
declaración de sus clases añadiendo la siguiente directiva en aquellos
archivos donde las vayamos a utilizar:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#include &amp;lt;QtNetwork&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para enlazar el módulo con el ejecutable de la aplicación, sólo hay que añadir
la siguiente línea al archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QT&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;network&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hecho esto, la mejor forma de aprender a utilizar los recursos del módulo
&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; es siguiendo los ejemplos disponibles en su documentación:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ejemplos de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html" title="QTcpSocket"&gt;QTcpSocket&lt;/a&gt; y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpserver.html" title="QTcpServer"&gt;QTcpServer&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/fortuneclient.html"&gt;Fortune Client&lt;/a&gt;
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/fortuneserver.html"&gt;Fortune Server&lt;/a&gt;
muestran como desarrollar una aplicación cliente-servidor sobre TCP.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/blockingfortuneclient.html"&gt;Blocking Fortune Client&lt;/a&gt;
muestra como usar la interfaz síncrona de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html" title="QTcpSocket"&gt;QTcpSocket&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/threadedfortuneserver.html"&gt;Threaded Fortune Server&lt;/a&gt;
muestra como desarrollar un servidor multihilo donde cada hilo sirve a un
cliente.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ejemplos de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qudpsocket.html" title="QUdpSocket"&gt;QUdpSocket&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/broadcastsender.html"&gt;Broadcast Sender&lt;/a&gt;
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/broadcastreceiver.html"&gt;Broadcast Receiver&lt;/a&gt;
muestran como desarrollar un emisor y un receptor sobre UDP.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/multicastsender.html"&gt;Multicast Sender&lt;/a&gt;
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/multicastreceiver.html"&gt;Multicast Receiver&lt;/a&gt;
muestran como desarrollar aplicaciones que hagan uso de la
&lt;a href="http://es.wikipedia.org/wiki/Multidifusi%C3%B3n"&gt;multidifusión&lt;/a&gt; (o &lt;em&gt;multicast&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Mon, 04 Mar 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-04:qt-network.html</guid><category>qt</category><category>comunicaciones</category><category>sockets</category></item><item><title>BSD sockets</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html</link><description>&lt;p&gt;&lt;em&gt;POSIX sockets&lt;/em&gt; es una parte de la especificación POSIX&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; que define un API
(Application Programming Interface) para la comunicación entre procesos,
fundamentalmente entre equipos conectados a través de Internet
(&lt;em&gt;socket&lt;/em&gt; de Internet), aunque también soporta la conexión local entre procesos
que se ejecutan en el mismo sistema (&lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;socket de dominio UNIX&lt;/a&gt;
o &lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;socket UNIX&lt;/a&gt;).&lt;/p&gt;
&lt;h2&gt;Historia&lt;/h2&gt;
&lt;p&gt;La primera implementación ampliamente distribuida de la pila de protocolos
TCP/IP lo fue con el UNIX 4.2BSD, que incluía &lt;em&gt;BSD sockets&lt;/em&gt; (o &lt;em&gt;Berkeley sockets&lt;/em&gt;)
como API para las comunicaciones entre procesos usando estos protocolos.&lt;/p&gt;
&lt;p&gt;Las distintas versiones de BSD incorporaban código del UNIX original de AT&amp;amp;T,
por lo que estaban sujetas a la licencia de software de esta empresa. La
licencias de código fuente se estaban volviendo muy costosas, por lo que muchas
empresas y organizaciones comenzaron a interesarse en la liberación independiente
del código de red, que había sido desarrollado enteramente al margen de AT&amp;amp;T,
por lo que no tenía que estar sujeto a los requerimientos de su licencia.&lt;/p&gt;
&lt;p&gt;En junio de 1989 este código fue liberado bajo los términos de la licencia
&lt;a href="http://es.wikipedia.org/wiki/Licencia_BSD"&gt;BSD&lt;/a&gt;. Muchos fabricantes incluyeron
este código directamente en sus propios sistemas, incluso aunque tuvieran sus
propios protocolos propietarios con los que competían entre ellos. Y algunas
compañías comenzaron a usarlo para vender pilas de protocolo TCP/IP para
Windows, hasta que Microsoft incluyó la suya propia en Windows 95, también
derivada del código de BSD.&lt;/p&gt;
&lt;p&gt;Todo esto alimentó el despegue de TCP/IP como protocolo dominante e impuso
los &lt;em&gt;BSD sockets&lt;/em&gt; como API de acceso a la red, de tal forma que hoy en día
todos los sistemas operativos modernos tienen una implementación de &lt;em&gt;BSD
sockets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El API &lt;em&gt;BSD sockets&lt;/em&gt; evolucionó y finalmente fue adoptado en el estándar
POSIX&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, donde algunas funciones fueron deprecadas y eliminadas y
reemplazadas por otras. Aun así el API &lt;em&gt;POSIX sockets&lt;/em&gt; es básicamente el
&lt;em&gt;BSD sockets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;De la misma manera los sistemas Windows incluyen &lt;a href="http://msdn.microsoft.com/es-es/library/windows/desktop/ms740673(v=vs.85).aspx" title="Windows Sockets API"&gt;Winsock&lt;/a&gt;, un API de acceso a
la red derivado de &lt;em&gt;BSD sockets&lt;/em&gt; que sólo difiere de éste en unos
&lt;a href="http://tangentsoft.net/wskfaq/articles/bsd-compatibility.html"&gt;pocos detalles&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Funciones del API&lt;/h2&gt;
&lt;p&gt;Este es un resumen de las funciones proporcionadas por &lt;em&gt;POSIX sockets&lt;/em&gt;:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Crea un nuevo &lt;em&gt;socket&lt;/em&gt;, identificado por un número entero, de cierto tipo y
reserva recursos del sistema para él.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa generalmente en el lado del servidor para asociar un &lt;em&gt;socket&lt;/em&gt; con una
dirección de red, por ejemplo una dirección IP y un puerto concretos.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa en el lado del servidor para hacer que un &lt;em&gt;socket&lt;/em&gt; TCP entre en modo
de escucha a la espera de nuevas conexiones entrantes.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa en el lado del cliente para asignar un número de puerto libre al
&lt;em&gt;socket&lt;/em&gt;. En el caso de &lt;em&gt;sockets&lt;/em&gt; TCP, intenta establecer una nueva conexión TCP
con un &lt;em&gt;socket&lt;/em&gt; a la escucha en otro puerto y dirección IP.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa en el lado del servidor para aceptar una conexión entrante e intentar
crear una nueva conexión TCP con el cliente remoto. Si tiene éxito, crea un
nuevo socket asociado con esta pareja concreta de direcciones en ambos
extremos de la conexión.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;send()&lt;/code&gt; y &lt;code&gt;recv()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; y &lt;code&gt;read()&lt;/code&gt; o &lt;code&gt;sendto()&lt;/code&gt; y &lt;code&gt;recvfrom()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usan para enviar y recibir datos hacia y desde el otro extremo de la conexión.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Hace que el sistema libere los recursos asignados al &lt;em&gt;socket&lt;/em&gt;. En el caso
de conexiones TCP, ésta es finalizada.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt; y &lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usan para resolver nombres de máquina y direcciones IP (&lt;a href="http://es.wikipedia.org/wiki/Domain_Name_System" title="DNS - Domain Name System"&gt;DNS&lt;/a&gt;).&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para esperar a que uno o más &lt;em&gt;sockets&lt;/em&gt; de una lista estén listos
para leer, escribir o tengan algún error.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para comprobar el estado de un &lt;em&gt;socket&lt;/em&gt; en un conjunto de &lt;em&gt;sockets&lt;/em&gt;.
Puede comprobar si están listos para escribir, leer o si ha ocurrido algún error.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;getsockopt()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para recuperar el valor actual de una opción concreta de configuración
del &lt;em&gt;socket&lt;/em&gt; especificado.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para cambiar el actual de una opción concreta de configuración del
&lt;em&gt;socket&lt;/em&gt; especificado.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;POSIX API en Boost.Asio&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; es una librería de C++ para programadores de software de sistema
donde el acceso a funcionalidades del sistema operativo; como la red, los archivos,
un puerto serie, etc.; se requiere con cierta frecuencia. El acceso a estos recursos
suele implicar operaciones de E/S que normalmente consumen mucho tiempo antes
de completarse, por lo que &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; provee de herramientas para gestionar
estas conexiones de manera asíncrona, sin necesitar modelos de concurrencia
basados en hilos o en múltiples procesos y memoria compartida.&lt;/p&gt;
&lt;p&gt;Debido a que uno de los usos principales de esta librería son las comunicaciones
por red, &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; incluye una interfaz multiplataforma de &lt;em&gt;sockets&lt;/em&gt; de bajo nivel,
basada en el API &lt;em&gt;BSD sockets&lt;/em&gt;, e implementada sobre la que proporciona el propio
sistema operativo.&lt;/p&gt;
&lt;p&gt;A diferencia de esta última, la implementación proporcionada por &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; no incluye
algunos aspectos del API original que no son seguros o que son propensos a provocar
errores de programación. Por ejemplo, el uso de &lt;code&gt;int&lt;/code&gt; para identificar a los &lt;em&gt;sockets&lt;/em&gt;
por parte del API &lt;em&gt;BSD sockets&lt;/em&gt; carece de la seguridad que nos ofrecería tener un
tipo específico para ellos. Por eso la representación de un &lt;em&gt;socket&lt;/em&gt; en &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; usa
un tipo distinto para cada protocolo. Es decir, para TCP el tipo de un socket es
&lt;code&gt;ip::tcp::socket&lt;/code&gt; mientras para UDP el tipo es &lt;code&gt;ip::udp::socket&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentación de &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; se incluye una &lt;a href="http://www.boost.org/doc/html/boost_asio/overview/networking/bsd_sockets.html"&gt;tabla&lt;/a&gt;
que muestra la relación entre el API &lt;em&gt;BSD socket&lt;/em&gt; y el API de acceso a red de &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt;:&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Berkeley_sockets"&gt;Berkeley sockets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://msdn.microsoft.com/es-es/library/windows/desktop/ms740673(v=vs.85).aspx"&gt;Wnsock - Windows Sockets API&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tangentsoft.net/wskfaq/articles/bsd-compatibility.html"&gt;Winsock Programmer's FAQ - BSD Sockets Compatibility&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;POSIX son las siglas de Portable Operating System Interface, una familia
de estándares especificados por el &lt;a href="http://www.ieee.org/"&gt;IEEE&lt;/a&gt; para mantener
la compatibilidad entre sistemas operativos. POSIX define un API, tomando del
de los sistemas UNIX, para asegurar la compatibilidad entre las distintas
variantes de UNIX y otros sistemas operativos.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sat, 02 Mar 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-02:bsd-sockets.html</guid><category>sockets</category><category>POSIX</category><category>comunicaciones</category></item><item><title>Protocol Buffers</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html</link><description>&lt;p&gt;&lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; es una herramienta para la serialización&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; de estructuras de
datos.&lt;/p&gt;
&lt;p&gt;Básicamente provee una manera sencilla de definir la estructura de los datos,
pudieron entonces generar código capaz de leer y escribir dichos datos de
manera eficiente, desde diferentes lenguajes y en una variedad de distintos
tipos de flujos de datos.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; fue desarrollado internamente por Google para almacenar
e intercambiar todo tipo de información estructurada. Hasta el punto de que
sirve de base para un sistema de &lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call"&gt;llamada a procedimiento remoto&lt;/a&gt;
o &lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call" title="Llamada a Procedimiento Remoto"&gt;RPC&lt;/a&gt; (Remote Procedure Call) propio que es usado prácticamente para
todas las comunicaciones entre equipos en Google.&lt;/p&gt;
&lt;p&gt;En su momento Google hizo generadores de código de &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; para
C++, Java y Python y liberó la herramienta con una licencia
&lt;a href="http://es.wikipedia.org/wiki/Licencia_BSD"&gt;BSD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La idea detrás de &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; es muy similar a la que dio origen a
&lt;a href="http://en.wikipedia.org/wiki/XML" title="XML"&gt;XML&lt;/a&gt;, solo que en este caso el formato es binario, compacto y pone énfasis
en la velocidad a la hora de serializar&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; y deserializar los datos. Además
es muy similar a &lt;a href="http://en.wikipedia.org/wiki/Apache_Thrift" title="Apache Thrift"&gt;Apache Thrift&lt;/a&gt; (creado y usado internamente por Facebook)
o &lt;a href="http://en.wikipedia.org/wiki/Apache_Avro" title="Apache Avro"&gt;Apache Avro&lt;/a&gt;, excepto porque &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; no define un protocolo
&lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call" title="Llamada a Procedimiento Remoto"&gt;RPC&lt;/a&gt; concreto, sino sólo como deben empaquetarse los datos.&lt;/p&gt;
&lt;p&gt;Si se quiere definir un servicio &lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call" title="Llamada a Procedimiento Remoto"&gt;RPC&lt;/a&gt; que haga uso de un protocolo que se
apoye sobre &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; para el intercambio de datos, existen
&lt;a href="http://code.google.com/p/protobuf/wiki/ThirdPartyAddOns#RPC_Implementations"&gt;diversas implementaciones RPC&lt;/a&gt;
para distintos lenguajes de programación.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://code.google.com/p/protobuf/"&gt;protobuf - Protocol Buffers - Google's data interchange format&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/"&gt;Protocol Buffers - Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Protocol_Buffers"&gt;Protocol Buffers&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;La serialización es un proceso de codificación de un objeto en un medio
de almacenamiento (como puede ser una archivo o un buffer en memoria), en
ocasiones para transmitirlo a través de una conexión de red o para preservarlo
entre ejecuciones de un programa. La serie de bytes que codifican el estado
del objeto tras la serialización puede ser usada para crear un nuevo objeto,
idéntico al original, tras aplicar el proceso inverso de deserialización.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sat, 02 Mar 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-02:protocol-buffers.html</guid><category>protobuf</category><category>serialización</category></item><item><title>Detección de movimiento</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/deteccion-de-movimiento.html</link><description>&lt;p&gt;Detectar movimiento en una secuencia de vídeo es una tarea relativamente simple
que puede abordarse en unos pocos pasos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Supresión del fondo&lt;/strong&gt;. Consiste en estimar un modelo del fondo y compararlo
con el &lt;em&gt;frame&lt;/em&gt; actual para detectar cambios. El resultado es una imagen binaria
donde los píxeles se clasifican entre si forman parte del fondo o son del
primer plano.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Operaciones morfológicas&lt;/strong&gt;. En la imagen resultado de la operación anterior
suelen aparecer regiones de pequeño tamaño marcadas como de primer plano debido
al ruido en el &lt;em&gt;frame&lt;/em&gt; original. Una solución muy común en estos casos es aplicar
operaciones de dilatación y erosión con el objeto de suprimirlas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Extracción de blobs&lt;/strong&gt;. Los píxeles clasificados como de primer plano
suelen agruparse en regiones que corresponden a objetos en movimiento en el
&lt;em&gt;frame&lt;/em&gt; original. La &lt;em&gt;extracción de blobs&lt;/em&gt; permite identificar estas regiones
para, por ejemplo, marcarlas con un cuadro delimitador en la imagen original.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;OpenCV&lt;/h2&gt;
&lt;p&gt;Los pasos a realizar son relativamente sencillos, por lo que no nos costaría
mucho desarrollar nuestra propia implementación, ya que la mayor parte de ellos
están perfectamente documentados de manera muy comprensible en Internet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Supresión del fondo&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://es.wikipedia.org/wiki/Detecci%C3%B3n_de_primer_plano"&gt;Detección de primer plano&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Operaciones morfológicas&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://es.wikipedia.org/wiki/Morfolog%C3%ADa_matem%C3%A1tica"&gt;Morfología matemática&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Universidad Carlos III de Madrid - &lt;a href="http://www.tsc.uc3m.es/imagine/Curso_ProcesadoMorfologico/Contenido/Operaciones/OperacionesMorfologicas.html"&gt;Operaciones Morfológicas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Extracción de blobs&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Blob_extraction"&gt;Connected-component labeling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sin embargo existe una librería de visión por computador, denominada &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt;,
que permite que nos ahorremos todo este trabajo.&lt;/p&gt;
&lt;p&gt;Además en estos casos siempre debemos tener presente que aunque se trate de
algoritmos sencillos, siempre existen pequeñas cuestiones que deben ser tenidas
en cuenta, fundamentalmente desde el punto de vista de la precisión de los
algoritmos y del rendimiento, lo que puede dificultar el desarrollo. Por eso
suele ser preferible utilizar una librería madura en lugar de hacer nuestra
propia implementación.&lt;/p&gt;
&lt;h2&gt;OpenCV y Qt&lt;/h2&gt;
&lt;p&gt;Si estamos desarrollando una aplicación gráfica en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; debemos tomar una serie
de medidas para poder emplear la librería &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; desde ella:&lt;/p&gt;
&lt;h3&gt;Conversión de QImage en cv::Mat&lt;/h3&gt;
&lt;p&gt;Las imágenes de las que haremos uso son instancias de la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;, propia
del &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;. Sin embargo las funciones, clases y métodos de &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt;
esperan objetos &lt;code&gt;cv::Mat&lt;/code&gt;. Para convertir entre un formato y otro podemos emplear
el proyecto &lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt; de &lt;a href="https://github.com/dbzhang800"&gt;Debao Zhang&lt;/a&gt; (licencia
&lt;a href="http://es.wikipedia.org/wiki/MIT_License"&gt;MIT&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Para utilizarlo sólo necesitamos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Descargar en el directorio del proyecto los archivos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.cpp" title="cvmatandqimage.cpp"&gt;cvmatandqimage.cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.h" title="cvmatandqimage.h"&gt;cvmatandqimage.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/opencv.pri" title="opencv.pri"&gt;opencv.pri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri"&gt;QtOpenCV.pri&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Abrir el archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto y añadir al final la línea:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QtOpenCV&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Los archivos &lt;code&gt;.pri&lt;/code&gt; tienen el mismo formato que los &lt;code&gt;.pro&lt;/code&gt; pero están pensados
para ser incluidos por estos últimos. En nuestro caso el archivo &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri"&gt;QtOpenCV.pri&lt;/a&gt;
contiene información sobre como incorporar los archivos &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.cpp" title="cvmatandqimage.cpp"&gt;cvmatandqimage.cpp&lt;/a&gt;
y &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.h" title="cvmatandqimage.h"&gt;cvmatandqimage.h&lt;/a&gt; al proyecto, haciendo que las funciones por ellos
definidas estén disponibles para nuestra aplicación.&lt;/p&gt;
&lt;p&gt;Tal y como se comenta en el archivo &lt;code&gt;README.md&lt;/code&gt; de &lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt;, en el proyecto
se definen dos funciones:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;QtOcv&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// channels == 0 significa autodetección&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;image2Mat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;channels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="n"&gt;MatChannelOrder&lt;/span&gt; &lt;span class="n"&gt;rgbOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MCO_BGR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// format == QImage::Format_Invalid significa autodetección&lt;/span&gt;
    &lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;mat2Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;QImage&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QImage&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Format_Invalid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;MatChannelOrder&lt;/span&gt; &lt;span class="n"&gt;rgbOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MCO_BGR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;que podemos usar para convertir objetos &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; a &lt;code&gt;cv::Mat&lt;/code&gt; y viceversa.&lt;/p&gt;
&lt;h3&gt;Añadir la librería OpenCV al proyecto&lt;/h3&gt;
&lt;p&gt;Aunque ya hemos incorporado &lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt; a nuestro proyecto para la conversión
entre formatos de imagen, aun no hemos añadido la librería OpenCV propiamente
dicha:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;El archivo &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri"&gt;QtOpenCV.pri&lt;/a&gt; incluido anteriormente a su vez incluye a
&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/opencv.pri" title="opencv.pri"&gt;opencv.pri&lt;/a&gt;, cuya labor es facilitar el añadir &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; al proyecto. Lo único
que tenemos que hacer es editar el archivo &lt;code&gt;.pro&lt;/code&gt; e incorporar al final la línea:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;add_opencv_modules&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;video&lt;/span&gt; &lt;span class="n"&gt;imgproc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;o en Windows:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;add_opencv_modules&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;video&lt;/span&gt; &lt;span class="n"&gt;imgproc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;2.4.4&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;donde &lt;code&gt;2.4.4&lt;/code&gt; debe sustituirse por el número de la versión actualmente
instalada de OpenCV. Esto es un requisito en los sistemas Windows ya que
dicho número se usa para componer el nombre de las librerías &lt;code&gt;.dll&lt;/code&gt; con las
que debe enlazarse el ejecutable del proyecto.&lt;/p&gt;
&lt;p&gt;En la &lt;a href="http://docs.opencv.org/modules/core/doc/intro.html"&gt;introducción&lt;/a&gt; de
&lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; se explica que el paquete está divido a su vez en distintos módulos
o librerías, cada uno de los cuales está dedicado a un tipo de tarea específico.
En nuestro caso concreto el módulo &lt;em&gt;video&lt;/em&gt; incluye las clases y funciones de
supresión del fondo que nos interesa utilizar, mientras que &lt;em&gt;imgproc&lt;/em&gt; contiene
las operaciones morfológicas y de detección de contornos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a id="incorporar_libreria_manualmente"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Si por cualquier motivo no estuviéramos haciendo uso de los archivos &lt;code&gt;.pri&lt;/code&gt;
tendríamos que incorporar la librería al proyecto manualmente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;En Linux y Mac OS X esto se puede hacer como un &lt;em&gt;paquete instalado en el sistema&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;En el menú contextual del proyecto (botón derecho sobre el proyecto)
seleccionar &lt;strong&gt;Add Library.../System package&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el paso posterior indicar &lt;strong&gt;opencv&lt;/strong&gt; como nombre del paquete. Obviamente
la librería tiene que haber sido instalada previamente usando el procedimiento
usual de nuestra distribución.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En Windows este recurso no existe, por lo que la librería suele incorporarse
al proyecto como &lt;em&gt;librería externa&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;En el menú contextual del proyecto (botón derecho sobre el proyecto)
seleccionar &lt;strong&gt;Add Library.../External library&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Indicar el archivo de la librería (&lt;em&gt;Library file&lt;/em&gt;) que queremos
incorporar y el directorio de cabeceras (&lt;em&gt;Include Path&lt;/em&gt;). Como lo estamos
haciendo para Windows, sólo tenemos que tener marcada dicha opción en la lista
de plataformas soportadas. Por lo general:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Librerías en &lt;code&gt;C:\opencv\build\&amp;lt;ARQUITECTURA&amp;gt;\mingw\lib&lt;/code&gt;: &lt;code&gt;libopencv_core&amp;lt;VERSION&amp;gt;.dll.a&lt;/code&gt; y &lt;code&gt;libopencv_video&amp;lt;VERSION&amp;gt;.dll.a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ruta de las cabeceras: &lt;code&gt;C:\opencv\build\include&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para ambos sistemas, al terminar se nos abrirá el archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto con
los cambios correspondientes realizados. Debemos guardarlo para dar por
finalizada la incorporación de la librería.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;QImage vs QPixmap&lt;/h2&gt;
&lt;p&gt;Una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; es una representación de una imagen optimizada para
ser mostrada. Esto significa que en muchos sistemas sus características
dependen de las de la pantalla (p. ej. su profundida de color puede tener que
ser la misma que la que actualmente tiene el adaptador gráfico: 8 bits,
16 bits, 32 bits, etc.) y que internamente se implementa mediante algún tipo
de objeto del lado del servidor gráfico cuya función es representar a las
imágenes de cara al resto del sistema de ventanas. Por lo tanto, los píxeles
de un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; no son accesibles directamente por parte del aplicación.&lt;/p&gt;
&lt;p&gt;Una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; es una representación independiente del hardware de
una imagen. Básicamente permite leer y escribir imágenes desde un archivo y
manipular los píxeles directamente, sin que las características actuales del
adaptador gráfico tengan nada que ver. Los datos de la imagen se almacenan
en el lado de la aplicación, por lo que son accesibles a esta en todo momento.&lt;/p&gt;
&lt;p&gt;Normalmente la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; se utiliza para cargar una imagen desde un
archivo, opcionalmente manipular los píxeles y después convertirla a un
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; para mostrarla en la pantalla.&lt;/p&gt;
&lt;p&gt;En nuestro caso existen dos motivos fundamentales para utilizar &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;
en lugar de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Para convertir la imagen a un objeto &lt;code&gt;cv::Mat&lt;/code&gt; de &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; se necesita
acceso a los datos de los píxeles. Como hemos comentado, eso sólo es posible
con la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generamente un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; encapsula el acceso a algún tipo de
recurso del servidor gráfico, con el que la aplicación se comunica a través
del hilo GUI (el hilo principal de la aplicación). Puesto que en muchos
sistemas operativos no es seguro comunicarse con el servidor gráfico a través
de un hilo diferente a ese, cualquier manipulación de un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;
fuera del hilo principal puede dar lugar a efectos inesperados. Dado que
queremos transferir las imágenes a un hilo de trabajo para su procesamiento,
parece que lo más seguro es utilizar la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Detección de movimiento&lt;/h2&gt;
&lt;p&gt;Con acceso a las clases y funciones de &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; desde nuestra aplicación,
podemos pasar a resolver el problema que nos habíamos propuesto; detectar
movimiento en una secuencia de vídeo.&lt;/p&gt;
&lt;p&gt;Como ocurre con muchas otras tareas en el campo de la visión por computador,
esta se puede resolver de múltiples maneras. Además es muy común que en cada
técnica posible haya una decena de parámetros que den resultados diferentes
según como los ajustemos.&lt;/p&gt;
&lt;p&gt;Nosotros nos centraremos en solución concreta:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// std::vector&amp;lt;cv::Mat&amp;gt; images = &amp;lt;vector de imágenes en cv::Mat&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Definimos algunos tipos para que el código se lea mejor&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ImagesType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ContoursType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Instancia de la clase del sustractor de fondo&lt;/span&gt;
&lt;span class="c1"&gt;// cv::BackgroundSubtractorMOG2(history=500,&lt;/span&gt;
&lt;span class="c1"&gt;//                              varThreshold=16,&lt;/span&gt;
&lt;span class="c1"&gt;//                              bShadowDetection=true)&lt;/span&gt;
&lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BackgroundSubtractorMOG2&lt;/span&gt; &lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nmixtures&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Desactivar la detección de sombras&lt;/span&gt;
&lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bShadowDetection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ImagesTypes&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Sustracción del fondo:&lt;/span&gt;
    &lt;span class="c1"&gt;//  1. El objeto sustractor compara la imagen en i con su&lt;/span&gt;
    &lt;span class="c1"&gt;//     estimación del fondo y devuelve en foregroundMask una&lt;/span&gt;
    &lt;span class="c1"&gt;//     máscara (imagen binaria) con un 1 en los píxeles de&lt;/span&gt;
    &lt;span class="c1"&gt;//     primer plano.&lt;/span&gt;
    &lt;span class="c1"&gt;//  2. El objeto sustractor actualiza su estimación del fondo&lt;/span&gt;
    &lt;span class="c1"&gt;//     usando la imagen en i.&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Operaciones morfolóficas para eliminar las regiones de&lt;/span&gt;
    &lt;span class="c1"&gt;// pequeño tamaño. Erode() las encoge y dilate() las vuelve a&lt;/span&gt;
    &lt;span class="c1"&gt;// agrandar.&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;erode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;dilate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="c1"&gt;// Obtener los contornos que bordean las regiones externas&lt;/span&gt;
    &lt;span class="c1"&gt;// (CV_RETR_EXTERNAL) encontradas. Cada contorno es un vector&lt;/span&gt;
    &lt;span class="c1"&gt;// de puntos y se devuelve uno por región en la máscara.&lt;/span&gt;
    &lt;span class="n"&gt;ContoursType&lt;/span&gt; &lt;span class="n"&gt;contours&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;findContours&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contours&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CV_RETR_EXTERNAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;CV_CHAIN_APPROX_NONE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Aquí va el código ódigo que usa los contornos encontrados...&lt;/span&gt;
    &lt;span class="c1"&gt;// P. ej. usar cv::boundingRect() para obtener el cuadro&lt;/span&gt;
    &lt;span class="c1"&gt;// delimitador de cada uno y pintarlo en la imagen original&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Donde suponemos que previamente hemos convertido todas las imágenes de
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; a cv::Mat y las hemos almacenado en un vector.&lt;/p&gt;
&lt;p&gt;Al final de cada iteración del bucle tenemos para cada imagen un vector de
contornos, donde cada uno es un vector de puntos. Con los contornos se pueden
hacer múltiples operaciones. Por ejemplo calcular el rectángulo que contiene
a cada uno (&lt;em&gt;bounding box&lt;/em&gt;) con &lt;a href="http://opencv.willowgarage.com/documentation/cpp/structural_analysis_and_shape_descriptors.html#cv-boundingrect" title="cv::boundingRect"&gt;cv::boundingRect&lt;/a&gt;() para pintarlos sobre
la imagen antes de mostrársela al usuario.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Más detalles en el mensaje &lt;a href="http://lists.trolltech.com/qt-interest/2008-11/thread00534-0.html"&gt;QPixmap: It is not safe to use pixmaps outside the GUI thread&lt;/a&gt;
de las listas de correo de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Tue, 19 Feb 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-19:deteccion-de-movimiento.html</guid><category>visión</category><category>imágenes</category><category>opencv</category><category>qt. qimage</category></item><item><title>Hilos de trabajo usando señales y slots</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html</link><description>&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; proporciona clases para hilos y mecanismos de sincronización que facilitan
sacar las tareas de larga duración del hilo principal de la aplicación, lo que
de lo contrario bloquearía la interfaz de usuario.&lt;/p&gt;
&lt;p&gt;Una forma práctica de hacerlo la hemos visto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;anteriormente&lt;/a&gt;
utilizando un &lt;em&gt;buffer&lt;/em&gt; compartido. Sin embargo &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; provee a cada hilo de una
cola de mensajes, lo que permite enviar señales a &lt;em&gt;slots&lt;/em&gt; en otros hilos. Esto
nos proporciona una forma sencilla de pasar datos entre los hilos de la
aplicación.&lt;/p&gt;
&lt;p&gt;Si no se indica lo contrario, las señales emitidas desde un hilo a un objeto
en el mismo hilo son entregadas directamente. Es decir, que al emitir la señal
se invoca el &lt;em&gt;slot&lt;/em&gt; como si de un método convencional se tratara. Sin embargo
si el emisor y el receptor residen en hilos diferentes, la señal es insertada
en la cola de mensajes del hilo del objeto de destino. Así el &lt;em&gt;slot&lt;/em&gt;
correspondiente será invocado en el hilo receptor desde su bucle de mensajes.&lt;/p&gt;
&lt;p&gt;En la actualidad esta es la forma recomendada de usar hilos en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; ya que
permite evitar el uso de de mecanismos de sincronización como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;,
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;, etc.&lt;/p&gt;
&lt;h2&gt;El ejemplo. Ordenar números enteros&lt;/h2&gt;
&lt;p&gt;El ejemplo que vamos a seguir básicamente consiste en ordenar
un vector de enteros en un hilo de trabajo distinto al hilo principal.&lt;/p&gt;
&lt;p&gt;Como se puede observar en la figura utilizaremos dos objetos, uno vinculado
al hilo principal (clase &lt;code&gt;Sorter&lt;/code&gt;) y otro al hilo de trabajo
(clase &lt;code&gt;SorterWorker&lt;/code&gt;). En una aplicación gráfica convencional con &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; la
clase &lt;code&gt;Sorter&lt;/code&gt; podría ser una ventana o cualquier otro control que
quiera ceder una tarea al hilo de trabajo. Aquí no lo haremos así para
que el ejemplo sea lo más sencillo posible.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1tZ0CMTNJoLsbHx3TjgecQuRXGEM5hf3pYwm9_s1R8bI/pub?w=960&amp;amp;h=720" alt="Ejemplo de comunicación entre hilos en Qt" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;En &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; un objeto se dice que vive en el hilo en el que es creado. Esto se
puede cambiar utilizando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#moveToThread" title="QObject::moveToThread()"&gt;moveToThread&lt;/a&gt;() que tienen todas las
clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;La clase Sorter&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Sorter&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="c1"&gt;// Ordenar asíncronamente un vector en el hilo de trabajo&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sortAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nl"&gt;signals:&lt;/span&gt;
        &lt;span class="c1"&gt;// Señal para comunicarnos con el hilo de trabajo&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sortingRequested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nl"&gt;slots:&lt;/span&gt;
        &lt;span class="c1"&gt;// Slot para saber cuando el vector ha sido ordenado&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;// Clase del hilo de trabajo&lt;/span&gt;
        &lt;span class="n"&gt;QThread&lt;/span&gt; &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="c1"&gt;// Clase que hace el ordenamiento&lt;/span&gt;
        &lt;span class="n"&gt;SorterWorker&lt;/span&gt; &lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La propia clase &lt;code&gt;Sorter&lt;/code&gt; se hará cargo de crear el hilo de trabajo, que por
defecto lo único que hace es iterar en su propio bucle de mensajes. Todos
los detalles acerca de la creación de hilos ya los vimos
&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;anteriormente&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La clase &lt;code&gt;Sorter&lt;/code&gt; provee un método &lt;code&gt;sortAsync()&lt;/code&gt; que podrá ser llamado por
los clientes para ordenar un vector de números enteros. Puesto que la operación
es asíncrona, necesitamos definir un &lt;em&gt;slot&lt;/em&gt; &lt;code&gt;vectorSorted()&lt;/code&gt; para ser
notificados cuando el ordenamiento haya finalizado con éxito.&lt;/p&gt;
&lt;p&gt;La implementación de esta clase sería la siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Q_FUNC_INFO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThreadId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// Registrar los parámetros de la señales. Necesitamos registrar&lt;/span&gt;
    &lt;span class="c1"&gt;// QList&amp;lt;int&amp;gt; porque no es un tipo conocido por el sistema de&lt;/span&gt;
    &lt;span class="c1"&gt;// meta-objetos de Qt.&lt;/span&gt;
    &lt;span class="n"&gt;qRegisterMetaType&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;QVector&amp;lt;int&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Pasar la petición de ordenar a la instancia de SorterWorker&lt;/span&gt;
    &lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sortingRequested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;doSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
    &lt;span class="c1"&gt;// Ser notificado cuando el vector haya sido ordenado&lt;/span&gt;
    &lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;

    &lt;span class="c1"&gt;// Migrar la instancia de SorterWorker al hilo de trabajo&lt;/span&gt;
    &lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;moveToThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Iniciar el hilo de trabajo&lt;/span&gt;
    &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Le decimos al bucle de mensajes del hilo que se detenga&lt;/span&gt;
    &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// Ahora esperamos a que el hilo de trabajo termine&lt;/span&gt;
    &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sortAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Q_FUNC_INFO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThreadId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;emit&lt;/span&gt; &lt;span class="n"&gt;sortingRequested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se puede observar, en el constructor de &lt;code&gt;Sorter&lt;/code&gt; se usa el método
&lt;code&gt;qRegisterMetaType()&lt;/code&gt;, antes de conectar las señales, para registrar el tipo
&lt;code&gt;QVector&amp;lt;int&amp;gt;&lt;/code&gt;. Esto debe hacerse porque cuando una señal es encolada sus
parámetros deben ser de tipos conocidos para &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, de forma que pueda
almacenar los argumentos en la cola.&lt;/p&gt;
&lt;p&gt;Por otro lado en el destructor de &lt;code&gt;Sorter&lt;/code&gt; tenemos cuidado de detener
el hilo de trabajo en condiciones seguras cuando ya no va a ser necesario.
Si no lo hacemos así, el hilo podría ser destruido por el sistema operativo
en cualquier punto de la secuencia de instrucciones al termina la aplicación,
lo que podría dejar los datos en uso en un estado indeterminado.&lt;/p&gt;
&lt;h2&gt;La clase SorterWorker&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SorterWorker&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="nl"&gt;signals:&lt;/span&gt;
        &lt;span class="c1"&gt;// Señal emitida cuando el vector ha sido ordenado&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nl"&gt;slots:&lt;/span&gt;
        &lt;span class="c1"&gt;// Método encargado del ordenamiento&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Q_FUNC_INFO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThreadId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

            &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list_sorted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;qSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list_sorted&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;emit&lt;/span&gt; &lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list_sorted&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Como usar el ejemplo&lt;/h2&gt;
&lt;p&gt;Para usar el ejemplo sólo necesitamos crear una instancia de &lt;code&gt;Sorter&lt;/code&gt; y
llamar a su método &lt;code&gt;sortAsync()&lt;/code&gt; para pedir que ordene el vector especificado.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QCoreApplication&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;Sorter&lt;/span&gt; &lt;span class="n"&gt;sorter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;sorter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sortAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;Introducción al uso de hilos en Qt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cdumez.blogspot.com.es/2011/03/worker-thread-in-qt-using-signals-slots.html"&gt;Worker Thread in Qt using Signals &amp;amp; Slots&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Todas las clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; tienen como clase base &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html" title="QObject"&gt;QObject&lt;/a&gt; donde se
implementan algunos métodos comunes como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html" title="QObject"&gt;QObject&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#moveToThread" title="QObject::moveToThread()"&gt;moveToThread&lt;/a&gt;()&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Mon, 18 Feb 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-18:hilos-de-trabajo-usando-senales-y-slots.html</guid><category>qt</category><category>hilos</category><category>señales</category><category>slots</category></item><item><title>Introducción al uso de hilos en Qt</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html</link><description>&lt;p&gt;Debido a la existencia del bucle de mensajes, no se pueden ejecutar tareas de
larga duración en los &lt;em&gt;slots&lt;/em&gt;. Si lo hiciéramos la ejecución tardaría en
volver al bucle de mensajes, retrasando el momento en el que la aplicación puede
procesar nuevos eventos de los usuarios.&lt;/p&gt;
&lt;p&gt;Por eso lo habitual es que desde los &lt;em&gt;slots&lt;/em&gt; se deleguen esas tareas a hilos de
trabajo —o &lt;em&gt;worker thread&lt;/em&gt;— de tal manera que se ejecuten mientras el hilo
principal sigue procesando los eventos que llegen a la aplicación.&lt;/p&gt;
&lt;h2&gt;Crear hilos&lt;/h2&gt;
&lt;p&gt;Para usar hilos en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; se utiliza la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;, donde cada instancia de
dicha clase representa a un hilo de la aplicación.&lt;/p&gt;
&lt;p&gt;Crear un hilo es tan sencillo como heredar la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt; y reimplementar
el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run" title="QThread::run()"&gt;run&lt;/a&gt;() insertando el código que queremos que ejecute el hilo.
En este sentido el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run" title="QThread::run()"&gt;run&lt;/a&gt;() es para el hilo lo que la función
&lt;code&gt;main()&lt;/code&gt; es para la aplicación.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyThread&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MyThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Aquí el código a ejecutar en el hilo...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Una vez instanciada la clase, iniciar el nuevo hilo es tan sencillo como
invocar el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#start" title="QThread::start()"&gt;start&lt;/a&gt;().&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;MyThread&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El hilo terminará cuando la ejecución retorne de su método MyThread::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run" title="QThread::run()"&gt;run&lt;/a&gt;()
o si desde el código del hilo se invocan los métodos &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#exit" title="QThread::exit()"&gt;exit&lt;/a&gt;() o&lt;/p&gt;
&lt;h2&gt;Problema del buffer finito&lt;/h2&gt;
&lt;p&gt;Generalmente los hilos no se crean directamente en los &lt;em&gt;slots&lt;/em&gt; en los que son
necesarios, sino en la función &lt;code&gt;main()&lt;/code&gt;, en el constructor de la clase de la
ventana que los va a utilizar o en otros sitios similares. Eso se así por una
cuestión de eficiencia, ya que crear y destruir hilos según cuando son
necesarios tiene cierto coste.&lt;/p&gt;
&lt;p&gt;La única cuestión es que entonces un &lt;em&gt;slot&lt;/em&gt; debe poder entregar la tarea
al hilo correspondiente que ha sido creado previamente. Como todos los hilos
comparten la memoria del proceso, esto no debe ser un problema, pero realmente
entraña ciertas dificultades relacionadas con la concurrencia.&lt;/p&gt;
&lt;p&gt;Para ilustrarlo supongamos que hemos abierto un archivo de vídeo para procesarlo
y que un &lt;em&gt;slot&lt;/em&gt; de la clase de la ventana es invocado cada vez que se dispone
de un nuevo &lt;em&gt;frame&lt;/em&gt;. La función del &lt;em&gt;slot&lt;/em&gt; sería la de transferir al hilo
el &lt;em&gt;frame&lt;/em&gt; para que se haga cargo de su procesamiento. Teniendo esto en cuenta,
el problema al que nos enfrentamos podría ser descrito de la siguiente manera:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;El &lt;em&gt;slot&lt;/em&gt; obtiene los &lt;em&gt;frames&lt;/em&gt; por lo que sería nuestro &lt;em&gt;productor&lt;/em&gt;. Como
 se ejecuta desde la bomba de mensajes sabemos que siempre lo hace dentro
 del hilo principal del proceso.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El hilo de trabajo encargado del procesamiento sería nuestro &lt;em&gt;consumidor&lt;/em&gt;,
 ya que toma los &lt;em&gt;frames&lt;/em&gt; entregados por el productor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ambos comparten un &lt;em&gt;buffer&lt;/em&gt; de &lt;em&gt;frames&lt;/em&gt; de tamaño fijo que se usa a modo
 de cola. El &lt;em&gt;productor&lt;/em&gt; insertaría los &lt;em&gt;frames&lt;/em&gt; en la cola mientras el
 &lt;em&gt;consumidor&lt;/em&gt; los extraería.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para evitar que el &lt;em&gt;productor&lt;/em&gt; añada más &lt;em&gt;frames&lt;/em&gt; de los que caben en la
 cola y que el &lt;em&gt;consumidor&lt;/em&gt; intente extraer más cuando ya no queden,
 ambos comparten un contador con el número de &lt;em&gt;frames&lt;/em&gt; almacenados.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para que todo esto funcione correctamente vamos a necesitar una serie de
elementos de sincronización que ayuden a ambos hilos a coordinarse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Un cerrojo —o &lt;em&gt;mutex&lt;/em&gt;— de exclusión mutua &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt; que serialice la
  ejecución del código en ambos hilos que manipulan la cola y su contador. La
  idea es que mientras uno de los hilos esté manipulando la cola, el otro tenga
  que esperar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Una condición de espera &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt; para que el &lt;em&gt;productor&lt;/em&gt; pueda
  dormir —o descartar los nuevos &lt;em&gt;frames&lt;/em&gt;— mientras la cola esté llena. La
  siguiente vez que el consumidor extraiga un &lt;em&gt;frame&lt;/em&gt; de la cola, utilizaría la
  condición de espera para notificar al productor que puede volver a insertar
  &lt;em&gt;frames&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Una condición de espera &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt; para que el &lt;em&gt;consumidor&lt;/em&gt; pueda
  dormir mientras la cola esté vacía. La siguiente vez que el productor
  inserte un &lt;em&gt;frame&lt;/em&gt; en la cola, utilizaría la condición de espera para
  notificar al consumidor que puede volver a extraerlos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Teniendo todo esto presente, a continuación desarrollamos un posible solución.&lt;/p&gt;
&lt;h3&gt;Variables globales&lt;/h3&gt;
&lt;p&gt;Como ya hemos comentado, ambos hilos deben compartir la cola, el contador y
una serie de elementos de sincronización:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// Tamaño de la cola&lt;/span&gt;
&lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;// Cola de frames como array de C&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// Contador de frames en la cola&lt;/span&gt;

&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="n"&gt;bufferNotEmpty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="n"&gt;bufferNotFull&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QMutex&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;El productor&lt;/h3&gt;
&lt;p&gt;El código del &lt;em&gt;productor&lt;/em&gt; en el &lt;em&gt;slot&lt;/em&gt; podría tener el siguiente aspecto:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MyWindow&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;on_video_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// Posición último frame insertado&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// Bloquear el cerrojo&lt;/span&gt;
    &lt;span class="c1"&gt;// El código del productor a partir de este punto y hasta&lt;/span&gt;
    &lt;span class="c1"&gt;// el unlock() no se ejecutará si el consumidor ha bloqueado el&lt;/span&gt;
    &lt;span class="c1"&gt;// cerrojo primero.&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// ¿Cola llena?&lt;/span&gt;
        &lt;span class="n"&gt;bufferNotFull&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// Dormir hasta que haya sitio&lt;/span&gt;
                                        &lt;span class="c1"&gt;// en la cola.&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;

    &lt;span class="c1"&gt;// Insertar el frame en la cola&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;currentImage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// Bloquear el cerrojo&lt;/span&gt;
    &lt;span class="c1"&gt;// El código del productor a partir de este punto y hasta&lt;/span&gt;
    &lt;span class="c1"&gt;// el unlock() no se ejecutará si el consumidor ha bloqueado el&lt;/span&gt;
    &lt;span class="c1"&gt;// cerrojo primero.&lt;/span&gt;

    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;bufferNotEmpty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wakeAll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// Despertar al consumidor si&lt;/span&gt;
                                    &lt;span class="c1"&gt;// esperaba por más frames.&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Donde la instancia &lt;code&gt;mutex&lt;/code&gt; de la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt; sirve para evitar que el
&lt;em&gt;productor&lt;/em&gt; y el &lt;em&gt;consumidor&lt;/em&gt; accedan al contador compartido al mismo tiempo.
Concretamente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;El primero en llegar al método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html#lock" title="QMutex::lock()"&gt;lock&lt;/a&gt;() obtiene el cerrojo. Si
un segundo hilo llega a ese método mientras el otro tiene el cerrojo,
simplemente se duerme a la espera de que el cerrojo sea liberado por el primero.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Con el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html#unlock" title="QMutex::unlock()"&gt;unlock&lt;/a&gt;() se libera el cerrojo. En ese momento
uno de los hilos que espera en &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html#lock" title="QMutex::lock()"&gt;lock&lt;/a&gt;() se despierta y obtiene
el cerrojo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Por otro lado las instancias de condiciones de espera &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt; permiten
dormir un hilo hasta que se de una condición determinada. En nuestro ejemplo el
&lt;em&gt;productor&lt;/em&gt; utiliza el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html#wait" title="QWaitCondition::wait()"&gt;wait&lt;/a&gt;() para dormir si la
cola está llena. Antes de hacerlo libera temporalmente el cerrojo &lt;code&gt;mutex&lt;/code&gt;,
permitiendo que el &lt;em&gt;consumidor&lt;/em&gt; se pueda ejecutar en el código que protege.&lt;/p&gt;
&lt;p&gt;Como se verá a continuación, el &lt;em&gt;consumidor&lt;/em&gt; utiliza el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html#weakAll" title="QWaitCondition::weakAll()"&gt;weakAll&lt;/a&gt;() después de extraer un elemento con el objeto
de despertar al productor. Obviamente este deberá bloquear el cerrojo &lt;code&gt;mutex&lt;/code&gt;
antes de volver del método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html#wait" title="QWaitCondition::wait()"&gt;wait&lt;/a&gt;().&lt;/p&gt;
&lt;h3&gt;El consumidor&lt;/h3&gt;
&lt;p&gt;El código del consumidor podría tener el siguiente aspecto, que es muy similar
al del productor:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FrameProcessingThread&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

        &lt;span class="n"&gt;FrameProcessingThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{}&lt;/span&gt;

        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// Posición último frame extraido&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// Bloqueamos el cerrojo&lt;/span&gt;
            &lt;span class="c1"&gt;// El código del consumidor a partir de este punto y&lt;/span&gt;
            &lt;span class="c1"&gt;// hasta el unlock() no se ejecutará si el productor ha&lt;/span&gt;
            &lt;span class="c1"&gt;// bloqueado el cerrojo primero.&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// ¿Cola vacía?...&lt;/span&gt;
                &lt;span class="n"&gt;bufferNotEmpty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Dormir si es así&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;

            &lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                    &lt;span class="c1"&gt;// Bloquear el cerrojo&lt;/span&gt;
            &lt;span class="c1"&gt;// El código del consumidor a partir de este punto y&lt;/span&gt;
            &lt;span class="c1"&gt;// hasta el unlock() no se ejecutará si el productor ha&lt;/span&gt;
            &lt;span class="c1"&gt;// bloqueado el cerrojo primero.&lt;/span&gt;

            &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;bufferNotFull&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wakeAll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Despertar al productor si&lt;/span&gt;
                                        &lt;span class="c1"&gt;// esperaba por un hueco.&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;

            &lt;span class="c1"&gt;// Aquí va el código para procesar el frame...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;La función principal&lt;/h3&gt;
&lt;p&gt;Finalmente es en la función principal del programa &lt;code&gt;main()&lt;/code&gt; donde debe crearse
el hilo encargado del procesamiento de los &lt;em&gt;frames&lt;/em&gt;. Es decir, nuestro
consumidor.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QApplication&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;FrameProcessingThread&lt;/span&gt; &lt;span class="n"&gt;frameProcessingThread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;frameProcessingThread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;MyWindow&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/threads-starting.html"&gt;Starting Threads with QThread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-4.8/threads-waitconditions.html"&gt;Wait Conditions Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Producer-consumer_problem"&gt;Producer-consumer problem&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sat, 16 Feb 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-16:introduccion-al-uso-de-hilos-en-qt.html</guid><category>qt</category><category>hilos</category><category>mutex</category><category>condición de espera</category><category>variables de condición</category><category>productor-consumidor</category><category>buffer finito</category></item><item><title>Layouts en Qt. Organización de controles</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/layouts-en-qt-organizacion-de-controles.html</link><description>&lt;p&gt;El sistema de &lt;em&gt;layouts&lt;/em&gt; de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; proporcionar una manera sencilla de organizar
los controles dentro de otros controles o ventanas, asegurando el mejor
aprovechamiento del espacio disponible.&lt;/p&gt;
&lt;p&gt;La idea es describir como deben organizarse los controles, dejando que después
sean posicionados automáticamente por &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; en función del espacio disponible,
incluso cuando este cambia por el redimensionado de la ventana o control que
los contiene.&lt;/p&gt;
&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;p&gt;Dentro de &lt;em&gt;Qt Creator&lt;/em&gt;, en cualquier control, incluidas las ventanas
principales y cuadros de diálogo, se puede seleccionar la organización de los
controles que contiene mediante la opción &lt;em&gt;Lay Out&lt;/em&gt; del menú contexual que
se despliega al pulsar con el botón derecho del ratón.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Menú Lay Out en Qt Creator" src="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/static/images/menu-lay-out.png" /&gt;&lt;/p&gt;
&lt;p&gt;Las opciones disponibles permiten organizar los controles en disposiciones tales
como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Columnas en horizontal.&lt;/li&gt;
&lt;li&gt;Filas en vertical.&lt;/li&gt;
&lt;li&gt;En una rejilla bidimensional, permitiendo que un mismo control ocupe varias
celdas.&lt;/li&gt;
&lt;li&gt;Como un formulario, con dos colunmas donde a la izquierda se sitúan las
etiquetas descriptivas de los campos de la derecha.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Todas están comentadas en la documentación del proyecto sobre el
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/layout.html" title="Layout Management"&gt;Layout Management&lt;/a&gt; de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, donde además se muestran algunos ejemplos.&lt;/p&gt;
&lt;h2&gt;Anidamiento de layouts&lt;/h2&gt;
&lt;p&gt;Una organización de controles se puede anidar dentro de otra. Para eso existen
unos controles especiales (uno por cada uno de los tipos de organización comentados
anteriormente) cuya única función es contener otros controles para organizarlos
de una manera concreta:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;QHBoxLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contiene en columnas en horizontal.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QVBoxLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contiene en filas en vertical.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QGridLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contiene en una rejilla bidimensional.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QFormLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contienen como un formulario, con dos columnas.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Estos controles se pueden crear dentro de otro, de tal forma que su ubicación
final dependerá de la organización configurada en el padre.&lt;/p&gt;
&lt;h2&gt;Espaciadores&lt;/h2&gt;
&lt;p&gt;Otro elemento clave en la organización de los controles son los &lt;em&gt;espaciadores&lt;/em&gt;.
Estos controles funcionan como muelles que separan los controles en horizontal
o en vertical, según su orientación.&lt;/p&gt;
&lt;p&gt;Por ejemplo, permiten mantener los controles lo más separados posible entre
sí o pegarlos a los extremos de las ventanas, incluso aunque estas sean
redimensionadas.&lt;/p&gt;
&lt;h2&gt;Tamaño de los controles&lt;/h2&gt;
&lt;p&gt;Cuando se añaden controles a un &lt;em&gt;layout&lt;/em&gt; este procede de la siguiente manera:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A todos los controles se les asigna una cantidad de espacio de acuerdo
 con su &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; y su &lt;code&gt;QWidget::sizeHint()&lt;/code&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;Si alguno de los controles tiene un &lt;em&gt;factor de estiramiento&lt;/em&gt;&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; con valor
 mayor  que cero, entonces se les asigna espacio en proporción a dicho factor.&lt;/li&gt;
&lt;li&gt;Si alguno de los controles tiene un &lt;em&gt;factor de estiramiento&lt;/em&gt; igual a cero,
 entonces sólo recibirá más espacio si ningún otro control lo reclama. De todos
 estos primero se asigna el espacio a los que tienen una propiedad
 &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt; configurada como &lt;em&gt;Expanding&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A cualquier control al que se le ha asignado menos espacio que su tamaño mínimo
 (o el tamaño mínimo aconsejado&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;, si no se ha especificado un tamaño mínimo concreto)
 se le asigna ese espacio que necesita.&lt;/li&gt;
&lt;li&gt;A cualquier control al que se le ha asignado más espacio que su tamaño máximo
 se le asigna ese espacio máximo.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;El &lt;em&gt;factor de estiramiento&lt;/em&gt;, que por lo general es cero, es un mecanismo para
dar a unos controles más espacio en relación a otros. Si por ejemplo tenemos
tres controles iguales en organización horizontal y sin &lt;em&gt;factor de estiramiento&lt;/em&gt;,
todos obtendrá el mismo espacio. Pero si aplicamos un &lt;em&gt;factor de estiramiento&lt;/em&gt;
su tamaño cambiará en proporción a la relación de dicho factor entre los distintos
controles.&lt;/p&gt;
&lt;p&gt;Otro elemento clave en la asignación del espacio es la política fijada en la
propiedad &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt;. Los valores posibles son:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Fixed&lt;/dt&gt;
&lt;dd&gt;El tamaño del control viene determinado por &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; y no puede cambiarse.&lt;/dd&gt;
&lt;dt&gt;Minimum&lt;/dt&gt;
&lt;dd&gt;El tamaño del control indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es el mínimo posible.
No puede encogerse pero si hacerse más grande, según sea necesario.&lt;/dd&gt;
&lt;dt&gt;Maximum&lt;/dt&gt;
&lt;dd&gt;El tamaño del control indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es el máximo posible.
No puede agrandarse pero si encogerse, según sea necesario.&lt;/dd&gt;
&lt;dt&gt;Preferred&lt;/dt&gt;
&lt;dd&gt;El mejor tamaño posible es el indicado por &lt;code&gt;QWidget::sizeHint()&lt;/code&gt;, pero el
control puede tanto agrandarse como encogerse, según sea necesario.&lt;/dd&gt;
&lt;dt&gt;Expanding&lt;/dt&gt;
&lt;dd&gt;El mejor tamaño posible es el indicado por &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; pero el
control, de encogerse, seguiría siendo útil. Si sobra espacio, el control
debe hacerse todo lo grande que sea posible.&lt;/dd&gt;
&lt;dt&gt;MinimumExpanding&lt;/dt&gt;
&lt;dd&gt;El tamaño del control indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es el mínimo posible.
No puede agrandarse pero si sobra espacio, el control debe hacerse todo lo
grande que sea posible.&lt;/dd&gt;
&lt;dt&gt;Ignored&lt;/dt&gt;
&lt;dd&gt;El tamaño indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; debe ignorarse y el control
debe hacerse todo lo grande que sea posible.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/layout.html" title="Layout Management"&gt;Layout Management&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;code&gt;QWidget::sizePolicy()&lt;/code&gt; es una propiedad de cada control donde
se fija la política que desea que se siga para asignarle espacio.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es una propiedad de cada control donde se indica
el espacio recomendado que debe ocupar.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;El &lt;em&gt;factor de estiramiento del control&lt;/em&gt; se indica a través de su
propiedad &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Fri, 15 Feb 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-15:layouts-en-qt-organizacion-de-controles.html</guid><category>qt</category><category>gui</category><category>layouts</category></item><item><title>Como usar QMovie en Qt</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/como-usar-qmovie-en-qt.html</link><description>&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; trae una clase denominada &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; que facilita mostrar pequeñas
animaciones sin mucho esfuerzo.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; está diseñada para ser independiente del formato de archivo pero como
internamente depende de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;, sólo puede utilizarse con los que esta
última soporta (véase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#supportedFormats" title="QMovie::supportedFormats()"&gt;supportedFormats&lt;/a&gt;()). Esto incluye GIF
animados, archivos MNG y MJPEG. Para mostrar vídeo y otros contenidos
multimedia, es mejor utilizar el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtmultimedia/multimediaoverview.html" title="Qt Multimedia"&gt;Qt Multimedia&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Primeros pasos&lt;/h2&gt;
&lt;p&gt;La forma más sencilla de usar &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; es asignar un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; a un
control &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; usando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setMovie" title="QLabel::setMovie()"&gt;setMovie&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QMovie&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;video.mjpeg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;donde &lt;code&gt;ui&lt;/code&gt; es el miembro de la clase que tiene asignada la instancia de la
ventana creada previamente con Qt Creator.&lt;/p&gt;
&lt;h2&gt;Nombre de archivo especificado por el usuario&lt;/h2&gt;
&lt;p&gt;No siempre ocurre que el nombre del archivo a reproducir se conozca de antemano
al desarrollar el programar. Si por ejemplo se pretende que el usuario lo
escoja de entre los disponibles en su disco duro podemos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crear un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;, guardarlo en un miembro de la clase (manteniendo
 así un puntero al mismo que nos permita referenciarlo más adelante&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;) y asignar
 dicho objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; a &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;MovieViewerWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QWidget&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QMainWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nn"&gt;Ui::&lt;/span&gt;&lt;span class="n"&gt;MovieViewerWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt; &lt;span class="n"&gt;otro&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;inicializaci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;instancia&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;movie_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el slot de la acción que abre el cuadro de diálogo &lt;em&gt;abrir archivo&lt;/em&gt;,
 asignar al objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; el nombre escogido por el usuario mediante el
 método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#setFileName" title="QMovie::setFileName()"&gt;setFileName&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;on_actionOpen_triggered&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="n"&gt;abre&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;cuadro&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;di&lt;/span&gt;&lt;span class="err"&gt;á&lt;/span&gt;&lt;span class="n"&gt;logo&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;comprueba&lt;/span&gt; &lt;span class="n"&gt;si&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;usuario&lt;/span&gt; &lt;span class="n"&gt;seleccion&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt; &lt;span class="n"&gt;alg&lt;/span&gt;&lt;span class="err"&gt;ú&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;archivo&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;QString&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;QFileDialog::&lt;/span&gt;&lt;span class="n"&gt;getFileName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;

    &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setFileName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isValid&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;QMessageBox::&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="nb"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No se pudo abrir el archivo o el formato&amp;quot;&lt;/span&gt;
               &lt;span class="s"&gt;&amp;quot; es inválido&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Iniciar&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;reproducci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;animaci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se puede observar es conveniente utilizar el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#isValid" title="QMovie::isValid()"&gt;isValid&lt;/a&gt;()
para comprobar si el archivo pudo ser abierto y tiene uno de los formatos soportados.&lt;/p&gt;
&lt;p&gt;Para distinguir entre ambos tipos de error, con el objeto de mostrar al usuario
un mensaje diferente según el caso, podemos emplear el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#device" title="QMovie::device()"&gt;device&lt;/a&gt;().
Este devuelve el objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; (realmente una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; que es la clase
base de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; y de todas clases que representan dispositivos de E/S) vinculado con
la instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;. Así podemos comprobar mediante el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html#isOpen" title="QFile::isOpen()"&gt;isOpen&lt;/a&gt;() si el archivo se pudo abrir con éxito o no.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Control de la reproducción&lt;/h2&gt;
&lt;p&gt;El control de la reproducción se puede hacer mediante los &lt;em&gt;slots&lt;/em&gt;
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() y &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#stop" title="QMovie::stop()"&gt;stop&lt;/a&gt;().&lt;/p&gt;
&lt;p&gt;En el ejemplo anterior se puede observar como el &lt;em&gt;slot&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;()
es invocado exactamente de la misma manera que un método convencional para
iniciar la reproducción de la animación. Sin embargo el hecho de que los
desarrolladores de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; lo hayan declarado como un &lt;em&gt;slot&lt;/em&gt; y no como un
método nos permitiría conectarlo a una señal emitida desde otro control.&lt;/p&gt;
&lt;p&gt;Por ejemplo, si tuvieramos un botón de &lt;em&gt;play&lt;/em&gt; podríamos conectar su señal
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qabstractbutton.html#clicked" title="QAbstractButton::clicked"&gt;clicked&lt;/a&gt;() al slot &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;playButton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clicked&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;de forma que al pulsar dicho botón se inicie automáticamente la reproducción.&lt;/p&gt;
&lt;p&gt;Otro detalle a tener en cuenta es que los &lt;em&gt;slots&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;()
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#stop" title="QMovie::stop()"&gt;stop&lt;/a&gt;() indican a la instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; que inicie o detengan
la reproducción pero, una vez hecho, vuelven inmediatamente. Es decir, que no
se quedan a la espera de que la animación se reproduzca o esperan a que termine.&lt;/p&gt;
&lt;p&gt;Este es un detalle importante porque al &lt;em&gt;slot&lt;/em&gt; &lt;code&gt;on_actionOpen_triggered()&lt;/code&gt; de
nuestro ejemplo se llega a través del bucle de mensajes, cuando el sistema de
ventanas notifica a la aplicación un &lt;em&gt;click&lt;/em&gt; sobre la acción correspondiente. Si
en el &lt;em&gt;slot&lt;/em&gt; introduciésemos tareas de larga duración, la ejecución tardaría en
volver al bucle de mensajes, retrasando el momento en el que la aplicación puede
procesar nuevos eventos de los usuarios. Es decir, que si
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() se quedara a la espera y añadiéramos un botón para detener
la reproducción, este nunca funcionaría porque la aplicación no volvería al bucle
de mensajes hasta que la reproducción no hubiera terminado.&lt;/p&gt;
&lt;p&gt;Podemos comprobar esto añadiendo una espera justo después de invocar el
&lt;em&gt;slot&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QMutex&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Espera&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;segundos&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Debido a los efectos desastrosos que este tipo de esperas tienen en las aplicaciones
dirigidas por eventos, &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; no incluye funciones del tipo de &lt;code&gt;sleep()&lt;/code&gt;, &lt;code&gt;delay()&lt;/code&gt;,
&lt;code&gt;usleep()&lt;/code&gt; y &lt;code&gt;nanosleep()&lt;/code&gt;, que muchos sistemas operativos sí soportan.&lt;/p&gt;
&lt;h2&gt;Procesando la imagen frame a frame&lt;/h2&gt;
&lt;p&gt;Aunque &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; se hace cargo de mostrar la animación sin que tengamos que intervenir
de ninguna otra manera, en ocasiones puede ser interesante tener acceso a los
&lt;em&gt;frames&lt;/em&gt; de manera individualizada para poder procesarlos antes de que sean mostrados.
Por ese motivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; emite una señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;() cada vez que el &lt;em&gt;frame&lt;/em&gt;
actual cambia.&lt;/p&gt;
&lt;p&gt;Para aprovechar eso:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declaramos un &lt;em&gt;slot&lt;/em&gt; para que reciba la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;slots:&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Otros&lt;/span&gt; &lt;span class="n"&gt;slots&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;on_actionOpen_triggered&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definimos el código del &lt;em&gt;slot&lt;/em&gt; para que al ser invocado actualice la
imagen mostrada por el control &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;. En ese sentido el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setPixmap" title="QLabel::setPixmap()"&gt;setPixmap&lt;/a&gt;() permite indicar al objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; que imagen queremos
mostrar. Mientras que &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#currentPixmap" title="QMovie::currentPixmap()"&gt;currentPixmap&lt;/a&gt;() nos permite obtener el último
&lt;em&gt;frame&lt;/em&gt; del objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; en formato &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QPixmap&lt;/span&gt; &lt;span class="n"&gt;pixmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;currentPixmap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setPixmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pixmap&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Suprimimos el uso del método &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setMovie" title="QLabel::setMovie()"&gt;setMovie&lt;/a&gt;(), para que el
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; no sepa nada de nuestra animación, y conectamos la señal
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;() con nuestro nuevo slot:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;movie_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ahora podríamos introducir en el &lt;em&gt;slot&lt;/em&gt; todo aquello que nos interese hacer
sobre los &lt;em&gt;frames&lt;/em&gt; antes de mostrarlos.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; Class Reference.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/widgets-movie.html"&gt;Moviel Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/widgets-imageviewer.html"&gt;Image Viewer Example&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Sin olvidarnos de que es necesario para liberar la memoria en el destructor de la clase &lt;code&gt;MovieViewerWindow&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Esta clase es la base de todos los dispositivos de E/S, incluidos los archivos. Su
misión es proporcionar una interfaz común; mediante métodos como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html#open" title="QFile::open()"&gt;open&lt;/a&gt;(),
&lt;code&gt;close()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;seek()&lt;/code&gt;, etc.; con la que acceder a cualquier
dispositivo. De &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; heredan clases como &lt;code&gt;QBuffer&lt;/code&gt;, &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html" title="QProcess"&gt;QProcess&lt;/a&gt; o &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; que
proporcionan implementaciones concretas para cada tipo de dispositivo en particular.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Wed, 13 Feb 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-13:como-usar-qmovie-en-qt.html</guid><category>qt</category><category>gui</category><category>qmovie</category></item><item><title>Proyecto Qt. Framework de desarrollo de aplicaciones</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html</link><description>&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; es una &lt;em&gt;framework&lt;/em&gt; multiplataforma en C++ de desarrollo de aplicaciones. Se
utiliza fundamentalmente para desarrollar aplicaciones con interfaz gráfica,
gracias al conjunto de controles independientes de la plataforma que ofrece,
aunque también es usado para crear herramientas de linea de comando o consolas
de gestión para servicios.&lt;/p&gt;
&lt;p&gt;Esto último es debido a que el API de la librería cuenta con clases para:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acceso a bases de datos mediante SQL.&lt;/li&gt;
&lt;li&gt;Procesamiento de XML.&lt;/li&gt;
&lt;li&gt;Gestión de hilos.&lt;/li&gt;
&lt;li&gt;Comunicaciones por red.&lt;/li&gt;
&lt;li&gt;Manejo de archivos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a parte de las clases ya mencionadas para el desarrollo de aplicaciones con
interfaz gráfica. Todo esto convierte a &lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; en un &lt;em&gt;framework&lt;/em&gt; muy valorado a la
hora de desarrollar aplicaciones multiplataforma en C++.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; está disponible para sistemas tipo UNIX (Linux, BSD, UNIX, etc.) con
servidor gráfico X Window System, Apple Mac OS X, Microsoft Windows y sistemas
Linux embebidos. Además se puede hacer uso de la librería desde lenguajes
diferentes a C++ gracias al empleo de &lt;a href="http://es.wikipedia.org/wiki/Bindings"&gt;bindings&lt;/a&gt;:
Python, Java, Ruby, Ada, Pascal, Perl, PHP, Haskell, Lua, D, .NET, etc.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; está disponible bajo licencias GPLv3, LGPLv2 y privativa comercial.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/"&gt;Qt Proyect&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Qt_(framework)"&gt;Wikipedia&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Tue, 29 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-29:proyecto-qt-framework-de-desarrollo-de-aplicaciones.html</guid><category>qt</category><category>gui</category></item><item><title>Crea tu propia distro de Linux con Yocto</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/crea-tu-propia-distro-de-linux-con-yocto.html</link><description>&lt;p&gt;El objetivo de este artículo es explicar paso a paso como se puede utilizar
el proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; para crear nuestra propia distribución de Linux. Primero
construiremos una para ejecutarla en &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt; y después otra para nuestra
Raspberry Pi.&lt;/p&gt;
&lt;h2&gt;Inicio rápido&lt;/h2&gt;
&lt;p&gt;El inicio rápido con el proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; está perfectamente documentado en
&lt;a href="http://www.yoctoproject.org/docs/1.0/yocto-quick-start/yocto-project-qs.html" title="Yocto Project Quick Start"&gt;Yocto Project Quick Start&lt;/a&gt;. En cualquier caso aquí resumiremos los pasos
deteniéndonos en los de mayor importancia.&lt;/p&gt;
&lt;h3&gt;Requisitos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Una distribución de Linux.&lt;/strong&gt; En nuestro caso, por simplicidad, cualquiera
de las basadas en Debian.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paquetes de desarrollo.&lt;/strong&gt; En el sistema deben estar instalados una serie
de paquetes utilizados habitualmente en tareas de desarrollo. En un sistema
basado en Debian deberían poder instalarse con el siguiente comando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo apt-get install sed wget cvs subversion git-core &lt;span class="se"&gt;\&lt;/span&gt;
coreutils unzip texi2html texinfo libsdl1.2-dev docbook-utils &lt;span class="se"&gt;\&lt;/span&gt;
gawk python-pysqlite2 diffstat help2man make gcc &lt;span class="se"&gt;\&lt;/span&gt;
build-essential g++ desktop-file-utils chrpath libgl1-mesa-dev &lt;span class="se"&gt;\&lt;/span&gt;
libglu1-mesa-dev mercurial autoconf automake groff
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Una versión del proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt;.&lt;/strong&gt; Las distintas versiones pueden
descargarse desde la dirección:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://downloads.yoctoproject.org/releases/yocto/"&gt;http://downloads.yoctoproject.org/releases/yocto/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Construir una imagen de sistema Linux&lt;/h3&gt;
&lt;p&gt;El proceso de construir una imagen genera una distribución de Linux completa,
incluyendo las herramienta de desarrollo para la misma:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Descargar el sistema de construcción &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Poky&lt;/a&gt; de la última versión del
proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; y descomprimirla:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;wget http://downloads.yoctoproject.org/releases/yocto/yocto-1.3/poky-danny-8.0.tar.bz2
&lt;span class="nv"&gt;$ &lt;/span&gt;tar jxf poky-danny-8.0.tar.bz2
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crear el directorio &lt;code&gt;raspberry-pi-build&lt;/code&gt; donde construir la imagen y
configurar las variables de entorno necesarias:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;source &lt;/span&gt;poky-danny-8.0/oe-init-build-env raspberry-pi-build
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como las variables de entorno configuradas por este comando se pierden al
 cerrar la shell, en caso de que eso ocurra o de abandonar la sesión sería
 necesario volver a ejecutar este comando antes de continuar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construir la imagen:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;bitbake core-image-minimal
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;La imagen construida puede ejecutarse en &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt; de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;runqemu qemux86
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y en unos segundos tendremos acceso a la consola de nuestra nueva distribución.&lt;/p&gt;
&lt;h3&gt;Optimizando la construcción&lt;/h3&gt;
&lt;p&gt;En el archivo &lt;code&gt;conf/local.conf&lt;/code&gt; del directorio &lt;code&gt;raspberry-pi-build&lt;/code&gt; se pueden
definir algunos parámetros que pueden reducir el tiempo necesario para
construir la imagen si se dispone de un sistema multi-núcleo.&lt;/p&gt;
&lt;p&gt;Si se tienen &lt;code&gt;N&lt;/code&gt; núcleos, es conveniente descomentar las variables &lt;code&gt;BB_NUMBER_THREADS&lt;/code&gt;
y &lt;code&gt;PARALLEL_MAKE&lt;/code&gt; y asignarle &lt;code&gt;N + 1&lt;/code&gt;. Por ejemplo, con 8 núcleos el valor
debería ser 9:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;BB_NUMBER_THREADS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;9&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;PARALLEL_MAKE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;-j 9&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Crear una distribución para Raspberry Pi&lt;/h2&gt;
&lt;p&gt;El ejemplo estándar del proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; se construye por defecto para la arquitectura
&lt;strong&gt;qemux86&lt;/strong&gt;. En el caso de querer compilar para otro sistema sólo es necesario añadir
una capa que incorpore los archivos de configuración necesarios.&lt;/p&gt;
&lt;p&gt;En nuestro caso dicha capa es &lt;strong&gt;meta-raspberrypi&lt;/strong&gt;, una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; que agrupa todos los
metadatos necesarios para construir para dispositivos Raspberry Pi. Fundamentalmente
contiene configuraciones para el núcleo y opciones para la arquitectura.&lt;/p&gt;
&lt;p&gt;Estos son los pasos para incorporarla a nuestro proyecto:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Clonar localmente el repositorio &lt;strong&gt;meta-raspberrypi&lt;/strong&gt; fuera del directorio
&lt;code&gt;raspberry-pi-build&lt;/code&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git clone https://github.com/djwillis/meta-raspberrypi.git
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cambiar a la rama &lt;strong&gt;danny&lt;/strong&gt; que es la de la versión de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Poky&lt;/a&gt; que estamos usando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;meta-raspberrypi
&lt;span class="nv"&gt;$ &lt;/span&gt;git checkout danny
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buscar la variable &lt;code&gt;BBLAYERS&lt;/code&gt; en &lt;code&gt;raspberry-pi-build/conf/bblayers.conf&lt;/code&gt; y añadir
al final la ruta hasta el repositorio de la capa &lt;strong&gt;meta-raspberrypi&lt;/strong&gt; para incluirla
en el proceso de construcción. Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;BBLAYERS&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/poky-danny-8.0/meta \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/poky-danny-8.0/meta-yocto \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/poky-danny-8.0/meta-yocto-bsp \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/meta-raspberry-pi \&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buscar la variable &lt;code&gt;MACHINE&lt;/code&gt; en &lt;code&gt;raspberry-pi-build/conf/local.conf&lt;/code&gt; e indicar que
la máquina de destino de la imagen es &lt;code&gt;raspberrypi&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;MACHINE&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;raspberrypi&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construir la imagen:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd &lt;/span&gt;raspberry-pi-build
&lt;span class="nv"&gt;$ &lt;/span&gt;bitbake rpi-basic-image
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta imagen incluye un servidor &lt;strong&gt;SSH&lt;/strong&gt; y un &lt;em&gt;splash&lt;/em&gt; de Raspberry Pi durante el arranque.
Mientras que la imagen alternativa &lt;code&gt;rpi-hwup-image&lt;/code&gt; no contiene ninguna de las dos cosas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transferir la imagen construida a la tarjeta SD.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;sudo dd &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;tmp/deploy/images/rpi-basic-image-raspberrypi.rpi-sdimg &lt;span class="nv"&gt;of&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/ruta/a/la/sd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;y probarla en el dispositivo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/yocto-quick-start/yocto-project-qs.html"&gt;Yocto Project Quick Start&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pokylinux.org/doc/poky-handbook.html"&gt;Poky HandBook&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pimpmypi.com/blog/blogPost.php?blogPostID=7"&gt;Build a Custom Raspberry Pi Distro with OpenEmbedded &amp;amp; Yocto&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Tue, 22 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-22:crea-tu-propia-distro-de-linux-con-yocto.html</guid><category>yocto</category><category>poky</category><category>distribución</category></item><item><title>Cámara CF7670C-V2</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/camara-cf7670c-v2.html</link><description>&lt;p&gt;Los módulos de cámara CF7670C y CF7670C-V2 combinan el sensor CMOS &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt;
con una memoria FIFO &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fV3gyQ3dfTkRETDg/edit" title="FIFO Averlogic AL422"&gt;Averlogic AL422&lt;/a&gt; de 3Mb.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://drive.google.com/uc?export=download&amp;confirm=&amp;id=0B4Cklvu_Zw9fS20tR1lnYmFHZVk" width="300" alt="Cámara CF7670C-V2" class="right-float"&gt;&lt;/p&gt;
&lt;p&gt;La idea es que las imágenes capturadas por el sensor se almacenen en la memoria FIFO,
dando tiempo a la CPU externa a recuperarlas al ritmo que le sea posible.&lt;/p&gt;
&lt;p&gt;Las principales características del sensor &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt; son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolución de 640x480 pixels (VGA).&lt;/li&gt;
&lt;li&gt;Hasta 30 fps para resolución VGA.&lt;/li&gt;
&lt;li&gt;Formatos de salida (8 bits):&lt;ul&gt;
&lt;li&gt;&lt;a href="http://es.wikipedia.org/wiki/YUV" title="YUV"&gt;YUV&lt;/a&gt;/&lt;a href="http://es.wikipedia.org/wiki/YCbCr" title="YCbCr"&gt;YCbCr&lt;/a&gt; 4:2:2&lt;/li&gt;
&lt;li&gt;RGB 565/555/444&lt;/li&gt;
&lt;li&gt;GRB 4:2:2&lt;/li&gt;
&lt;li&gt;Raw RGB Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modo de &lt;a href="http://es.wikipedia.org/wiki/Escaneo_progresivo"&gt;escaneo progresivo&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Interfaz de control mediante &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fTThIUmdRYUw4TXM/edit" title="Serial Camera Control Bus"&gt;SCCB&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tal y como se puede observar en el &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNFJ3QTdaY284Znc/edit" title="CF7670C-V2 Camera Module Schematic"&gt;esquemático&lt;/a&gt; del módulo, tanto el bus
&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fTThIUmdRYUw4TXM/edit" title="Serial Camera Control Bus"&gt;SCCB&lt;/a&gt; (que prácticamente es un &lt;a href="http://es.wikipedia.org/wiki/I2C" title="I²C (Inter-Integrated Circuit)"&gt;I2C&lt;/a&gt;) como las líneas del OV7670 que informan
del barrido vertical (VSYNC) y horizontal (HREF) están disponibles para que
sean accesibles a una CPU externa.&lt;/p&gt;
&lt;p&gt;Por el contrario, las líneas de datos del OV7670 están conectadas al AL422
para almacenar en el la imagen capturada. Es la salida de esta memoria FIFO,
así como las líneas necesarias para controlar la lectura de la misma, las que
son  accesibles desde el conector del módulo.&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fV3gyQ3dfTkRETDg/edit" title="FIFO Averlogic AL422"&gt;Averlogic AL422&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNFJ3QTdaY284Znc/edit"&gt;Esquemático del módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNzFIbml0dHNXaTQ/edit"&gt;Pines del módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/uc?export=download&amp;amp;confirm=&amp;amp;id=0B4Cklvu_Zw9fS3c4VTRTNHJvMEU"&gt;Controlador de ejemplo para el módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9feEVCU3BzZHY4SEk/edit"&gt;OV7670 Implementation Guide&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:camara-cf7670c-v2.html</guid><category>cf7670c</category><category>i2c</category><category>ov7670</category><category>al422</category></item><item><title>LCD 1.8" SPI (ST7735)</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/lcd-18-spi-st7735.html</link><description>&lt;p&gt;El módulo en cuestión tiene las siguientes características:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://drive.google.com/uc?export=download&amp;confirm=&amp;id=0B4Cklvu_Zw9fUmF1d0YzNzMwNG8" alt="Pantalla LCD" class="right-float"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolución de 128x160 pixels.&lt;/li&gt;
&lt;li&gt;262K colores.&lt;/li&gt;
&lt;li&gt;Retro-iluminación LED.&lt;/li&gt;
&lt;li&gt;Interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; a través del chip controlador ST7735R.&lt;/li&gt;
&lt;li&gt;Compatible con lógica TTL de 3.3 y 5v.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El corazón del módulo es el chip controlador ST7735. Este se conecta por un lado
a la LCD propiamente dicha y por el otro ofrece una interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; a la que
se puede conectar una CPU externa. Los datos a mostrar se pueden almacenar
en una RAM interna con capacidad para 132x162x18 bits.&lt;/p&gt;
&lt;p&gt;Las aplicaciones pueden acceder directamente al módulo a través de la
interfaz de programación &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; que el núcleo puede hacer pública al espacio de
usuario. Sin embargo una de las características más interesantes de este
módulo es la existencia de un &lt;a href="http://es.wikipedia.org/wiki/Framebuffer" title="Framebuffer"&gt;controlador de vídeo&lt;/a&gt; para sistemas
Linux. Haciendo uso del mismo las aplicaciones pueden utilizar la pantalla LCD
como si de una tarjeta gráfica convencional se trata, ignorando la interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/file/d/0B4Cklvu_Zw9fMmM3U0I2NU53Y3c/edit"&gt;Hoja de datos Sitronix ST7735 262K Color Single-Chip TFT Controller/Driver&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/uc?export=download&amp;amp;confirm=&amp;amp;id=0B4Cklvu_Zw9fT2hjVmpIQ2x0NVU"&gt;Librería para Arduino y programas de ejemplo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ohporter/linux-am33x/blob/st7735fb/drivers/video/st7735fb.c"&gt;FB driver for ST7735 LCD controller&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:lcd-18-spi-st7735.html</guid><category>lcd</category><category>spi</category><category>st7735</category></item><item><title>Raspberry Pi</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/raspberry-pi.html</link><description>&lt;p&gt;Una Raspberry Pi es una placa computadora (&lt;a href="http://en.wikipedia.org/wiki/Single-board_computer" title="Single-board Computer"&gt;SBC&lt;/a&gt;) de bajo coste que incluye:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://commons.wikimedia.org/wiki/File:RaspberryPi.jpg"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/RaspberryPi.jpg/320px-RaspberryPi.jpg" alt="Raspberry Pi" class="right-float"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Un &lt;a href="http://es.wikipedia.org/wiki/System_on_a_chip" title="System on a Chip"&gt;SOC&lt;/a&gt; Broadcom BCM2835, que contiene una CPU &lt;a href="http://en.wikipedia.org/wiki/ARM11" title="ARM11"&gt;ARM11&lt;/a&gt;76JZF-S a 700 MHz y
una GPU &lt;a href="http://en.wikipedia.org/wiki/VideoCore" title="VideoCore"&gt;VideoCore&lt;/a&gt; IV.&lt;/li&gt;
&lt;li&gt;512 MB de memoria RAM (en la versión B de Raspberry Pi, 256 MB en la versión A)
instalada sobre la CPU.&lt;/li&gt;
&lt;li&gt;Una ranura de tarjetas SD/MMC/SDIO para el almacenamiento no volátil.&lt;/li&gt;
&lt;li&gt;1 puerto Ethernet de 10/100Mb.&lt;/li&gt;
&lt;li&gt;2 puertos USB 2.0.&lt;/li&gt;
&lt;li&gt;1 puerto micro USB de alimentación.&lt;/li&gt;
&lt;li&gt;1 puerto tipo A de salida HDMI 1.3.a&lt;/li&gt;
&lt;li&gt;1 conector RCA de salida de vídeo compuesto.&lt;/li&gt;
&lt;li&gt;1 conector jack estéreo de 3.5mm para la salida de audio.&lt;/li&gt;
&lt;li&gt;1 conector de expansión de 26 pines con:&lt;ul&gt;
&lt;li&gt;8 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;2 puertos seriales (&lt;a href="http://es.wikipedia.org/wiki/Universal_Asynchronous_Receiver-Transmitter" title="Universal Asynchronous Receiver-Transmitter"&gt;UART&lt;/a&gt;) a 3.3v TTL o 2 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;1 interfaz &lt;a href="http://es.wikipedia.org/wiki/I2C" title="I²C (Inter-Integrated Circuit)"&gt;I2C&lt;/a&gt; (3.3v) o 2 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;1 interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; (3.3v) o 5 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;Diversos pines a 3.3v, 5v y tierra (GND).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;entre otros componentes. En la web del proyecto colaborativo &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt;
hay disponible más información sobre todo este &lt;a href="http://elinux.org/RPi_Hardware" title="RPi Hardware"&gt;hardware&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Respecto al software la &lt;a href="http://www.raspberrypi.org/about" title="Raspberry Pi Foundation"&gt;Fundación Raspberry Pi&lt;/a&gt; da soporte para las distribuciones
&lt;a href="http://www.raspbian.org/" title="Raspbian"&gt;Raspbian&lt;/a&gt; (derivada de Debian), &lt;a href="http://es.wikipedia.org/wiki/RISC_OS"&gt;RISC OS&lt;/a&gt;
y Arch Linux y promueve principalmente el aprendizaje de los lenguajes de
programación &lt;a href="http://es.wikipedia.org/wiki/Python" title="Lenguage de programación Python"&gt;Python&lt;/a&gt; y &lt;a href="http://es.wikipedia.org/wiki/Scratch_(lenguaje_de_programaci%C3%B3n)" title="Lenguage de programación Scratch"&gt;Scratch&lt;/a&gt; con &lt;a href="http://www.raspberrypi.org/archives/2965"&gt;fines educativos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Otra organización que se ha volcado en Raspberry Pi es &lt;a href="http://www.adafruit.com/blog/category/raspberry-pi/" title="Adafruit - Raspberry Pi"&gt;Adafruit&lt;/a&gt;. Esta compañía
en la actualidad provee &lt;a href="https://www.adafruit.com/raspberrypi"&gt;productos&lt;/a&gt; relacionados,
&lt;a href="http://learn.adafruit.com/category/raspberry-pi"&gt;formación&lt;/a&gt;, su propia
distribución &lt;a href="http://learn.adafruit.com/adafruit-raspberry-pi-educational-linux-distro"&gt;Adafruit Raspberry Pi Educational Linux Distro&lt;/a&gt;,
que tiene algunas ventajas respecto a las oficiales, y el
entorno de desarrollo &lt;a href="http://learn.adafruit.com/webide/"&gt;Raspberry Pi WebIDE&lt;/a&gt;
basado en web para crear fácilmente aplicaciones en &lt;a href="http://es.wikipedia.org/wiki/Python" title="Lenguage de programación Python"&gt;Python&lt;/a&gt;, Ruby o JavaScript.&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://downloads.raspberrypi.org/Raspberry_Pi_Education_Manual.pdf"&gt;Raspberry Pi Educational Manual&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/RPi_Hardware" title="RPi Hardware"&gt;RPi Hardware&lt;/a&gt; en &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/RPi_Low-level_peripherals"&gt;RPi Low-level periperals&lt;/a&gt; en &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt; (incluye el detalle del conector de expasión).&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf"&gt;BCM2835 ARM Peripherals&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/DDI0301H_arm1176jzfs_r0p7_trm.pdf"&gt;ARM1176JZF-S Technical Reference Manual&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/wp-content/uploads/2012/10/Raspberry-Pi-R2.0-Schematics-Issue2.2_027.pdf"&gt;Raspberry Pi 2.0 Schematics&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:raspberry-pi.html</guid><category>rpi</category><category>raspberry pi</category><category>arm</category><category>gpio</category><category>videocore</category><category>broadcom</category></item><item><title>Yocto, Poky y BitBake</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html</link><description>&lt;p&gt;El proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; proporciona a los desarrolladores de sistemas empotrados
Linux un punto de partida para generar distribuciones personalizadas para
sus productos. Una de las piezas clave del proyecto es el sistema de
construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, que a su vez se apoya en &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt;, una herramienta de
construcción de paquetes al estilo de
&lt;a href="http://es.wikipedia.org/wiki/Portage_(software)"&gt;Portage&lt;/a&gt; de
&lt;a href="http://www.gentoo.org/"&gt;Gentoo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;El proyecto Yocto&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; está financiado por la &lt;a href="http://www.linuxfoundation.org/"&gt;Linux Foundation&lt;/a&gt;.
Su principal objetivo es desarrollar herramientas que ayuden a los desarrolladores
a crear sus propias distribuciones de Linux, sea cual sea el hardware sobre el que
van a correr. Entre los proyectos desarrollados en el seno de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; están:
el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, el sistema de
&lt;a href="http://es.wikipedia.org/wiki/Integraci%C3%B3n_continua"&gt;integración continua&lt;/a&gt;
&lt;a href="http://autobuilder.yoctoproject.org/"&gt;Autobuiler&lt;/a&gt; y la librería de sistema
&lt;a href="http://www.eglibc.org/"&gt;Embedded GLIBC (EGLIBC)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Además, cuando se crea una distribución con &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, la herramienta de construcción
crea un SDK de desarrollo de aplicaciones adaptado a dicha distribución. Este
SDK puede conectarse al IDE &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; o puede usarse desde la línea de comandos.&lt;/p&gt;
&lt;h2&gt;El sistema de construcción Poky&lt;/h2&gt;
&lt;p&gt;Uno de los componentes centrales de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; es el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.
Su responsabilidad fundamental es la construcción de imágenes de sistemas de
archivos de sistemas Linux. Estos pueden incluir diferentes productos de software:
Linux, X11, Matchbox, GTK+, Pimlico, Clutter, D-BUS, etc.&lt;/p&gt;
&lt;p&gt;Aunque se pueden generar diferentes tipos de imágenes según el dispositivo donde
va a ser almacenada, el proyecto ejemplo estándar lo hace para el emulador &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;
y para placas de referencia reales de los fabricantes, para cada una de las
arquitecturas soportadas. Esta habilidad de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; lo hace especialmente
apropiado como plataforma de pruebas y de desarrollo de software para empotrados.&lt;/p&gt;
&lt;p&gt;Un proyecto similar a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, que también es un sistema de construcción
para sistemas Linux empotrados. &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; deriva de un proyecto para crear
una rama estabilizada de &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, limitando el software disponible a unos
pocos paquetes, de entre los miles de los que dispone &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, así como el número
de arquitecturas soportadas. Con el tiempo esta rama evolucionó añadiendo
el componente de &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; y la generación de imágenes para &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;, entre otras cosas.
Esto dio origen a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El núcleo central de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es la herramienta de construcción &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; junto
con una colección de archivos de configuración de diversos tipos que definen
todo lo necesario para construir la imagen del sistema Linux.&lt;/p&gt;
&lt;h2&gt;La herramienta de construcción BitBake&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; es básicamente un ejecutor de tareas. Su función es leer los archivos
de configuración que definen el proyecto; establecer que tareas deben ser realizadas
y en que orden, obviamente en función de las dependencias y para maximizar la eficiencia
(por ejemplo primero se intentan ejecutar las que son dependencias comunes a otras tareas)
y finalmente ejecutarlas.&lt;/p&gt;
&lt;p&gt;Los tipos de archivos de configuración que maneja &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; son:&lt;/p&gt;
&lt;dl&gt;
 &lt;dt&gt;Recetas (.bb)&lt;/dt&gt;
 &lt;dd&gt;Contienen información acerca de un componente de software concreto. Entre
 dicha información, por ejemplo, podemos destacar: desde donde descargar los
 parches para las fuentes, que configuraciones deben ser aplicadas antes de
 la compilación, como se compila el componente y como se empaqueta el resultado.&lt;/dd&gt;
 &lt;dt&gt;Clases (.bbclass)&lt;/dt&gt;
 &lt;dd&gt;Contienen información que es interesante compartir entre distintas recetas.
 Por ejemplo la clase **autotools**, que contiene configuraciones comunes para
 cualquier aplicación que utiliza la herramienta **autotools**.&lt;/dd&gt;
 &lt;dt&gt;Configuraciones (.conf)&lt;/dt&gt;
 &lt;dd&gt;Define diversas variables de configuración que controlan lo que Poky va
 a hacer. Esto incluye configuraciones específicas de la maquina, opciones de
 configuración de la distribución, ajustes del compilador, configuraciones de
 usuario, etc.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; puede combinar varios de estos archivos en los se denomina como &lt;strong&gt;capas&lt;/strong&gt;.
Una capa es un agrupamiento de recetas que proporciona algún tipo de funcionalidad
adicional. Pueden ser un &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para un nuevo dispositivo, tipos de imágenes
adicionales o software no incluido en Poky.&lt;/p&gt;
&lt;p&gt;Los mismos metadatos principales del proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, &lt;strong&gt;meta-yocto&lt;/strong&gt;, son por si
mismos una capa aplicada sobre la capa de metadatos OE-Core que añade software
adicional y tipos de imágenes a esta última.&lt;/p&gt;
&lt;p&gt;Un ejemplo de como funciona esto se puede ver al crear un dispositivo &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;
(Network-attached Storage) para la CPU Intel E660
(&lt;a href="http://www.intel.com/p/es_XL/embedded/hwsw/hardware/atom-e6xx/overview"&gt;Crown Bay&lt;/a&gt;)
usando x32, el nuevo &lt;a href="http://en.wikipedia.org/wiki/Application_binary_interface" title="Application binary interface"&gt;ABI&lt;/a&gt; nativo de 32 bits para procesadores x86-64:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;En el nivel más bajo colocaríamos una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para Crown Bay que activaría
 funcionalidades específicas del hardware de estos procesadores.
 Esta capa, por ejemplo, incluiría los drivers de vídeo.&lt;/li&gt;
&lt;li&gt;Como queremos utilizar x32, añadiríamos posteriormente la capa &lt;strong&gt;meta-x32&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;La funcionalidad de &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt; se incorporaría añadiendo la capa &lt;strong&gt;meta-bayron&lt;/strong&gt;,
 que el mismo proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; nos ofrece como ejemplo.&lt;/li&gt;
&lt;li&gt;Finalmente incorporaríamos una capa, que imaginariamente llamaremos
 &lt;strong&gt;meta-myproject&lt;/strong&gt;, para proveer el software y la configuraciones necesarias
 para crear una interfaz gráfica de usuario de configuración del &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Como hemos comentado, cada una de estas capas estaría formada por uno o más
archivos de configuración de los tipos indicados anteriormente.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.aosabook.org/en/yocto.html"&gt;The Yocto Proyect&lt;/a&gt;.
 &lt;a href="http://www.aosabook.org/"&gt;The Architecture of Open Source Applications&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.yoctoproject.org/wiki/FAQ"&gt;Yocto Proyect FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/poky-ref-manual/poky-ref-manual.html"&gt;Poky HandBook&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Thu, 10 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-10:yocto-poky-y-bitbake.html</guid><category>yocto</category><category>poky</category><category>bitbake</category><category>empotrado</category><category>linux</category><category>openembedded</category></item></channel></rss>