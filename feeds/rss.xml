<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>Sistema de Videovigilancia from Scratch</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/</link><description></description><atom:link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/rss.xml" rel="self"></atom:link><lastBuildDate>Tue, 22 Jan 2013 00:00:00 +0000</lastBuildDate><item><title>Crea tu propia distro de Linux con Yocto</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/crea-tu-propia-distro-de-linux-con-yocto.html</link><description>&lt;p&gt;El objetivo de este artículo es explicar paso a paso como se puede utilizar
el proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; para crear nuestra propia distribución de Linux. Primero
construiremos una para ejecutarla en &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt; y después otra para nuestra
Raspberry Pi.&lt;/p&gt;
&lt;h2&gt;Inicio rápido&lt;/h2&gt;
&lt;p&gt;El inicio rápido con el proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; está perfectamente documentado en
&lt;a href="http://www.yoctoproject.org/docs/1.0/yocto-quick-start/yocto-project-qs.html" title="Yocto Project Quick Start"&gt;Yocto Project Quick Start&lt;/a&gt;. En cualquier caso aquí resumiremos los pasos
deteniéndonos en los de mayor importancia.&lt;/p&gt;
&lt;h3&gt;Requisitos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Una distribución de Linux.&lt;/strong&gt; En nuestro caso, por simplicidad, cualquiera
de las basadas en Debian.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paquetes de desarrollo.&lt;/strong&gt; En el sistema deben estar instalados una serie
de paquetes utilizados habitualmente en tareas de desarrollo. En un sistema
basado en Debian deberían poder instalarse con el siguiente comando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="n"&gt;wget&lt;/span&gt; &lt;span class="n"&gt;cvs&lt;/span&gt; &lt;span class="n"&gt;subversion&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;coreutils&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;unzip&lt;/span&gt; &lt;span class="n"&gt;texi2html&lt;/span&gt; &lt;span class="n"&gt;texinfo&lt;/span&gt; &lt;span class="n"&gt;libsdl1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;2&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;docbook&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utils&lt;/span&gt; &lt;span class="n"&gt;gawk&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pysqlite2&lt;/span&gt; &lt;span class="n"&gt;diffstat&lt;/span&gt; &lt;span class="n"&gt;help2man&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;gcc&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;desktop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utils&lt;/span&gt; &lt;span class="n"&gt;chrpath&lt;/span&gt; &lt;span class="n"&gt;libgl1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mesa&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;libglu1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mesa&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;mercurial&lt;/span&gt; &lt;span class="n"&gt;autoconf&lt;/span&gt; &lt;span class="n"&gt;automake&lt;/span&gt; &lt;span class="n"&gt;groff&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Una versión del proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt;.&lt;/strong&gt; Las distintas versiones pueden
descargarse desde la dirección:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://downloads.yoctoproject.org/releases/yocto/"&gt;http://downloads.yoctoproject.org/releases/yocto/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Construir una imagen de sistema Linux&lt;/h3&gt;
&lt;p&gt;El proceso de construir una imagen genera una distribución de Linux completa,
incluyendo las herramienta de desarrollo para la misma:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Descargar el sistema de construcción &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Poky&lt;/a&gt; de la última versión del
proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; y descomprimirla:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;wget&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;downloads&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yoctoproject&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;releases&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;yocto&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;yocto&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;1&lt;span class="p"&gt;.&lt;/span&gt;3&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;8&lt;span class="p"&gt;.&lt;/span&gt;0&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bz2&lt;/span&gt;
$ &lt;span class="n"&gt;tar&lt;/span&gt; &lt;span class="n"&gt;jxf&lt;/span&gt; &lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;8&lt;span class="p"&gt;.&lt;/span&gt;0&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bz2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crear el directorio &lt;code&gt;raspberry-pi-build&lt;/code&gt; donde construir la imagen y
configurar las variables de entorno necesarias:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;source&lt;/span&gt; &lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;8&lt;span class="p"&gt;.&lt;/span&gt;0&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;oe&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt; &lt;span class="n"&gt;raspberry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como las variables de entorno configuradas por este comando se pierden al
 cerrar la shell, en caso de que eso ocurra o de abandonar la sesión sería
 necesario volver a ejecutar este comando antes de continuar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construir la imagen:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;bitbake&lt;/span&gt; &lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;minimal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;La imagen construida puede ejecutarse en &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt; de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;runqemu&lt;/span&gt; &lt;span class="n"&gt;qemux86&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y en unos segundos tendremos acceso a la consola de nuestra nueva distribución.&lt;/p&gt;
&lt;h3&gt;Optimizando la construcción&lt;/h3&gt;
&lt;p&gt;En el archivo &lt;code&gt;conf/local.conf&lt;/code&gt; del directorio &lt;code&gt;raspberry-pi-build&lt;/code&gt; se pueden
definir algunos parámetros que pueden reducir el tiempo necesario para
construir la imagen si se dispone de un sistema multi-núcleo.&lt;/p&gt;
&lt;p&gt;Si se tienen &lt;code&gt;N&lt;/code&gt; núcleos, es conveniente descomentar las variables &lt;code&gt;BB_NUMBER_THREADS&lt;/code&gt;
y &lt;code&gt;PARALLEL_MAKE&lt;/code&gt; y asignarle &lt;code&gt;N + 1&lt;/code&gt;. Por ejemplo, con 8 núcleos el valor
debería ser 9:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;BB_NUMBER_THREADS&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &amp;quot;9&amp;quot;
&lt;span class="n"&gt;PARALLEL_MAKE&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &amp;quot;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;j&lt;/span&gt; 9&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Crear una distribución para Raspberry Pi&lt;/h2&gt;
&lt;p&gt;El ejemplo estándar del proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; se construye por defecto para la arquitectura
&lt;strong&gt;qemux86&lt;/strong&gt;. En el caso de querer compilar para otro sistema sólo es necesario añadir
una capa que incorpore los archivos de configuración necesarios.&lt;/p&gt;
&lt;p&gt;En nuestro caso dicha capa es &lt;strong&gt;meta-raspberrypi&lt;/strong&gt;, una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; que agrupa todos los
metadatos necesarios para construir para dispositivos Raspberry Pi. Fundamentalmente
contiene configuraciones para el núcleo y opciones para la arquitectura.&lt;/p&gt;
&lt;p&gt;Estos son los pasos para incorporarla a nuestro proyecto:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Clonar localmente el repositorio &lt;strong&gt;meta-raspberrypi&lt;/strong&gt; fuera del directorio
&lt;code&gt;raspberry-pi-build&lt;/code&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;github&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;djwillis&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;raspberrypi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cambiar a la rama &lt;strong&gt;danny&lt;/strong&gt; que es la de la versión de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Poky&lt;/a&gt; que estamos usando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;raspberrypi&lt;/span&gt;
$ &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="n"&gt;danny&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buscar la variable &lt;code&gt;BBLAYERS&lt;/code&gt; en &lt;code&gt;raspberry-pi-build/conf/bblayers.conf&lt;/code&gt; y añadir
al final la ruta hasta el repositorio de la capa &lt;strong&gt;meta-raspberrypi&lt;/strong&gt; para incluirla
en el proceso de construcción. Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;BBLAYERS&lt;/span&gt; ?&lt;span class="p"&gt;=&lt;/span&gt; &amp;quot; &lt;span class="o"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usuario&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;8&lt;span class="p"&gt;.&lt;/span&gt;0&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;meta&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usuario&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;8&lt;span class="p"&gt;.&lt;/span&gt;0&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;yocto&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usuario&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;8&lt;span class="p"&gt;.&lt;/span&gt;0&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;yocto&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bsp&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
  &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;home&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;usuario&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;raspberry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buscar la variable &lt;code&gt;MACHINE&lt;/code&gt; en &lt;code&gt;raspberry-pi-build/conf/local.conf&lt;/code&gt; e indicar que
la máquina de destino de la imagen es &lt;code&gt;raspberrypi&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;MACHINE&lt;/span&gt; ?&lt;span class="p"&gt;=&lt;/span&gt; &amp;quot;&lt;span class="n"&gt;raspberrypi&lt;/span&gt;&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construir la imagen:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;raspberry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nb"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;
$ &lt;span class="n"&gt;bitbake&lt;/span&gt; &lt;span class="n"&gt;rpi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;basic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta imagen incluye un servidor &lt;strong&gt;SSH&lt;/strong&gt; y un &lt;em&gt;splash&lt;/em&gt; de Raspberry Pi durante el arranque.
Mientras que la imagen alternativa &lt;code&gt;rpi-hwup-image&lt;/code&gt; no contiene ninguna de las dos cosas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transferir la imagen construida a la tarjeta SD.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;$ &lt;span class="n"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;deploy&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;rpi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;basic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;raspberrypi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;rpi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;sdimg&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt;&lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;ruta&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;la&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;y probarla en el dispositivo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/yocto-quick-start/yocto-project-qs.html"&gt;Yocto Project Quick Start&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pokylinux.org/doc/poky-handbook.html"&gt;Poky HandBook&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pimpmypi.com/blog/blogPost.php?blogPostID=7"&gt;Build a Custom Raspberry Pi Distro with OpenEmbedded &amp;amp; Yocto&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Tue, 22 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-22:crea-tu-propia-distro-de-linux-con-yocto.html</guid><category>yocto</category><category>poky</category><category>distribución</category></item><item><title>Cámara CF7670C-V2</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/camara-cf7670c-v2.html</link><description>&lt;p&gt;Los módulos de cámara CF7670C y CF7670C-V2 combinan el sensor CMOS &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt;
con una memoria FIFO &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fV3gyQ3dfTkRETDg/edit" title="FIFO Averlogic AL422"&gt;Averlogic AL422&lt;/a&gt; de 3Mb.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://drive.google.com/uc?export=download&amp;confirm=&amp;id=0B4Cklvu_Zw9fS20tR1lnYmFHZVk" width="300" style="float:right;margin:0 0px 10px 0"&gt;&lt;/p&gt;
&lt;p&gt;La idea es que las imágenes capturadas por el sensor se almacenen en la memoria FIFO,
dando tiempo a la CPU externa a recuperarlas al ritmo que le sea posible.&lt;/p&gt;
&lt;p&gt;Las principales características del sensor &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt; son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolución de 640x480 pixels (VGA).&lt;/li&gt;
&lt;li&gt;Hasta 30 fps para resolución VGA.&lt;/li&gt;
&lt;li&gt;Formatos de salida (8 bits):&lt;ul&gt;
&lt;li&gt;&lt;a href="http://es.wikipedia.org/wiki/YUV" title="YUV"&gt;YUV&lt;/a&gt;/&lt;a href="http://es.wikipedia.org/wiki/YCbCr" title="YCbCr"&gt;YCbCr&lt;/a&gt; 4:2:2&lt;/li&gt;
&lt;li&gt;RGB 565/555/444&lt;/li&gt;
&lt;li&gt;GRB 4:2:2&lt;/li&gt;
&lt;li&gt;Raw RGB Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modo de &lt;a href="http://es.wikipedia.org/wiki/Escaneo_progresivo"&gt;escaneo progresivo&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Interfaz de control mediante &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fTThIUmdRYUw4TXM/edit" title="Serial Camera Control Bus"&gt;SCCB&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tal y como se puede observar en el &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNFJ3QTdaY284Znc/edit" title="CF7670C-V2 Camera Module Schematic"&gt;esquemático&lt;/a&gt; del módulo, tanto el bus
&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fTThIUmdRYUw4TXM/edit" title="Serial Camera Control Bus"&gt;SCCB&lt;/a&gt; (que prácticamente es un &lt;a href="http://es.wikipedia.org/wiki/I2C" title="I²C (Inter-Integrated Circuit)"&gt;I2C&lt;/a&gt;) como las líneas del OV7670 que informan
del barrido vertical (VSYNC) y horizontal (HREF) están disponibles para que
sean accesibles a una CPU externa.&lt;/p&gt;
&lt;p&gt;Por el contrario, las líneas de datos del OV7670 están conectadas al AL422
para almacenar en el la imagen capturada. Es la salida de esta memoria FIFO,
así como las líneas necesarias para controlar la lectura de la misma, las que
son  accesibles desde el conector del módulo.&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fV3gyQ3dfTkRETDg/edit" title="FIFO Averlogic AL422"&gt;Averlogic AL422&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNFJ3QTdaY284Znc/edit"&gt;Esquemático del módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNzFIbml0dHNXaTQ/edit"&gt;Pines del módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/uc?export=download&amp;amp;confirm=&amp;amp;id=0B4Cklvu_Zw9fS3c4VTRTNHJvMEU"&gt;Controlador de ejemplo para el módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9feEVCU3BzZHY4SEk/edit"&gt;OV7670 Implementation Guide&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:camara-cf7670c-v2.html</guid><category>cf7670c</category><category>i2c</category><category>ov7670</category><category>al422</category></item><item><title>LCD 1.8" SPI (ST7735)</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/lcd-18-spi-st7735.html</link><description>&lt;p&gt;El módulo en cuestión tiene las siguientes características:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://drive.google.com/uc?export=download&amp;confirm=&amp;id=0B4Cklvu_Zw9fUmF1d0YzNzMwNG8" style="float:right;margin:0 0px 10px 0"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolución de 128x160 pixels.&lt;/li&gt;
&lt;li&gt;262K colores.&lt;/li&gt;
&lt;li&gt;Retro-iluminación LED.&lt;/li&gt;
&lt;li&gt;Interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; a través del chip controlador ST7735R.&lt;/li&gt;
&lt;li&gt;Compatible con lógica TTL de 3.3 y 5v.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El corazón del módulo es el chip controlador ST7735. Este se conecta por un lado
a la LCD propiamente dicha y por el otro ofrece una interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; a la que
se puede conectar una CPU externa. Los datos a mostrar se pueden almacenar
en una RAM interna con capacidad para 132x162x18 bits.&lt;/p&gt;
&lt;p&gt;Las aplicaciones pueden acceder directamente al módulo a través de la
interfaz de programación &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; que el núcleo puede hacer pública al espacio de
usuario. Sin embargo una de las características más interesantes de este
módulo es la existencia de un &lt;a href="http://es.wikipedia.org/wiki/Framebuffer" title="Framebuffer"&gt;controlador de vídeo&lt;/a&gt; para sistemas
Linux. Haciendo uso del mismo las aplicaciones pueden utilizar la pantalla LCD
como si de una tarjeta gráfica convencional se trata, ignorando la interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/file/d/0B4Cklvu_Zw9fMmM3U0I2NU53Y3c/edit"&gt;Hoja de datos Sitronix ST7735 262K Color Single-Chip TFT Controller/Driver&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/uc?export=download&amp;amp;confirm=&amp;amp;id=0B4Cklvu_Zw9fT2hjVmpIQ2x0NVU"&gt;Librería para Arduino y programas de ejemplo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ohporter/linux-am33x/blob/st7735fb/drivers/video/st7735fb.c"&gt;FB driver for ST7735 LCD controller&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:lcd-18-spi-st7735.html</guid><category>lcd</category><category>spi</category><category>st7735</category></item><item><title>Raspberry Pi</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/raspberry-pi.html</link><description>&lt;p&gt;Una Raspberry Pi es una placa computadora (&lt;a href="http://en.wikipedia.org/wiki/Single-board_computer" title="Single-board Computer"&gt;SBC&lt;/a&gt;) de bajo coste que incluye:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/RaspberryPi.jpg/320px-RaspberryPi.jpg" style="float:right;margin:0 0px 10px 0"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Un &lt;a href="http://es.wikipedia.org/wiki/System_on_a_chip" title="System on a Chip"&gt;SOC&lt;/a&gt; Broadcom BCM2835, que contiene una CPU &lt;a href="http://en.wikipedia.org/wiki/ARM11" title="ARM11"&gt;ARM11&lt;/a&gt;76JZF-S a 700 MHz y
una GPU &lt;a href="http://en.wikipedia.org/wiki/VideoCore" title="VideoCore"&gt;VideoCore&lt;/a&gt; IV.&lt;/li&gt;
&lt;li&gt;512 MB de memoria RAM (en la versión B de Raspberry Pi, 256 MB en la versión A)
instalada sobre la CPU.&lt;/li&gt;
&lt;li&gt;Una ranura de tarjetas SD/MMC/SDIO para el almacenamiento no volátil.&lt;/li&gt;
&lt;li&gt;1 puerto Ethernet de 10/100Mb.&lt;/li&gt;
&lt;li&gt;2 puertos USB 2.0.&lt;/li&gt;
&lt;li&gt;1 puerto micro USB de alimentación.&lt;/li&gt;
&lt;li&gt;1 puerto tipo A de salida HDMI 1.3.a&lt;/li&gt;
&lt;li&gt;1 conector RCA de salida de vídeo compuesto.&lt;/li&gt;
&lt;li&gt;1 conector jack estéreo de 3.5mm para la salida de audio.&lt;/li&gt;
&lt;li&gt;1 conector de expansión de 26 pines con:&lt;ul&gt;
&lt;li&gt;8 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;2 puertos seriales (&lt;a href="http://es.wikipedia.org/wiki/Universal_Asynchronous_Receiver-Transmitter" title="Universal Asynchronous Receiver-Transmitter"&gt;UART&lt;/a&gt;) a 3.3v TTL o 2 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;1 interfaz &lt;a href="http://es.wikipedia.org/wiki/I2C" title="I²C (Inter-Integrated Circuit)"&gt;I2C&lt;/a&gt; (3.3v) o 2 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;1 interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; (3.3v) o 5 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;Diversos pines a 3.3v, 5v y tierra (GND).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;entre otros componentes. En la web del proyecto colaborativo &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt;
hay disponible más información sobre todo este &lt;a href="http://elinux.org/RPi_Hardware" title="RPi Hardware"&gt;hardware&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Respecto al software la &lt;a href="http://www.raspberrypi.org/about" title="Raspberry Pi Foundation"&gt;Fundación Raspberry Pi&lt;/a&gt; da soporte para las distribuciones
&lt;a href="http://www.raspbian.org/" title="Raspbian"&gt;Raspbian&lt;/a&gt; (derivada de Debian), &lt;a href="http://es.wikipedia.org/wiki/RISC_OS"&gt;RISC OS&lt;/a&gt;
y Arch Linux y promueve principalmente el aprendizaje de los lenguajes de
programación &lt;a href="http://es.wikipedia.org/wiki/Python" title="Lenguage de programación Python"&gt;Python&lt;/a&gt; y &lt;a href="http://es.wikipedia.org/wiki/Scratch_(lenguaje_de_programaci%C3%B3n)" title="Lenguage de programación Scratch"&gt;Scratch&lt;/a&gt; con &lt;a href="http://www.raspberrypi.org/archives/2965"&gt;fines educativos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Otra organización que se ha volcado en Raspberry Pi es &lt;a href="http://www.adafruit.com/blog/category/raspberry-pi/" title="Adafruit - Raspberry Pi"&gt;Adafruit&lt;/a&gt;. Esta compañía
en la actualidad provee &lt;a href="https://www.adafruit.com/raspberrypi"&gt;productos&lt;/a&gt; relacionados,
&lt;a href="http://learn.adafruit.com/category/raspberry-pi"&gt;formación&lt;/a&gt;, su propia
distribución &lt;a href="http://learn.adafruit.com/adafruit-raspberry-pi-educational-linux-distro"&gt;Adafruit Raspberry Pi Educational Linux Distro&lt;/a&gt;,
que tiene algunas ventajas respecto a las oficiales, y el
entorno de desarrollo &lt;a href="http://learn.adafruit.com/webide/"&gt;Raspberry Pi WebIDE&lt;/a&gt;
basado en web para crear fácilmente aplicaciones en &lt;a href="http://es.wikipedia.org/wiki/Python" title="Lenguage de programación Python"&gt;Python&lt;/a&gt;, Ruby o JavaScript.&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://downloads.raspberrypi.org/Raspberry_Pi_Education_Manual.pdf"&gt;Raspberry Pi Educational Manual&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/RPi_Hardware" title="RPi Hardware"&gt;RPi Hardware&lt;/a&gt; en &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/RPi_Low-level_peripherals"&gt;RPi Low-level periperals&lt;/a&gt; en &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt; (incluye el detalle del conector de expasión).&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf"&gt;BCM2835 ARM Peripherals&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/DDI0301H_arm1176jzfs_r0p7_trm.pdf"&gt;ARM1176JZF-S Technical Reference Manual&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/wp-content/uploads/2012/10/Raspberry-Pi-R2.0-Schematics-Issue2.2_027.pdf"&gt;Raspberry Pi 2.0 Schematics&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Sun, 13 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:raspberry-pi.html</guid><category>rpi</category><category>raspberry pi</category><category>arm</category><category>gpio</category><category>videocore</category><category>broadcom</category></item><item><title>Yocto, Poky y BitBake</title><link>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html</link><description>&lt;p&gt;El proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; proporciona a los desarrolladores de sistemas empotrados
Linux un punto de partida para generar distribuciones personalizadas para
sus productos. Una de las piezas clave del proyecto es el sistema de
construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, que a su vez se apoya en &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt;, una herramienta de
construcción de paquetes al estilo de
&lt;a href="http://es.wikipedia.org/wiki/Portage_(software)"&gt;Portage&lt;/a&gt; de
&lt;a href="http://www.gentoo.org/"&gt;Gentoo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;El proyecto Yocto&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; está financiado por la &lt;a href="http://www.linuxfoundation.org/"&gt;Linux Foundation&lt;/a&gt;.
Su principal objetivo es desarrollar herramientas que ayuden a los desarrolladores
a crear sus propias distribuciones de Linux, sea cual sea el hardware sobre el que
van a correr. Entre los proyectos desarrollados en el seno de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; están:
el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, el sistema de
&lt;a href="http://es.wikipedia.org/wiki/Integraci%C3%B3n_continua"&gt;integración continua&lt;/a&gt;
&lt;a href="http://autobuilder.yoctoproject.org/"&gt;Autobuiler&lt;/a&gt; y la librería de sistema
&lt;a href="http://www.eglibc.org/"&gt;Embedded GLIBC (EGLIBC)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Además, cuando se crea una distribución con &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, la herramienta de construcción
crea un SDK de desarrollo de aplicaciones adaptado a dicha distribución. Este
SDK puede conectarse al IDE &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; o puede usarse desde la línea de comandos.&lt;/p&gt;
&lt;h2&gt;El sistema de construcción Poky&lt;/h2&gt;
&lt;p&gt;Uno de los componentes centrales de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; es el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.
Su responsabilidad fundamental es la construcción de imágenes de sistemas de
archivos de sistemas Linux. Estos pueden incluir diferentes productos de software:
Linux, X11, Matchbox, GTK+, Pimlico, Clutter, D-BUS, etc.&lt;/p&gt;
&lt;p&gt;Aunque se pueden generar diferentes tipos de imágenes según el dispositivo donde
va a ser almacenada, el proyecto ejemplo estándar lo hace para el emulador &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;
y para placas de referencia reales de los fabricantes, para cada una de las
arquitecturas soportadas. Esta habilidad de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; lo hace especialmente
apropiado como plataforma de pruebas y de desarrollo de software para empotrados.&lt;/p&gt;
&lt;p&gt;Un proyecto similar a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, que también es un sistema de construcción
para sistemas Linux empotrados. &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; deriva de un proyecto para crear
una rama estabilizada de &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, limitando el software disponible a unos
pocos paquetes, de entre los miles de los que dispone &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, así como el número
de arquitecturas soportadas. Con el tiempo esta rama evolucionó añadiendo
el componente de &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; y la generación de imágenes para &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;, entre otras cosas.
Esto dio origen a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El núcleo central de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es la herramienta de construcción &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; junto
con una colección de archivos de configuración de diversos tipos que definen
todo lo necesario para construir la imagen del sistema Linux.&lt;/p&gt;
&lt;h2&gt;La herramienta de construcción BitBake&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; es básicamente un ejecutor de tareas. Su función es leer los archivos
de configuración que definen el proyecto; establecer que tareas deben ser realizadas
y en que orden, obviamente en función de las dependencias y para maximizar la eficiencia
(por ejemplo primero se intentan ejecutar las que son dependencias comunes a otras tareas)
y finalmente ejecutarlas.&lt;/p&gt;
&lt;p&gt;Los tipos de archivos de configuración que maneja &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; son:&lt;/p&gt;
&lt;dl&gt;
 &lt;dt&gt;Recetas (.bb)&lt;/dt&gt;
 &lt;dd&gt;Contienen información acerca de un componente de software concreto. Entre
 dicha información, por ejemplo, podemos destacar: desde donde descargar los
 parches para las fuentes, que configuraciones deben ser aplicadas antes de
 la compilación, como se compila el componente y como se empaqueta el resultado.&lt;/dd&gt;
 &lt;dt&gt;Clases (.bbclass)&lt;/dt&gt;
 &lt;dd&gt;Contienen información que es interesante compartir entre distintas recetas.
 Por ejemplo la clase **autotools**, que contiene configuraciones comunes para
 cualquier aplicación que utiliza la herramienta **autotools**.&lt;/dd&gt;
 &lt;dt&gt;Configuraciones (.conf)&lt;/dt&gt;
 &lt;dd&gt;Define diversas variables de configuración que controlan lo que Poky va
 a hacer. Esto incluye configuraciones específicas de la maquina, opciones de
 configuración de la distribución, ajustes del compilador, configuraciones de
 usuario, etc.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; puede combinar varios de estos archivos en los se denomina como &lt;strong&gt;capas&lt;/strong&gt;.
Una capa es un agrupamiento de recetas que proporciona algún tipo de funcionalidad
adicional. Pueden ser un &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para un nuevo dispositivo, tipos de imágenes
adicionales o software no incluido en Poky.&lt;/p&gt;
&lt;p&gt;Los mismos metadatos principales del proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, &lt;strong&gt;meta-yocto&lt;/strong&gt;, son por si
mismos una capa aplicada sobre la capa de metadatos OE-Core que añade software
adicional y tipos de imágenes a esta última.&lt;/p&gt;
&lt;p&gt;Un ejemplo de como funciona esto se puede ver al crear un dispositivo &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;
(Network-attached Storage) para la CPU Intel E660
(&lt;a href="http://www.intel.com/p/es_XL/embedded/hwsw/hardware/atom-e6xx/overview"&gt;Crown Bay&lt;/a&gt;)
usando x32, el nuevo &lt;a href="http://en.wikipedia.org/wiki/Application_binary_interface" title="Application binary interface"&gt;ABI&lt;/a&gt; nativo de 32 bits para procesadores x86-64:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;En el nivel más bajo colocaríamos una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para Crown Bay que activaría
 funcionalidades específicas del hardware de estos procesadores.
 Esta capa, por ejemplo, incluiría los drivers de vídeo.&lt;/li&gt;
&lt;li&gt;Como queremos utilizar x32, añadiríamos posteriormente la capa &lt;strong&gt;meta-x32&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;La funcionalidad de &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt; se incorporaría añadiendo la capa &lt;strong&gt;meta-bayron&lt;/strong&gt;,
 que el mismo proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; nos ofrece como ejemplo.&lt;/li&gt;
&lt;li&gt;Finalmente incorporaríamos una capa, que imaginariamente llamaremos
 &lt;strong&gt;meta-myproject&lt;/strong&gt;, para proveer el software y la configuraciones necesarias
 para crear una interfaz gráfica de usuario de configuración del &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Como hemos comentado, cada una de estas capas estaría formada por uno o más
archivos de configuración de los tipos indicados anteriormente.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.aosabook.org/en/yocto.html"&gt;The Yocto Proyect&lt;/a&gt;.
 &lt;a href="http://www.aosabook.org/"&gt;The Architecture of Open Source Applications&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.yoctoproject.org/wiki/FAQ"&gt;Yocto Proyect FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/poky-ref-manual/poky-ref-manual.html"&gt;Poky HandBook&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Jesús Torres</dc:creator><pubDate>Thu, 10 Jan 2013 00:00:00 +0000</pubDate><guid>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-10:yocto-poky-y-bitbake.html</guid><category>yocto</category><category>poky</category><category>bitbake</category><category>empotrado</category><category>linux</category><category>openembedded</category></item></channel></rss>