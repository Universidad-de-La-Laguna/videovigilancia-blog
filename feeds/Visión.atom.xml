<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sistema de Videovigilancia from Scratch</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/" rel="alternate"></link><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/Visi%C3%B3n.atom.xml" rel="self"></link><id>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/</id><updated>2013-02-19T00:00:00+00:00</updated><entry><title>Detección de movimiento</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/deteccion-de-movimiento.html" rel="alternate"></link><updated>2013-02-19T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-19:deteccion-de-movimiento.html</id><summary type="html">&lt;p&gt;Detectar movimiento en una secuencia de vídeo es una tarea relativamente simple
que puede abordarse en unos pocos pasos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Supresión del fondo&lt;/strong&gt;. Consiste en estimar un modelo del fondo y compararlo
con el &lt;em&gt;frame&lt;/em&gt; actual para detectar cambios. El resultado es una imagen binaria
donde los píxeles se clasifican entre si forman parte del fondo o son del
primer plano.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Operaciones morfológicas&lt;/strong&gt;. En la imagen resultado de la operación anterior
suelen aparecer regiones de pequeño tamaño marcadas como de primer plano debido
al ruido en el &lt;em&gt;frame&lt;/em&gt; original. Una solución muy común en estos casos es aplicar
operaciones de dilatación y erosión con el objeto de suprimirlas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Extracción de blobs&lt;/strong&gt;. Los píxeles clasificados como de primer plano
suelen agruparse en regiones que corresponden a objetos en movimiento en el
&lt;em&gt;frame&lt;/em&gt; original. La &lt;em&gt;extracción de blobs&lt;/em&gt; permite identificar estas regiones
para, por ejemplo, marcarlas con un cuadro delimitador en la imagen original.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;OpenCV&lt;/h2&gt;
&lt;p&gt;Los pasos a realizar son relativamente sencillos, por lo que no nos costaría
mucho desarrollar nuestra propia implementación, ya que la mayor parte de ellos
están perfectamente documentados de manera muy comprensible en Internet:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Supresión del fondo&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://es.wikipedia.org/wiki/Detecci%C3%B3n_de_primer_plano"&gt;Detección de primer plano&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Operaciones morfológicas&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://es.wikipedia.org/wiki/Morfolog%C3%ADa_matem%C3%A1tica"&gt;Morfología matemática&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Universidad Carlos III de Madrid - &lt;a href="http://www.tsc.uc3m.es/imagine/Curso_ProcesadoMorfologico/Contenido/Operaciones/OperacionesMorfologicas.html"&gt;Operaciones Morfológicas&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Extracción de blobs&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Blob_extraction"&gt;Connected-component labeling&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sin embargo existe una librería de visión por computador, denominada &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt;,
que permite que nos ahorremos todo este trabajo.&lt;/p&gt;
&lt;p&gt;Además en estos casos siempre debemos tener presente que aunque se trate de
algoritmos sencillos, siempre existen pequeñas cuestiones que deben ser tenidas
en cuenta, fundamentalmente desde el punto de vista de la precisión de los
algoritmos y del rendimiento, lo que puede dificultar el desarrollo. Por eso
suele ser preferible utilizar una librería madura en lugar de hacer nuestra
propia implementación.&lt;/p&gt;
&lt;h2&gt;OpenCV y Qt&lt;/h2&gt;
&lt;p&gt;Si estamos desarrollando una aplicación gráfica en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; debemos tomar una serie
de medidas para poder emplear la librería &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; desde ella:&lt;/p&gt;
&lt;h3&gt;Conversión de QImage en cv::Mat&lt;/h3&gt;
&lt;p&gt;Las imágenes de las que haremos uso son instancias de la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;, propia
del &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;. Sin embargo las funciones, clases y métodos de &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt;
esperan objetos &lt;code&gt;cv::Mat&lt;/code&gt;. Para convertir entre un formato y otro podemos emplear
el proyecto &lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt; de &lt;a href="https://github.com/dbzhang800"&gt;Debao Zhang&lt;/a&gt; (licencia
&lt;a href="http://es.wikipedia.org/wiki/MIT_License"&gt;MIT&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Para utilizarlo sólo necesitamos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Descargar en el directorio del proyecto los archivos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.cpp" title="cvmatandqimage.cpp"&gt;cvmatandqimage.cpp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.h" title="cvmatandqimage.h"&gt;cvmatandqimage.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/opencv.pri" title="opencv.pri"&gt;opencv.pri&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri"&gt;QtOpenCV.pri&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Abrir el archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto y añadir al final la línea:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;include&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QtOpenCV&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pri&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Los archivos &lt;code&gt;.pri&lt;/code&gt; tienen el mismo formato que los &lt;code&gt;.pro&lt;/code&gt; pero están pensados
para ser incluidos por estos últimos. En nuestro caso el archivo &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri"&gt;QtOpenCV.pri&lt;/a&gt;
contiene información sobre como incorporar los archivos &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.cpp" title="cvmatandqimage.cpp"&gt;cvmatandqimage.cpp&lt;/a&gt;
y &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/cvmatandqimage.h" title="cvmatandqimage.h"&gt;cvmatandqimage.h&lt;/a&gt; al proyecto, haciendo que las funciones por ellos
definidas estén disponibles para nuestra aplicación.&lt;/p&gt;
&lt;p&gt;Tal y como se comenta en el archivo &lt;code&gt;README.md&lt;/code&gt; de &lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt;, en el proyecto
se definen dos funciones:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;namespace&lt;/span&gt; &lt;span class="n"&gt;QtOcv&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// channels == 0 significa autodetección&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;image2Mat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;img&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;channels&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                      &lt;span class="n"&gt;MatChannelOrder&lt;/span&gt; &lt;span class="n"&gt;rgbOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MCO_BGR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// format == QImage::Format_Invalid significa autodetección&lt;/span&gt;
    &lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;mat2Image&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mat&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;QImage&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Format&lt;/span&gt; &lt;span class="n"&gt;format&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;QImage&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Format_Invalid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;MatChannelOrder&lt;/span&gt; &lt;span class="n"&gt;rgbOrder&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MCO_BGR&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;que podemos usar para convertir objetos &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; a &lt;code&gt;cv::Mat&lt;/code&gt; y viceversa.&lt;/p&gt;
&lt;h3&gt;Añadir la librería OpenCV al proyecto&lt;/h3&gt;
&lt;p&gt;Aunque ya hemos incorporado &lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt; a nuestro proyecto para la conversión
entre formatos de imagen, aun no hemos añadido la librería OpenCV propiamente
dicha:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;El archivo &lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/QtOpenCV.pri" title="QtOpenCV.pri"&gt;QtOpenCV.pri&lt;/a&gt; incluido anteriormente a su vez incluye a
&lt;a href="https://github.com/dbzhang800/QtOpenCV/blob/master/opencv.pri" title="opencv.pri"&gt;opencv.pri&lt;/a&gt;, cuya labor es facilitar el añadir &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; al proyecto. Lo único
que tenemos que hacer es editar el archivo &lt;code&gt;.pro&lt;/code&gt; e incorporar al final la línea:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;add_opencv_modules&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;video&lt;/span&gt; &lt;span class="n"&gt;imgproc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En la &lt;a href="http://docs.opencv.org/modules/core/doc/intro.html"&gt;introducción&lt;/a&gt; de
&lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; se explica que el paquete está divido a su vez en distintos módulos
o librerías, cada uno de los cuales está dedicado a un tipo de tarea específico.
En nuestro caso concreto el módulo &lt;em&gt;video&lt;/em&gt; incluye las clases y funciones de
supresión del fondo que nos interesa utilizar, mientras que &lt;em&gt;imgproc&lt;/em&gt; contiene
las operaciones morfológicas y de detección de contornos.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Si por cualquier motivo no estuviéramos haciendo uso de los archivos &lt;code&gt;.pri&lt;/code&gt;
tendríamos que incorporar la librería al proyecto manualmente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;En Linux y Mac OS X esto se puede hacer como un &lt;em&gt;paquete instalado en el sistema&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;En el menú contextual del proyecto (botón derecho sobre el proyecto)
seleccionar &lt;strong&gt;Add Library.../System package&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el paso posterior indicar &lt;strong&gt;opencv&lt;/strong&gt; como nombre del paquete. Obviamente
la librería tiene que haber sido instalada previamente usando el procedimiento
usual de nuestra distribución.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En Windows este recurso no existe, por lo que la librería suele incorporarse
al proyecto como &lt;em&gt;librería externa&lt;/em&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;En el menú contextual del proyecto (botón derecho sobre el proyecto)
seleccionar &lt;strong&gt;Add Library.../External library&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Indicar el archivo de la librería (&lt;em&gt;Library file&lt;/em&gt;) que queremos
incorporar y el directorio de cabeceras (&lt;em&gt;Include Path&lt;/em&gt;). Como lo estamos
haciendo para Windows, sólo tenemos que tener marcada dicha opción en la lista
de plataformas soportadas. Por lo general:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Librerías en &lt;code&gt;C:\opencv\build\&amp;lt;ARQUITECTURA&amp;gt;\mingw\lib&lt;/code&gt;: &lt;code&gt;libopencv_core&amp;lt;VERSION&amp;gt;.dll.a&lt;/code&gt; y &lt;code&gt;libopencv_video&amp;lt;VERSION&amp;gt;.dll.a&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Ruta de las cabeceras: &lt;code&gt;C:\opencv\build\include&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para ambos sistemas, al terminar se nos abrirá el archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto con
los cambios correspondientes realizados. Debemos guardarlo para dar por
finalizada la incorporación de la librería.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;QImage vs QPixmap&lt;/h2&gt;
&lt;p&gt;Una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; es una representación de una imagen optimizada para
ser mostrada. Esto significa que en muchos sistemas sus características
dependen de las de la pantalla (p. ej. su profundida de color puede tener que
ser la misma que la que actualmente tiene el adaptador gráfico: 8 bits,
16 bits, 32 bits, etc.) y que internamente se implementa mediante algún tipo
de objeto del lado del servidor gráfico cuya función es representar a las
imágenes de cara al resto del sistema de ventanas. Por lo tanto, los píxeles
de un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; no son accesibles directamente por parte del aplicación.&lt;/p&gt;
&lt;p&gt;Una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; es una representación independiente del hardware de
una imagen. Básicamente permite leer y escribir imágenes desde un archivo y
manipular los píxeles directamente, sin que las características actuales del
adaptador gráfico tengan nada que ver. Los datos de la imagen se almacenan
en el lado de la aplicación, por lo que son accesibles a esta en todo momento.&lt;/p&gt;
&lt;p&gt;Normalmente la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; se utiliza para cargar una imagen desde un
archivo, opcionalmente manipular los píxeles y después convertirla a un
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; para mostrarla en la pantalla.&lt;/p&gt;
&lt;p&gt;En nuestro caso existen dos motivos fundamentales para utilizar &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;
en lugar de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Para convertir la imagen a un objeto &lt;code&gt;cv::Mat&lt;/code&gt; de &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; se necesita
acceso a los datos de los píxeles. Como hemos comentado, eso sólo es posible
con la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Generamente un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt; encapsula el acceso a algún tipo de
recurso del servidor gráfico, con el que la aplicación se comunica a través
del hilo GUI (el hilo principal de la aplicación). Puesto que en muchos
sistemas operativos no es seguro comunicarse con el servidor gráfico a través
de un hilo diferente a ese, cualquier manipulación de un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;
fuera del hilo principal puede dar lugar a efectos inesperados. Dado que
queremos transferir las imágenes a un hilo de trabajo para su procesamiento,
parece que lo más seguro es utilizar la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Detección de movimiento&lt;/h2&gt;
&lt;p&gt;Con acceso a las clases y funciones de &lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt; desde nuestra aplicación,
podemos pasar a resolver el problema que nos habíamos propuesto; detectar
movimiento en una secuencia de vídeo.&lt;/p&gt;
&lt;p&gt;Como ocurre con muchas otras tareas en el campo de la visión por computador,
esta se puede resolver de múltiples maneras. Además es muy común que en cada
técnica posible haya una decena de parámetros que den resultados diferentes
según como los ajustemos.&lt;/p&gt;
&lt;p&gt;Nosotros nos centraremos en solución concreta:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// std::vector&amp;lt;cv::Mat&amp;gt; images = &amp;lt;vector de imágenes en cv::Mat&amp;gt;&lt;/span&gt;

&lt;span class="c1"&gt;// Definimos algunos tipos para que el código se lea mejor&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ImagesType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Point&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;ContoursType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;// Instancia de la clase del sustractor de fondo&lt;/span&gt;
&lt;span class="c1"&gt;// cv::BackgroundSubtractorMOG2(history=500,&lt;/span&gt;
&lt;span class="c1"&gt;//                              varThreshold=16,&lt;/span&gt;
&lt;span class="c1"&gt;//                              bShadowDetection=true)&lt;/span&gt;
&lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;BackgroundSubtractorMOG2&lt;/span&gt; &lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;nmixtures&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Desactivar la detección de sombras&lt;/span&gt;
&lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bShadowDetection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ImagesTypes&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;const_iterator&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;begin&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;images&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Sustracción del fondo:&lt;/span&gt;
    &lt;span class="c1"&gt;//  1. El objeto sustractor compara la imagen en i con su&lt;/span&gt;
    &lt;span class="c1"&gt;//     estimación del fondo y devuelve en foregroundMask una&lt;/span&gt;
    &lt;span class="c1"&gt;//     máscara (imagen binaria) con un 1 en los píxeles de&lt;/span&gt;
    &lt;span class="c1"&gt;//     primer plano.&lt;/span&gt;
    &lt;span class="c1"&gt;//  2. El objeto sustractor actualiza su estimación del fondo&lt;/span&gt;
    &lt;span class="c1"&gt;//     usando la imagen en i.&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;backgroundSubtractor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Operaciones morfolóficas para eliminar las regiones de&lt;/span&gt;
    &lt;span class="c1"&gt;// pequeño tamaño. Erode() las encoge y dilate() las vuelve a&lt;/span&gt;
    &lt;span class="c1"&gt;// agrandar.&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;erode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;dilate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Mat&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;

    &lt;span class="c1"&gt;// Obtener los contornos que bordean las regiones externas&lt;/span&gt;
    &lt;span class="c1"&gt;// (CV_RETR_EXTERNAL) encontradas. Cada contorno es un vector&lt;/span&gt;
    &lt;span class="c1"&gt;// de puntos y se devuelve uno por región en la máscara.&lt;/span&gt;
    &lt;span class="n"&gt;ContoursType&lt;/span&gt; &lt;span class="n"&gt;contours&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;cv&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;findContours&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;foregroundMask&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;contours&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CV_RETR_EXTERNAL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                     &lt;span class="n"&gt;CV_CHAIN_APPROX_NONE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Aquí va el código ódigo que usa los contornos encontrados...&lt;/span&gt;
    &lt;span class="c1"&gt;// P. ej. usar cv::boundingRect() para obtener el cuadro&lt;/span&gt;
    &lt;span class="c1"&gt;// delimitador de cada uno y pintarlo en la imagen original&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Donde suponemos que previamente hemos convertido todas las imágenes de
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; a cv::Mat y las hemos almacenado en un vector.&lt;/p&gt;
&lt;p&gt;Al final de cada iteración del bucle tenemos para cada imagen un vector de
contornos, donde cada uno es un vector de puntos. Con los contornos se pueden
hacer múltiples operaciones. Por ejemplo calcular el rectángulo que contiene
a cada uno (&lt;em&gt;bounding box&lt;/em&gt;) con &lt;a href="http://opencv.willowgarage.com/documentation/cpp/structural_analysis_and_shape_descriptors.html#cv-boundingrect" title="cv::boundingRect"&gt;cv::boundingRect&lt;/a&gt;() para pintarlos sobre
la imagen antes de mostrársela al usuario.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://opencv.willowgarage.com/wiki/" title="OpenCV"&gt;OpenCV&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dbzhang800/QtOpenCV" title="QtOpenCV"&gt;QtOpenCV&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="visión"></category><category term="imágenes"></category><category term="opencv"></category><category term="qt. qimage"></category></entry></feed>