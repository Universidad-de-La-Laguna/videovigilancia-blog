<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sistema de Videovigilancia from Scratch</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/" rel="alternate"></link><link href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/Overviews.atom.xml" rel="self"></link><id>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/</id><updated>2013-05-12T00:00:00+01:00</updated><entry><title>Resource Interchange File Format</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/resource-interchange-file-format.html" rel="alternate"></link><updated>2013-05-12T00:00:00+01:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-05-12:resource-interchange-file-format.html</id><summary type="html">&lt;p&gt;El &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format"&gt;Resource Interchange File Format&lt;/a&gt; o &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format" title="Resource Interchange File Format"&gt;RIFF&lt;/a&gt; es un formato contenedor genérico diseñado para almacenar datos en forma
de fragmentos etiquetados o &lt;a href="http://en.wikipedia.org/wiki/Chunk_(information)" title="Chunk (information)"&gt;chunks&lt;/a&gt;. Siendo usado en la actualidad como formato
contenedor de los conocidos formatos de archivo AVI, ANI y WAV de Microsoft, es
indudable que resulta especialmente útil para almacenar contenidos multimedia,
aunque realmente puede almacenar cualquier tipo de información.&lt;/p&gt;
&lt;h1&gt;Tipos de fragmentos&lt;/h1&gt;
&lt;p&gt;Hay dos tipos de fragmentos en un archivo &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format" title="Resource Interchange File Format"&gt;RIFF&lt;/a&gt;. El más básico son los
&lt;a href="http://en.wikipedia.org/wiki/Chunk_(information)" title="Chunk (information)"&gt;chunks&lt;/a&gt; o fragmentos de datos propiamente dichos:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;Chunk&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;        &lt;span class="c1"&gt;// contiene datos en general&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;donde &lt;code&gt;type&lt;/code&gt; sirve para identificar el tipo y el formato de los datos que
almacena el fragmento y &lt;code&gt;size&lt;/code&gt; para especificar su tamaño —sin incluir ni el
tamaño del campo &lt;code&gt;type&lt;/code&gt; ni el de &lt;code&gt;size&lt;/code&gt;—.&lt;/p&gt;
&lt;p&gt;El otro tipo de fragmento son las listas:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;List&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint32_t&lt;/span&gt; &lt;span class="n"&gt;listType&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;uint8_t&lt;/span&gt;  &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;      &lt;span class="c1"&gt;// contiene otros Chunk o List&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;que son aquellos que contienen una colección de otros fragmentos o listas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Las listas se identifican y distinguen de otros fragmentos porque su campo
&lt;code&gt;type&lt;/code&gt; contiene o los 4 caracteres de &lt;code&gt;RIFF&lt;/code&gt; o de &lt;code&gt;LIST&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/li&gt;
&lt;li&gt;Para este tipo de fragmentos el tamaño en el campo &lt;code&gt;size&lt;/code&gt; incluye tanto el
 de los datos almacenados dentro del fragmento como el del campo &lt;code&gt;listType&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Dentro de la lista los fragmentos que contiene se disponen unos detrás de
otros, pero siempre asegurando que cada fragmento comienza en una dirección
par —es decir, que se alinean a 16 bits—.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El archivo contenedor en si mismo es una gran fragmento de lista tipo &lt;code&gt;RIFF&lt;/code&gt; que
contiene otros fragmentos. Estos pueden ser &lt;em&gt;chunks&lt;/em&gt; o listas de tipo &lt;code&gt;LIST&lt;/code&gt;.
Por lo tanto en una archivo RIFF sólo existe una lista de este tipo, que hace
las veces de contenedor de todos los fragmentos del archivo. El valor del campo
&lt;code&gt;listType&lt;/code&gt; del fragmento &lt;code&gt;RIFF&lt;/code&gt; es una secuencia de 4 bytes que identifica el
formato del archivo y se lo conoce como el &lt;a href="http://www.fourcc.org/codecs.php" title="FourCC"&gt;FourCC&lt;/a&gt; del mismo.&lt;/p&gt;
&lt;h1&gt;Estructura general&lt;/h1&gt;
&lt;p&gt;Para hacernos una idea del formato este sería el esquema de un archivo AVI
convencional:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;RIFF &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;AVI &amp;#39;&lt;/span&gt;
      LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;hdr1&amp;#39;&lt;/span&gt;
            AVIH &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;cabecera principal del AVI&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
            LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;str1&amp;#39;&lt;/span&gt;
                  STRH &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;cabecera del flujo&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
                  STRF &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;formato del flujo&amp;gt;&lt;span class="o"&gt;)&lt;/span&gt;
                  ...
                 &lt;span class="o"&gt;)&lt;/span&gt;
            ...
           &lt;span class="o"&gt;)&lt;/span&gt;
      LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;movi&amp;#39;&lt;/span&gt;
            &lt;span class="o"&gt;{&lt;/span&gt;Chunk | LIST &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;rec &amp;#39;&lt;/span&gt;
                           Chunk1
                           Chunk2
                           ...
                          &lt;span class="o"&gt;)&lt;/span&gt;
             ...
            &lt;span class="o"&gt;}&lt;/span&gt;
            ...
           &lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="o"&gt;[&lt;/span&gt;IDX1 &lt;span class="o"&gt;(&lt;/span&gt;&amp;lt;índice AVI&amp;gt;&lt;span class="o"&gt;)]&lt;/span&gt;
     &lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Donde los identificadores en mayúsculas denotan el valor del campo &lt;code&gt;type&lt;/code&gt; al
comienzo de un fragmento. Este siempre es seguido por el campo &lt;code&gt;size&lt;/code&gt;, que no se
muestra en el esquema anterior. Por otro lado el valor de los campos &lt;code&gt;listType&lt;/code&gt;
de los fragmentos de tipo lista se indica entre comillas simples.&lt;/p&gt;
&lt;p&gt;Para observar una estructura real de archivo RIFF se puede utilizar el
programa &lt;a href="http://manpages.ubuntu.com/manpages/lucid/man1/rifftree.1.html" title="Ubuntu Manpage: rifftree"&gt;rifftree&lt;/a&gt; del paquete &lt;code&gt;gigtools&lt;/code&gt; con cualquier archivo &lt;code&gt;.avi&lt;/code&gt; o
&lt;code&gt;.wav&lt;/code&gt; que tengamos a mano.&lt;/p&gt;
&lt;h1&gt;Rifftree&lt;/h1&gt;
&lt;p&gt;Para ilustrar lo comentado sobre los archivos RIFF, he publicado en GitHub &lt;a href="http://github.com/aplatanado/rifftree"&gt;mi
propia versión de rifftree&lt;/a&gt;. Está
desarrollada con &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; y hace uso del mapeo de archivos en memoria para
facilitar el acceso al archivo RIFF.&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Resource_Interchange_File_Format"&gt;Resource Interchange File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;MSDN - &lt;a href="http://msdn.microsoft.com/en-us/library/ms779636(VS.85).aspx"&gt;AVI RIFF File Reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.alexander-noe.com/video/documentation/avi.pdf"&gt;AVI File Format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.fourcc.org/codecs.php" title="FourCC"&gt;FourCC&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Si bien en el archivo se almacenan los caracteres &lt;code&gt;'R'&lt;/code&gt;, &lt;code&gt;'R'&lt;/code&gt;, &lt;code&gt;'I'&lt;/code&gt;, &lt;code&gt;'F'&lt;/code&gt;
en ese orden, hay que tener en cuenta que al interpretarlo como &lt;code&gt;uint32_t&lt;/code&gt; en
una máquina &lt;em&gt;little-endian&lt;/em&gt; no veremos el número 0x52494646 sino 0x46464952.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="RIFF"></category><category term="AVI"></category><category term="WAV"></category></entry><entry><title>Paralelismo y concurrencia</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/paralelismo-y-concurrencia.html" rel="alternate"></link><updated>2013-04-07T00:00:00+01:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-07:paralelismo-y-concurrencia.html</id><summary type="html">&lt;p&gt;El paralelismo no debe confundirse con la &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;concurrencia&lt;/a&gt;,
aunque es común que así ocurra. El paralelismo se preocupa de analizar como
superponer operaciones con el objeto de mejorar el rendimiento al realizar una
tarea concreta.&lt;/p&gt;
&lt;p&gt;Normalmente un programa lanza un conjunto de subtareas que se ejecutan en
paralelo para realizar un trabajo determinado, mientras la tarea principal no
continua hasta que todas las subtareas han terminado. El reto desde el punto
de vista del paralelismo es determinar las optimizaciones necesarias con
respecto a cuestiones tales como la granularidad y el coste de la comunicación.&lt;/p&gt;
&lt;p&gt;Sin embargo la concurrencia es necesaria para implementar el paralelismo.
Concretamente, en el ejemplo anterior, se hace cargo de establecer como se
definen las distintas tareas, que características tienen y como se implementan
sobre un hardware en concreto. También establece los mecanismos de
coordinación y sincronización necesarios para lidiar con la indeterminación, ya
que no sabemos cuando terminarán las tareas ni cuando accederán a las estructuras
de datos compartidas.&lt;/p&gt;
&lt;p&gt;En ese sentido podemos decir que el paralelismo es una abstracción útil para
mejorar el rendimiento de una tarea. Sin embargo no debe confundirse dicha
abstracción con su implementación, que entraría en el campo de la concurrencia.
Así un programa con dos hilos concurrentes que se ejecute en un sistema
monoprocesador sin múltiples núcleos ni físicos ni lógicos (&lt;a href="http://en.wikipedia.org/wiki/Simultaneous_multithreading" title="Simultaneous Multithreading"&gt;SMT&lt;/a&gt;) puede ser
concurrente pero no paralelo. Obviamente el paralelismo sólo es posible en
sistemas multinúcleo, multiprocesador o distribuidos.&lt;/p&gt;
&lt;p&gt;A continuación complementaremos lo hablado anteriormente sobre &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;concurrencia&lt;/a&gt;
considerando que ahora el contexto es el de programas donde pretendemos
descomponer y paralelizar tareas &lt;em&gt;limitadas por la CPU&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Multihilo&lt;/h2&gt;
&lt;p&gt;El uso de múltiples hilos dentro de un programa paralelo es un enfoque muy
común. Sin embargo, a diferencia de lo que ocurre &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;en los casos de los que
hemos hablado anteriormente&lt;/a&gt;, por lo
general se crean tantos hilos como núcleos diferentes dispone el sistema y
se divide entre ellos la tarea que deseamos realizar.&lt;/p&gt;
&lt;p&gt;Obviamente tiene poco sentido crear más hilos que secuencias de instrucciones
pueden ejecutarse paralelamente en el sistema.&lt;/p&gt;
&lt;h2&gt;Agrupamiento de hilos&lt;/h2&gt;
&lt;p&gt;Como acabamos de comentar, en un problema de &lt;strong&gt;programación paralela&lt;/strong&gt; el
número de hilos adecuado viene determinado por el de núcleos, lo que obliga a
dividir el problema de manera diferente según las características del hardware
donde el programa se va a ejecutar. Esto no es sencillo si la aplicación va a
ser distribuida al público y por lo tanto será utilizada en ordenadores con
características diversas.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://commons.wikimedia.org/wiki/File:Thread_pool.svg"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/500px-Thread_pool.svg.png" alt="Sencillo esquema de un agrupamiento de hilos" class="right-float"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;El patrón &lt;em&gt;agrupamiento de hilos&lt;/em&gt; comentado en el artículo sobre &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html"&gt;concurrencia&lt;/a&gt;
nos puede ayudar a enfrentar este problema. Básicamente nos permite dividir
las tareas &lt;em&gt;limitadas por la CPU&lt;/em&gt; tanto como queramos. Y que estas sean
ejecutadas sobre un agrupamiento configurado con el mismo número de hilos que
núcleos de procesador hay en el sistema donde se está ejecutando la aplicación.&lt;/p&gt;
&lt;p&gt;De esta manera los programas se pueden adaptar al paralelismo del hardware
subyacente, aprovechando de forma sencilla las ventajas de los sistemas
multinúcleo.&lt;/p&gt;
&lt;p&gt;Como ya hemos comentado, las plataformas Java y .NET incorporan una
implementación de este patrón. Mientras que para C/C++ existen diversas librerías,
entre las que no sólo está &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; y su clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthreadpool.html" title="QThreadPool"&gt;QThreadPool&lt;/a&gt;, si no que fundamentalmente
tenemos que destacar la &lt;a href="http://es.wikipedia.org/wiki/Intel_Threading_Building_Blocks" title="Intel Threading Building Blocks"&gt;Threading Building Blocks&lt;/a&gt; de Intel (TBB).&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.golang.org/2013/01/concurrency-is-not-parallelism.html"&gt;Concurrence is no parallelism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Concurrency_pattern"&gt;Concurrency pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Thread_pool_pattern"&gt;Thread pool pattern&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="concurrencia"></category><category term="paralelismo"></category><category term="hilos"></category><category term="multihilo"></category><category term="qthreadpool"></category></entry><entry><title>Concurrencia</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/concurrencia.html" rel="alternate"></link><updated>2013-04-06T00:00:00+01:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-06:concurrencia.html</id><summary type="html">&lt;p&gt;La concurrencia tiene que ver con manejar múltiples eventos que se superponen
en el tiempo fuera del control del programa. Por lo tanto debe preocuparse de
manejar la creciente complejidad que surge de la necesidad de un control de
flujo no determinista. Los programas concurrentes vienen con frecuencia
&lt;em&gt;limitados por la E/S&lt;/em&gt;, como por ejemplo es el caso de las arañas usadas por
los buscadores de Internet para explorar la web. Estos programas inician
varias peticiones HTTP para obtener diversas páginas y aceptan de forma
concurrente las respuestas con su contenido, acumulándolas en el conjunto de
páginas visitadas. El control del flujo es no determinista porque las respuestas
no se reciben necesariamente en el mismo orden en el que el programa hizo las
correspondientes peticiones.&lt;/p&gt;
&lt;p&gt;En general existen aplicaciones que son fundamentalmente concurrentes, como
los servidores web, los de archivos, los de base de datos y otros programas
similares que deben manejar al mismo tiempo la conexión con diversos clientes.
También son concurrentes las &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/paralelismo-y-concurrencia.html"&gt;aplicaciones paralelas&lt;/a&gt;,
donde una tarea se descompone en otras más pequeñas que se ejecutan al mismo
tiempo para obtener el máximo rendimiento, porque en muchas ocasiones no se sabe
de antemano cuando van a terminar estas subtareas o van a intentar acceder a las
estructuras de datos compartidas. Así mismo son concurrentes las aplicaciones
para las GUI modernas, ya que peticiones tales como atender un click de ratón o
actualizar el contenido de una ventana pueden llegar en cualquier momento fuera
del control del programa.&lt;/p&gt;
&lt;p&gt;Por su naturaleza no determinista, los programas concurrentes son difíciles de
depurar. &lt;/p&gt;
&lt;h2&gt;Manejar la concurrencia&lt;/h2&gt;
&lt;p&gt;Hasta el momento hemos dejado entrever las dos motivos más comunes por los que
necesitamos gestionar la concurrencia:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Si nuestro programa deben manejar eventos externos que escapan a su control,
como es el caso de un servidor que deben aceptar peticiones de múltiples
clientes o una aplicación interactiva que debe responder ante los eventos
notificados por el sistema a causa de las acciones del usuario, necesitamos
manejar la concurrencia.&lt;/p&gt;
&lt;p&gt;Las tareas de estos programas con frecuencia están &lt;em&gt;limitadas por la E/S&lt;/em&gt;,
aunque no siempre es así. Por ejemplo, los recolectores de basura concurrentes
presentes en algunas plataformas (p. ej. Java y .NET) están enteramente
&lt;em&gt;limitados por la CPU&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Obviamente todo sería mucho más sencillo si optáramos por ignorar la
concurrencia, manejando en turno una solicitud cada vez. Pero entonces una
petición o un evento bloquearía a los otros hasta que hubiera terminado.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Si en nuestro programa queremos usar &lt;strong&gt;programación paralela&lt;/strong&gt; para descomponer
ciertas tareas en otras más pequeñas que se puedan ejecutar al mismo tiempo con
el objeto de obtener el máximo rendimiento, también es necesario gestionar la
concurrencia. Sin embargo, por lo general, este tipo de tareas están
&lt;em&gt;limitadas por la CPU&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;En la actualidad existen diferentes maneras de tratar la concurrencia, que
pueden ser más o menos convenientes según el tipo de problemas a resolver.
Nosotros nos centraremos por el momento en el primer tipo, dejando los detalles
relacionados con la &lt;strong&gt;programación paralela&lt;/strong&gt; para un
&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/paralelismo-y-concurrencia.html"&gt;artículo posterior&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Multihilo&lt;/h2&gt;
&lt;p&gt;El uso de múltiples hilos dentro de un mismo programa es uno de los enfoques
más comunes cuando se plantea resolver un problema de concurrencia. En las
mayor parte de los sistemas modernos los hilos creados por la aplicación son
conocidos y gestionados por el núcleo (&lt;a href="http://en.wikipedia.org/wiki/Thread_(computing)#1:1_.28Kernel-
level_threading.29"&gt;modelo uno a
uno&lt;/a&gt;), lo que les permite acceder simultáneamente al mismo y
ser planificados en diferentes procesadores, pudiendo así aprovechar el
paralelismo ofrecido por el hardware en los sistemas multiprocesador y/o
multinúcleo.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1oViFjM7lI5jCoWx4uM9xD_8DRz9d2mOETWQuzjf3AU4/pub?w=606&amp;amp;h=534" alt="Modelo de hilo 1:1" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;Obviamente la manera en la que se utilizan los hilos dependen del tipo de problema.
Si lo que se pretende es gestionar eventos o peticiones externas, lo más habitual
es crear un hilo por cliente conectado. Así cada hilo funcionará de manera
independiente procesando y atendiendo las peticiones de su cliente.&lt;/p&gt;
&lt;h3&gt;Características&lt;/h3&gt;
&lt;p&gt;Las principales características de la programación multihilo son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Es muy sencilla, ya que permite gestionar diferentes hilos de ejecución
dentro del espacio de direcciones virtual de un mismo proceso, lo que facilita
la compartición de datos y otros recursos comunes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Se puede volver muy compleja, debido al cuidadoso control que es necesario
hacer sobre el acceso a los recursos compartidos, a poco que el problema crezca.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Modelos basados en paso de mensajes&lt;/h3&gt;
&lt;p&gt;Debido a que muchos de los problemas de la programación multihilo provienen de
la compartición de recursos, se ha extendido el uso de modelos basados en paso
de mensajes para resolver problemas concurrentes complejos.&lt;/p&gt;
&lt;p&gt;En estos modelos los hilos no acceden directamente a los datos sino que se los
transfieren entre si por medio de mensajes. Así se evita compartir recursos y,
por tanto, el uso de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;cerrojos, semáforos y variables de condición&lt;/a&gt;.
Lamentablemente así se pierde sencillez.&lt;/p&gt;
&lt;p&gt;Para estos lenguajes como Scala o Erlang implementan el modelo &lt;a href="http://en.wikipedia.org/wiki/Actor_model" title="Actor model"&gt;Actor&lt;/a&gt;, mientras
que Go se basa en en el modelo &lt;a href="http://en.wikipedia.org/wiki/Communicating_sequential_processes" title="Communicating sequential processes"&gt;CSP&lt;/a&gt;. Ambos casos, pese a &lt;a href="http://www.informit.com/articles/article.aspx?p=1768317"&gt;sus diferencias&lt;/a&gt;,
fundamentalmente operan tal y como hemos descrito. También entraría dentro de
este tipo de modelos el &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html"&gt;mecanismo de comunicación entre hilos&lt;/a&gt; que implementa &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; a través del uso de señales y &lt;em&gt;slots&lt;/em&gt;.&lt;/p&gt;
&lt;h2&gt;Multiproceso&lt;/h2&gt;
&lt;p&gt;En los sistemas operativos que implementan una llamada al sistema tipo
&lt;a href=""&gt;fork&lt;/a&gt; se pueden crear de forma sencilla múltiples procesos, en lugar de
hilos, para manejar la concurrencia. La forma de hacerlo no difiere mucho de
la programación multihilo, aunque es necesario tener en cuenta los siguientes
aspectos:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Escala peor, ya que soportar cientos de clientes implica la creación de
cientos de procesos y estos son más costosos que los hilos, en lo que respecta
al consumo de recursos del sistema.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;No es tan sencilla como la programación multihilo, porque hay que
indicar explícitamente que regiones de la memoria se desea compartir entre
procesos. Además, normalmente sólo se puede establecer que recursos van a
ser compartidos durante la creación de cada proceso, no pudiendo compartir
otros recursos posteriormente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Los procesos ofrecen mejor aislamiento que los hilos y por tanto mayor
robustez y seguridad.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Respecto a esto último debemos de tener en cuenta que un acceso indebido a la
memoria en uno de los procesos, quizás ocasionada por una petición de un
cliente mal formateada, no tiene por qué provocar la caída de toda la aplicación;
a diferencia de lo que pasaría en una aplicación multihilo. De igual manera,
si un atacante tomara el control de uno de los procesos tendría más difícil tener
acceso a los otros. Además, los procesos tienen características interesantes de
las que carecen los hilos, como la posibilidad de ejecutarse como un usuario
concreto del sistema o en un jaula &lt;a href="http://es.wikipedia.org/wiki/Chroot" title="chroot"&gt;chroot&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Agrupamiento de hilos&lt;/h2&gt;
&lt;p&gt;Aunque más baratos que los procesos, los hilos tienen un coste que llegado el
momento puede hacer que nuestra aplicación no pueda escalar ya que no se puedan
crear más hilos.&lt;/p&gt;
&lt;p&gt;Para evitarlo se puede hacer uso del patrón &lt;a href="http://en.wikipedia.org/wiki/Thread_pool_pattern"&gt;agrupamiento de hilos&lt;/a&gt;
(o &lt;em&gt;thread pool&lt;/em&gt;) que básicamente consiste en:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crear un grupo de hilos, una cola con las tareas que deben ser ejecutadas en
dichos hilos y otra cola donde almacenar los resultados de las tareas ejecutadas.
&lt;a href="http://commons.wikimedia.org/wiki/File:Thread_pool.svg"&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/0/0c/Thread_pool.svg/500px-Thread_pool.svg.png" alt="Sencillo esquema de un agrupamiento de hilos" class="right-float"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cada vez que un hilo del agrupamiento queda libre, toma la siguiente tarea
de la cola y la ejecuta hasta que es completada, insertando los resultados en
la cola correspondiente.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cuando la cola de tareas está vacía, los hilos pueden morir o dormir hasta
que hayan más tareas.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Número de hilos&lt;/h3&gt;
&lt;p&gt;Obviamente el número concreto de hilos del agrupamiento se debe ajustar con
el objeto de conseguir el mayor rendimiento posible. Con tareas &lt;em&gt;limitadas por
la E/S&lt;/em&gt; el número generalmente depende de la capacidad del sistema y del tipo de
tarea, por lo que suele ser necesario determinarlo experimentalmente.&lt;/p&gt;
&lt;p&gt;Además, en ocasiones el número de hilos en el agrupamiento puede ser ajustado
por el programa dinámicamente, en base al número de tareas pendientes de ser
ejecutadas. Así la aplicación podría incorporar hilos al agrupamiento sólo si la
cantidad de tareas a la espera supera cierto umbral, y únicamente hasta el
máximo por encima del cual hemos determinado que el rendimiento se vería penalizado.&lt;/p&gt;
&lt;h3&gt;Soporte&lt;/h3&gt;
&lt;p&gt;Debido a la proliferación de los procesadores multinúcleo, es cada vez más
común que los diferentes lenguajes dispongan de alguna implementación del
patrón &lt;em&gt;agrupamiento de hilos&lt;/em&gt;, ya sea en la librería que lo acompaña o a
través de librerías de terceros, con el fin de facilitar la programación
paralela.&lt;/p&gt;
&lt;p&gt;Plataformas como Java y .NET lo incorporan, así como el sistema operativo Mac
OS X bajo el nombre de &lt;a href="http://en.wikipedia.org/wiki/Grand_Central_Dispatch"&gt;Grand Central Dispatch&lt;/a&gt; (GCD).
En el caso de C++ existen múltiples librerías, como por ejemplo Intel &lt;a href="http://es.wikipedia.org/wiki/Intel_Threading_Building_Blocks" title="Intel Threading Building Blocks"&gt;TBB&lt;/a&gt;, diseñada
específicamente para facilitar que los programas aprovechen las ventajas de
los sistemas multinúcleo, o &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, que incorpora su propia implementación del
patrón a través de la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthreadpool.html" title="QThreadPool"&gt;QThreadPool&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;HelloWorldTask&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QRunnable&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
     &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Hello world from thread&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="n"&gt;HelloWorldTask&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HelloWorldTask&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
 &lt;span class="c1"&gt;// QThreadPool takes ownership and deletes &amp;#39;hello&amp;#39; automatically&lt;/span&gt;
 &lt;span class="n"&gt;QThreadPool&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;globalInstance&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hello&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Ejecución basada en eventos&lt;/h2&gt;
&lt;p&gt;Como ya hemos comentado, los hilos tienen un coste que no se puede despreciar
cuando el número que necesitamos es alto. Además, en muchos problemas de
concurrencia las tareas están muy &lt;em&gt;limitadas por la E/S&lt;/em&gt;, por lo que a penas se
obtiene beneficio alguno de la posibilidad de ejecutarlas en paralelo. En esos
casos la forma de gestionar la concurrencia que se ha demostrado más eficaz es
la ejecución basada en eventos.&lt;/p&gt;
&lt;p&gt;Simplificando, sus principales características son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Generalmente sólo se usa un hilo de ejecución. Por tanto no es posible la
ejecución paralela de código, lo que implica que si se ejecutan tareas &lt;em&gt;limitadas
por la CPU&lt;/em&gt; se podría estar bloqueando las peticiones de otros clientes al
ocupar el hilo de ejecución.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Toda la E/S es asíncrona, para evitar el bloqueo de las peticiones de los
clientes y que las operaciones de E/S se ejecuten en paralelo, tanto entre sí
como respecto al código en el hilo de ejecución.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Hace uso de un bucle de mensajes a donde llegan los eventos de E/S
notificados por el sistema operativo. Desde este bucle se llama a las rutinas
de &lt;em&gt;callback&lt;/em&gt; correspondientes, donde la aplicación tiene el código que da
respuesta a dichos eventos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1vr_1x_UQAW905hjxALQE0hGB6ii55dIiKOsqFD9lw_M/pub?w=809&amp;amp;h=367" alt="Ejecución basada en eventos" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;Estas rutinas de &lt;em&gt;callback&lt;/em&gt; pueden tener nombres predefinidos, como es el caso
del sistema de señales de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, o especificarse a través de un argumento
adicional indicado cuando se solicitó la E/S.&lt;/p&gt;
&lt;p&gt;Por lo general los programas que gestionan la concurrencia de esta manera
tiene muchos menos requerimientos de memoria que los que usan múltiples hilos
o procesos, lo que les permite escalar mejor. Este es por ejemplo el caso del
servidor web Nginx o el servidor de aplicaciones en Javascript Node.js cuando
se los compara con Apache, un servidor web que según la configuración utiliza
un hilo o un proceso por conexión.&lt;/p&gt;
&lt;h2&gt;Corrutinas&lt;/h2&gt;
&lt;p&gt;Aunque eficiente, la ejecución basada en eventos puede ser más compleja de
implementar ya que el control del flujo de ejecución se invierte. Es decir, en
un patrón procedural normal la interacción se expresa de forma imperativa,
haciendo llamadas a procedimientos, funciones o métodos. En su lugar, en la
ejecución basada en eventos se especifican las respuestas deseadas a los
eventos notificados, siendo imposible desarrollar una función que contenga
todo el código implicado en una tarea concreta.&lt;/p&gt;
&lt;p&gt;Esto se puede resolver incorporando el uso de &lt;a href="http://en.wikipedia.org/wiki/Coroutine"&gt;corrutinas&lt;/a&gt;.
Estas son una generalización de los procedimientos o subrutinas convencionales
de las que se puede salir por diversos puntos para posteriormente volver y
reiniciar la ejecución desde el último punto de retorno.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1CiGFeo02uYTWL3Y31u-RpIKBjlLUDrIEaXj8e1_geLw/pub?w=851&amp;amp;h=330" alt="Ejemplo de corrutina" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;En el contexto de la ejecución basada en eventos, las distintas tareas que deben
ser ejecutadas pueden programarse como corrutinas, mientras que las operaciones
de E/S, a parte de solicitar la operación correspondiente de manera asíncrona,
forzarían la salida de la corrutina. Así el bucle de mensajes, en lugar de
invocar el &lt;em&gt;callback&lt;/em&gt; de una operación completada, sólo tiene que restablecer
la ejecución de la corrutina allí donde fue interrumpida.&lt;/p&gt;
&lt;p&gt;Los corrutinas son soportadas por algunos lenguajes de alto nivel como Ruby,
Lua o Go. Este último incluso permite planificar su ejecución en paralelo
dentro de un agrupamiento de hilos, dando lugar a lo que sus desarrolladores
ha denominado &lt;em&gt;goroutines&lt;/em&gt;. Otro ejemplo destacable es Python, que si bien no
las soporta en el intérprete estándar, si lo hacen a través de &lt;a href="http://en.wikipedia.org/wiki/Stackless_Python" title="Stackless Python"&gt;Stackless
Python&lt;/a&gt;. Este intérprete es usado en productos como Eve Online o Second Live,
donde el número de conexiones simultáneas es muy alto. Por lo demás la mayor
parte de los lenguajes más populares no lo soportan, ni en el propio lenguaje
ni a través de su librería estándar, con la excepción de C++ a través de la
librería &lt;a href="http://www.boost.org/doc/libs/1_53_0/libs/coroutine/doc/html/index.html" title="Boost.Coroutine"&gt;Boost.Coroutine&lt;/a&gt;.&lt;/p&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Concurrency_pattern"&gt;Concurrency pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.oracle.com/technetwork/java/javase/gc-tuning-6-140523.html#cms"&gt;Java SE 6 - The Concurrent Collector&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.informit.com/articles/article.aspx?p=1768317"&gt;A Tale of Two Concurrency Models: Comparing the Go and Erlang Programming Languages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Thread_pool_pattern"&gt;Thread pool pattern&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.mixu.net/2011/02/01/understanding-the-node-js-event-loop/"&gt;Understanding the node.js event loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Coroutine"&gt;Coroutine&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="concurrencia"></category><category term="hilos"></category><category term="bucle de mensajes"></category><category term="multiproceso"></category><category term="multihilo"></category><category term="callbacks"></category><category term="qthreadpool"></category></entry><entry><title>BSD sockets</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html" rel="alternate"></link><updated>2013-03-02T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-02:bsd-sockets.html</id><summary type="html">&lt;p&gt;&lt;em&gt;POSIX sockets&lt;/em&gt; es una parte de la especificación POSIX&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; que define un API
(Application Programming Interface) para la comunicación entre procesos,
fundamentalmente entre equipos conectados a través de Internet
(&lt;em&gt;socket&lt;/em&gt; de Internet), aunque también soporta la conexión local entre procesos
que se ejecutan en el mismo sistema (&lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;socket de dominio UNIX&lt;/a&gt;
o &lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;socket UNIX&lt;/a&gt;).&lt;/p&gt;
&lt;h2&gt;Historia&lt;/h2&gt;
&lt;p&gt;La primera implementación ampliamente distribuida de la pila de protocolos
TCP/IP lo fue con el UNIX 4.2BSD, que incluía &lt;em&gt;BSD sockets&lt;/em&gt; (o &lt;em&gt;Berkeley sockets&lt;/em&gt;)
como API para las comunicaciones entre procesos usando estos protocolos.&lt;/p&gt;
&lt;p&gt;Las distintas versiones de BSD incorporaban código del UNIX original de AT&amp;amp;T,
por lo que estaban sujetas a la licencia de software de esta empresa. La
licencias de código fuente se estaban volviendo muy costosas, por lo que muchas
empresas y organizaciones comenzaron a interesarse en la liberación independiente
del código de red, que había sido desarrollado enteramente al margen de AT&amp;amp;T,
por lo que no tenía que estar sujeto a los requerimientos de su licencia.&lt;/p&gt;
&lt;p&gt;En junio de 1989 este código fue liberado bajo los términos de la licencia
&lt;a href="http://es.wikipedia.org/wiki/Licencia_BSD"&gt;BSD&lt;/a&gt;. Muchos fabricantes incluyeron
este código directamente en sus propios sistemas, incluso aunque tuvieran sus
propios protocolos propietarios con los que competían entre ellos. Y algunas
compañías comenzaron a usarlo para vender pilas de protocolo TCP/IP para
Windows, hasta que Microsoft incluyó la suya propia en Windows 95, también
derivada del código de BSD.&lt;/p&gt;
&lt;p&gt;Todo esto alimentó el despegue de TCP/IP como protocolo dominante e impuso
los &lt;em&gt;BSD sockets&lt;/em&gt; como API de acceso a la red, de tal forma que hoy en día
todos los sistemas operativos modernos tienen una implementación de &lt;em&gt;BSD
sockets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;El API &lt;em&gt;BSD sockets&lt;/em&gt; evolucionó y finalmente fue adoptado en el estándar
POSIX&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, donde algunas funciones fueron deprecadas y eliminadas y
reemplazadas por otras. Aun así el API &lt;em&gt;POSIX sockets&lt;/em&gt; es básicamente el
&lt;em&gt;BSD sockets&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;De la misma manera los sistemas Windows incluyen &lt;a href="http://msdn.microsoft.com/es-es/library/windows/desktop/ms740673(v=vs.85).aspx" title="Windows Sockets API"&gt;Winsock&lt;/a&gt;, un API de acceso a
la red derivado de &lt;em&gt;BSD sockets&lt;/em&gt; que sólo difiere de éste en unos
&lt;a href="http://tangentsoft.net/wskfaq/articles/bsd-compatibility.html"&gt;pocos detalles&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Funciones del API&lt;/h2&gt;
&lt;p&gt;Este es un resumen de las funciones proporcionadas por &lt;em&gt;POSIX sockets&lt;/em&gt;:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;socket()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Crea un nuevo &lt;em&gt;socket&lt;/em&gt;, identificado por un número entero, de cierto tipo y
reserva recursos del sistema para él.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;bind()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa generalmente en el lado del servidor para asociar un &lt;em&gt;socket&lt;/em&gt; con una
dirección de red, por ejemplo una dirección IP y un puerto concretos.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;listen()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa en el lado del servidor para hacer que un &lt;em&gt;socket&lt;/em&gt; TCP entre en modo
de escucha a la espera de nuevas conexiones entrantes.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;connect()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa en el lado del cliente para asignar un número de puerto libre al
&lt;em&gt;socket&lt;/em&gt;. En el caso de &lt;em&gt;sockets&lt;/em&gt; TCP, intenta establecer una nueva conexión TCP
con un &lt;em&gt;socket&lt;/em&gt; a la escucha en otro puerto y dirección IP.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;accept()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa en el lado del servidor para aceptar una conexión entrante e intentar
crear una nueva conexión TCP con el cliente remoto. Si tiene éxito, crea un
nuevo socket asociado con esta pareja concreta de direcciones en ambos
extremos de la conexión.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;send()&lt;/code&gt; y &lt;code&gt;recv()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt; y &lt;code&gt;read()&lt;/code&gt; o &lt;code&gt;sendto()&lt;/code&gt; y &lt;code&gt;recvfrom()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usan para enviar y recibir datos hacia y desde el otro extremo de la conexión.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;close()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Hace que el sistema libere los recursos asignados al &lt;em&gt;socket&lt;/em&gt;. En el caso
de conexiones TCP, ésta es finalizada.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;getaddrinfo()&lt;/code&gt; y &lt;code&gt;getnameinfo()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usan para resolver nombres de máquina y direcciones IP (&lt;a href="http://es.wikipedia.org/wiki/Domain_Name_System" title="DNS - Domain Name System"&gt;DNS&lt;/a&gt;).&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;select()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para esperar a que uno o más &lt;em&gt;sockets&lt;/em&gt; de una lista estén listos
para leer, escribir o tengan algún error.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;poll()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para comprobar el estado de un &lt;em&gt;socket&lt;/em&gt; en un conjunto de &lt;em&gt;sockets&lt;/em&gt;.
Puede comprobar si están listos para escribir, leer o si ha ocurrido algún error.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;getsockopt()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para recuperar el valor actual de una opción concreta de configuración
del &lt;em&gt;socket&lt;/em&gt; especificado.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;setsockopt()&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se usa para cambiar el actual de una opción concreta de configuración del
&lt;em&gt;socket&lt;/em&gt; especificado.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;POSIX API en Boost.Asio&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; es una librería de C++ para programadores de software de sistema
donde el acceso a funcionalidades del sistema operativo; como la red, los archivos,
un puerto serie, etc.; se requiere con cierta frecuencia. El acceso a estos recursos
suele implicar operaciones de E/S que normalmente consumen mucho tiempo antes
de completarse, por lo que &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; provee de herramientas para gestionar
estas conexiones de manera asíncrona, sin necesitar modelos de concurrencia
basados en hilos o en múltiples procesos y memoria compartida.&lt;/p&gt;
&lt;p&gt;Debido a que uno de los usos principales de esta librería son las comunicaciones
por red, &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; incluye una interfaz multiplataforma de &lt;em&gt;sockets&lt;/em&gt; de bajo nivel,
basada en el API &lt;em&gt;BSD sockets&lt;/em&gt;, e implementada sobre la que proporciona el propio
sistema operativo.&lt;/p&gt;
&lt;p&gt;A diferencia de esta última, la implementación proporcionada por &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; no incluye
algunos aspectos del API original que no son seguros o que son propensos a provocar
errores de programación. Por ejemplo, el uso de &lt;code&gt;int&lt;/code&gt; para identificar a los &lt;em&gt;sockets&lt;/em&gt;
por parte del API &lt;em&gt;BSD sockets&lt;/em&gt; carece de la seguridad que nos ofrecería tener un
tipo específico para ellos. Por eso la representación de un &lt;em&gt;socket&lt;/em&gt; en &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; usa
un tipo distinto para cada protocolo. Es decir, para TCP el tipo de un socket es
&lt;code&gt;ip::tcp::socket&lt;/code&gt; mientras para UDP el tipo es &lt;code&gt;ip::udp::socket&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;En la documentación de &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt; se incluye una &lt;a href="http://www.boost.org/doc/html/boost_asio/overview/networking/bsd_sockets.html"&gt;tabla&lt;/a&gt;
que muestra la relación entre el API &lt;em&gt;BSD socket&lt;/em&gt; y el API de acceso a red de &lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt;:&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Berkeley_sockets"&gt;Berkeley sockets&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://msdn.microsoft.com/es-es/library/windows/desktop/ms740673(v=vs.85).aspx"&gt;Wnsock - Windows Sockets API&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://tangentsoft.net/wskfaq/articles/bsd-compatibility.html"&gt;Winsock Programmer's FAQ - BSD Sockets Compatibility&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.boost.org/libs/asio/" title="Boost.Asio"&gt;Boost.Asio&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;POSIX son las siglas de Portable Operating System Interface, una familia
de estándares especificados por el &lt;a href="http://www.ieee.org/"&gt;IEEE&lt;/a&gt; para mantener
la compatibilidad entre sistemas operativos. POSIX define un API, tomando del
de los sistemas UNIX, para asegurar la compatibilidad entre las distintas
variantes de UNIX y otros sistemas operativos.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="sockets"></category><category term="POSIX"></category><category term="comunicaciones"></category></entry><entry><title>Protocol Buffers</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/protocol-buffers.html" rel="alternate"></link><updated>2013-03-02T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-02:protocol-buffers.html</id><summary type="html">&lt;p&gt;&lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; es una herramienta para la serialización&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; de estructuras de
datos.&lt;/p&gt;
&lt;p&gt;Básicamente provee una manera sencilla de definir la estructura de los datos,
pudieron entonces generar código capaz de leer y escribir dichos datos de
manera eficiente, desde diferentes lenguajes y en una variedad de distintos
tipos de flujos de datos.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; fue desarrollado internamente por Google para almacenar
e intercambiar todo tipo de información estructurada. Hasta el punto de que
sirve de base para un sistema de &lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call"&gt;llamada a procedimiento remoto&lt;/a&gt;
o &lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call" title="Llamada a Procedimiento Remoto"&gt;RPC&lt;/a&gt; (Remote Procedure Call) propio que es usado prácticamente para
todas las comunicaciones entre equipos en Google.&lt;/p&gt;
&lt;p&gt;En su momento Google hizo generadores de código de &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; para
C++, Java y Python y liberó la herramienta con una licencia
&lt;a href="http://es.wikipedia.org/wiki/Licencia_BSD"&gt;BSD&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La idea detrás de &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; es muy similar a la que dio origen a
&lt;a href="http://en.wikipedia.org/wiki/XML" title="XML"&gt;XML&lt;/a&gt;, solo que en este caso el formato es binario, compacto y pone énfasis
en la velocidad a la hora de serializar&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; y deserializar los datos. Además
es muy similar a &lt;a href="http://en.wikipedia.org/wiki/Apache_Thrift" title="Apache Thrift"&gt;Apache Thrift&lt;/a&gt; (creado y usado internamente por Facebook)
o &lt;a href="http://en.wikipedia.org/wiki/Apache_Avro" title="Apache Avro"&gt;Apache Avro&lt;/a&gt;, excepto porque &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; no define un protocolo
&lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call" title="Llamada a Procedimiento Remoto"&gt;RPC&lt;/a&gt; concreto, sino sólo como deben empaquetarse los datos.&lt;/p&gt;
&lt;p&gt;Si se quiere definir un servicio &lt;a href="http://es.wikipedia.org/wiki/Remote_Procedure_Call" title="Llamada a Procedimiento Remoto"&gt;RPC&lt;/a&gt; que haga uso de un protocolo que se
apoye sobre &lt;a href="http://code.google.com/p/protobuf/" title="Protocol buffers - Google's data interchange format"&gt;Protocol Buffers&lt;/a&gt; para el intercambio de datos, existen
&lt;a href="http://code.google.com/p/protobuf/wiki/ThirdPartyAddOns#RPC_Implementations"&gt;diversas implementaciones RPC&lt;/a&gt;
para distintos lenguajes de programación.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://code.google.com/p/protobuf/"&gt;protobuf - Protocol Buffers - Google's data interchange format&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://developers.google.com/protocol-buffers/"&gt;Protocol Buffers - Google Developers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Protocol_Buffers"&gt;Protocol Buffers&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;La serialización es un proceso de codificación de un objeto en un medio
de almacenamiento (como puede ser una archivo o un buffer en memoria), en
ocasiones para transmitirlo a través de una conexión de red o para preservarlo
entre ejecuciones de un programa. La serie de bytes que codifican el estado
del objeto tras la serialización puede ser usada para crear un nuevo objeto,
idéntico al original, tras aplicar el proceso inverso de deserialización.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="protobuf"></category><category term="serialización"></category></entry><entry><title>Proyecto Qt. Framework de desarrollo de aplicaciones</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" rel="alternate"></link><updated>2013-01-29T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-29:proyecto-qt-framework-de-desarrollo-de-aplicaciones.html</id><summary type="html">&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; es una &lt;em&gt;framework&lt;/em&gt; multiplataforma en C++ de desarrollo de aplicaciones. Se
utiliza fundamentalmente para desarrollar aplicaciones con interfaz gráfica,
gracias al conjunto de controles independientes de la plataforma que ofrece,
aunque también es usado para crear herramientas de linea de comando o consolas
de gestión para servicios.&lt;/p&gt;
&lt;p&gt;Esto último es debido a que el API de la librería cuenta con clases para:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acceso a bases de datos mediante SQL.&lt;/li&gt;
&lt;li&gt;Procesamiento de XML.&lt;/li&gt;
&lt;li&gt;Gestión de hilos.&lt;/li&gt;
&lt;li&gt;Comunicaciones por red.&lt;/li&gt;
&lt;li&gt;Manejo de archivos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a parte de las clases ya mencionadas para el desarrollo de aplicaciones con
interfaz gráfica. Todo esto convierte a &lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; en un &lt;em&gt;framework&lt;/em&gt; muy valorado a la
hora de desarrollar aplicaciones multiplataforma en C++.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; está disponible para sistemas tipo UNIX (Linux, BSD, UNIX, etc.) con
servidor gráfico X Window System, Apple Mac OS X, Microsoft Windows y sistemas
Linux embebidos. Además se puede hacer uso de la librería desde lenguajes
diferentes a C++ gracias al empleo de &lt;a href="http://es.wikipedia.org/wiki/Bindings"&gt;bindings&lt;/a&gt;:
Python, Java, Ruby, Ada, Pascal, Perl, PHP, Haskell, Lua, D, .NET, etc.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; está disponible bajo licencias GPLv3, LGPLv2 y privativa comercial.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/"&gt;Qt Proyect&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Qt_(framework)"&gt;Wikipedia&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="qt"></category><category term="gui"></category></entry><entry><title>Yocto, Poky y BitBake</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" rel="alternate"></link><updated>2013-01-10T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-10:yocto-poky-y-bitbake.html</id><summary type="html">&lt;p&gt;El proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; proporciona a los desarrolladores de sistemas empotrados
Linux un punto de partida para generar distribuciones personalizadas para
sus productos. Una de las piezas clave del proyecto es el sistema de
construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, que a su vez se apoya en &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt;, una herramienta de
construcción de paquetes al estilo de
&lt;a href="http://es.wikipedia.org/wiki/Portage_(software)"&gt;Portage&lt;/a&gt; de
&lt;a href="http://www.gentoo.org/"&gt;Gentoo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;El proyecto Yocto&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; está financiado por la &lt;a href="http://www.linuxfoundation.org/"&gt;Linux Foundation&lt;/a&gt;.
Su principal objetivo es desarrollar herramientas que ayuden a los desarrolladores
a crear sus propias distribuciones de Linux, sea cual sea el hardware sobre el que
van a correr. Entre los proyectos desarrollados en el seno de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; están:
el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, el sistema de
&lt;a href="http://es.wikipedia.org/wiki/Integraci%C3%B3n_continua"&gt;integración continua&lt;/a&gt;
&lt;a href="http://autobuilder.yoctoproject.org/"&gt;Autobuiler&lt;/a&gt; y la librería de sistema
&lt;a href="http://www.eglibc.org/"&gt;Embedded GLIBC (EGLIBC)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Además, cuando se crea una distribución con &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, la herramienta de construcción
crea un SDK de desarrollo de aplicaciones adaptado a dicha distribución. Este
SDK puede conectarse al IDE &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; o puede usarse desde la línea de comandos.&lt;/p&gt;
&lt;h2&gt;El sistema de construcción Poky&lt;/h2&gt;
&lt;p&gt;Uno de los componentes centrales de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; es el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.
Su responsabilidad fundamental es la construcción de imágenes de sistemas de
archivos de sistemas Linux. Estos pueden incluir diferentes productos de software:
Linux, X11, Matchbox, GTK+, Pimlico, Clutter, D-BUS, etc.&lt;/p&gt;
&lt;p&gt;Aunque se pueden generar diferentes tipos de imágenes según el dispositivo donde
va a ser almacenada, el proyecto ejemplo estándar lo hace para el emulador &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;
y para placas de referencia reales de los fabricantes, para cada una de las
arquitecturas soportadas. Esta habilidad de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; lo hace especialmente
apropiado como plataforma de pruebas y de desarrollo de software para empotrados.&lt;/p&gt;
&lt;p&gt;Un proyecto similar a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, que también es un sistema de construcción
para sistemas Linux empotrados. &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; deriva de un proyecto para crear
una rama estabilizada de &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, limitando el software disponible a unos
pocos paquetes, de entre los miles de los que dispone &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, así como el número
de arquitecturas soportadas. Con el tiempo esta rama evolucionó añadiendo
el componente de &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; y la generación de imágenes para &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;, entre otras cosas.
Esto dio origen a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El núcleo central de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es la herramienta de construcción &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; junto
con una colección de archivos de configuración de diversos tipos que definen
todo lo necesario para construir la imagen del sistema Linux.&lt;/p&gt;
&lt;h2&gt;La herramienta de construcción BitBake&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; es básicamente un ejecutor de tareas. Su función es leer los archivos
de configuración que definen el proyecto; establecer que tareas deben ser realizadas
y en que orden, obviamente en función de las dependencias y para maximizar la eficiencia
(por ejemplo primero se intentan ejecutar las que son dependencias comunes a otras tareas)
y finalmente ejecutarlas.&lt;/p&gt;
&lt;p&gt;Los tipos de archivos de configuración que maneja &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; son:&lt;/p&gt;
&lt;dl&gt;
 &lt;dt&gt;Recetas (.bb)&lt;/dt&gt;
 &lt;dd&gt;Contienen información acerca de un componente de software concreto. Entre
 dicha información, por ejemplo, podemos destacar: desde donde descargar los
 parches para las fuentes, que configuraciones deben ser aplicadas antes de
 la compilación, como se compila el componente y como se empaqueta el resultado.&lt;/dd&gt;
 &lt;dt&gt;Clases (.bbclass)&lt;/dt&gt;
 &lt;dd&gt;Contienen información que es interesante compartir entre distintas recetas.
 Por ejemplo la clase **autotools**, que contiene configuraciones comunes para
 cualquier aplicación que utiliza la herramienta **autotools**.&lt;/dd&gt;
 &lt;dt&gt;Configuraciones (.conf)&lt;/dt&gt;
 &lt;dd&gt;Define diversas variables de configuración que controlan lo que Poky va
 a hacer. Esto incluye configuraciones específicas de la maquina, opciones de
 configuración de la distribución, ajustes del compilador, configuraciones de
 usuario, etc.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; puede combinar varios de estos archivos en los se denomina como &lt;strong&gt;capas&lt;/strong&gt;.
Una capa es un agrupamiento de recetas que proporciona algún tipo de funcionalidad
adicional. Pueden ser un &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para un nuevo dispositivo, tipos de imágenes
adicionales o software no incluido en Poky.&lt;/p&gt;
&lt;p&gt;Los mismos metadatos principales del proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, &lt;strong&gt;meta-yocto&lt;/strong&gt;, son por si
mismos una capa aplicada sobre la capa de metadatos OE-Core que añade software
adicional y tipos de imágenes a esta última.&lt;/p&gt;
&lt;p&gt;Un ejemplo de como funciona esto se puede ver al crear un dispositivo &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;
(Network-attached Storage) para la CPU Intel E660
(&lt;a href="http://www.intel.com/p/es_XL/embedded/hwsw/hardware/atom-e6xx/overview"&gt;Crown Bay&lt;/a&gt;)
usando x32, el nuevo &lt;a href="http://en.wikipedia.org/wiki/Application_binary_interface" title="Application binary interface"&gt;ABI&lt;/a&gt; nativo de 32 bits para procesadores x86-64:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;En el nivel más bajo colocaríamos una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para Crown Bay que activaría
 funcionalidades específicas del hardware de estos procesadores.
 Esta capa, por ejemplo, incluiría los drivers de vídeo.&lt;/li&gt;
&lt;li&gt;Como queremos utilizar x32, añadiríamos posteriormente la capa &lt;strong&gt;meta-x32&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;La funcionalidad de &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt; se incorporaría añadiendo la capa &lt;strong&gt;meta-bayron&lt;/strong&gt;,
 que el mismo proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; nos ofrece como ejemplo.&lt;/li&gt;
&lt;li&gt;Finalmente incorporaríamos una capa, que imaginariamente llamaremos
 &lt;strong&gt;meta-myproject&lt;/strong&gt;, para proveer el software y la configuraciones necesarias
 para crear una interfaz gráfica de usuario de configuración del &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Como hemos comentado, cada una de estas capas estaría formada por uno o más
archivos de configuración de los tipos indicados anteriormente.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.aosabook.org/en/yocto.html"&gt;The Yocto Proyect&lt;/a&gt;.
 &lt;a href="http://www.aosabook.org/"&gt;The Architecture of Open Source Applications&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.yoctoproject.org/wiki/FAQ"&gt;Yocto Proyect FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/poky-ref-manual/poky-ref-manual.html"&gt;Poky HandBook&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="yocto"></category><category term="poky"></category><category term="bitbake"></category><category term="empotrado"></category><category term="linux"></category><category term="openembedded"></category></entry></feed>