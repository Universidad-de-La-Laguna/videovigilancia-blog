<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sistema de Videovigilancia from Scratch</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/" rel="alternate"></link><link href="http://ull-etsii-sistemas-operativos.github.io/videovigilancia-blog/feeds/Qt.atom.xml" rel="self"></link><id>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/</id><updated>2013-04-22T00:00:00+01:00</updated><entry><title>Make install con qmake</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/make-install-con-qmake.html" rel="alternate"></link><updated>2013-04-22T00:00:00+01:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-22:make-install-con-qmake.html</id><summary type="html">&lt;p&gt;Cada entorno de desarrollo y/o lenguaje de programación maneja por sus propios
medios la manera de definir un proyecto de software y el proceso de construcción
del mismo. Sin embargo &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; sigue siendo ámpliamente utilizado para este
propósito, especialmente en los sistemas UNIX y derivados.&lt;/p&gt;
&lt;h1&gt;Make&lt;/h1&gt;
&lt;p&gt;Para usar &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; cada proyecto debe ir acompañado de un fichero &lt;code&gt;Makefile&lt;/code&gt; donde
se incluyen las reglas para la compilación y enlazado de las librerías y
ejecutables del mismo. Estas reglas fijan que es lo que hay que hacer —que
comandos ejecutar y como hacerlo— para obtener cada producto del proceso de
construcción, así como las dependencias de estos con respecto a otros productos
o a los distintos archivos de código fuente del proyecto. Además se pueden
incluir reglas para automatizar tareas tales como generar la documentación;
instalar o desplegar los programas, las librerías, la documentación y otros
productos generados; o limpiar el proyecto, borrando archivos temporales y
subproductos de la compilación.&lt;/p&gt;
&lt;p&gt;Cuando la construcción de un proyecto ha sido automatizada adecuadamente con
&lt;code&gt;make&lt;/code&gt;, la compilación del mismo se reduce a ejecutar el comando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;en el directorio del proyecto. Siendo su instalación igual de sencilla:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Obviamente entornos integrados de desarrollo como Eclise, KDevelop, Code::Blocks
o Visual Studio incorporan sus propias herramientas para automatizar la
compilación de proyectos, que además se integran perfectamente con estos
entornos gráficos. Sin embargo &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; suele estar disponible en cualquier
sistema y puede ser utilizado independientemente de las preferencias de cada
desarrollador acerca del entorno integrado con el que trabajar.&lt;/p&gt;
&lt;p&gt;Además &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; es una herramienta que fácilmente puede ser utilizada desde otras
de más alto nivel. Por ejemplo, un sistema de construcción de paquetes como el
que utilizan las distribuciones basadas en Debian automatiza todos los pasos,
desde la descarga del código fuente hasta la generación del archivo &lt;code&gt;.deb&lt;/code&gt;,
pasando por invocar a &lt;code&gt;make&lt;/code&gt; para compilar y a &lt;code&gt;make install&lt;/code&gt; para que los
productos de dicha construcción se instalen en su ubicación definitiva&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;, de
donde son tomados para conformar el contenido del paquete del proyecto. De forma
muy similar funciona &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Bitbake&lt;/a&gt;, la herramienta de construcción que utiliza el
proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; para generar distribuciones de Linux para sistemas empotrados,
y así una larga lista de herramientas similares. Para todas ellas el poder
automatizar la construcción de proyectos de software es fundamental, siendo éste
un campo donde la solución orientada a línea de comandos de &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; se muestra
mucho más flexible que las soluciones de interfaz gráfica integradas de los 
distintos entornos de desarrollo.&lt;/p&gt;
&lt;h1&gt;Qmake&lt;/h1&gt;
&lt;p&gt;Aunque &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; es una herramienta muy flexible, resulta muy compleja de utilizar,
si no imposible, cuando se quiere crear software portable. Diferentes sistemas
operativos pueden tener distintos compiladores, ya sean de diferentes
fabricantes o en distintas versiones, u ofrecer a las aplicaciones diferentes
funcionalidades —o las mismas pero de manera distintas—. Además un proyecto de
software puede depender de otras librerías o programas, que nuevamente pueden
ser de versiones diferentes o distintos desarrolladores. Y a todo eso hay que
unir que según el sistema operativo la ubicación de librerías, programas y
herramientas de desarrollo puede diferir.&lt;/p&gt;
&lt;p&gt;Enfrentar estas situaciones con &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; es extremadamente difícil, por lo que los
desarrolladores suelen utilizar otras utilidades que se encarguen de buscar las
herramientas de desarrollo y las dependencias del programa, detectar las
funcionalidades del sistema y generar un archivo &lt;code&gt;Makefile&lt;/code&gt; ajustado al sistema
concreto donde se va a compilar.&lt;/p&gt;
&lt;p&gt;Herramientas de este tipo existen muchas. Por ejemplo Autotools&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;, CMake,
SCons y &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt;. Siendo esta última la que se usa preferentemente con las
aplicaciones desarrolladas en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, ya que sabe manejar perfectamente las
singularidades de este &lt;em&gt;framework&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Con &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; las información requerida para construir un proyecto se define en un
&lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt; que generalmente tienen extensión &lt;code&gt;.pro&lt;/code&gt;. Al ejecutar
&lt;code&gt;qmake&lt;/code&gt; dentro del directorio de un proyecto, éste interpreta los archivos de
proyecto y genera el &lt;code&gt;Makefile&lt;/code&gt; correspondiente. Después sólo es necesario
ejecutar el comando &lt;code&gt;make&lt;/code&gt; para iniciar la compilación del mismo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;qmake
&lt;span class="nv"&gt;$ &lt;/span&gt;make
&lt;span class="nv"&gt;$ &lt;/span&gt;make install
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Reglas para make install&lt;/h1&gt;
&lt;p&gt;Realmente el último &lt;code&gt;make install&lt;/code&gt; no sirve de mucho porque &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; por defecto
no añade tareas a dicha regla en el archivo &lt;code&gt;Makefile&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Si queremos que al ejecutar &lt;code&gt;make install&lt;/code&gt; se instalen los archivos de nuestra
aplicación en las ubicaciones adecuadas&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt;, debemos instruir a &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; a través
del &lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt; acerca de como se hace:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;unix {          # Esta configuración específica de Linux y UNIX
    # Variables
    #
    isEmpty(PREFIX) {
        PREFIX = /usr/local
    }
    BINDIR  = $$PREFIX/bin
    DATADIR = $$PREFIX/share
    CONFDIR = /etc
    isEmpty(VARDIR) {
        VARDIR  = /var/lib/$${TARGET}
    }

    # Install
    #
    INSTALLS += target config desktop icon32 vardir

    ## Instalar ejecutable
    target.path = $$BINDIR

    ## Instalar archivo de configuración
    config.path = $$CONFDIR
    config.files += $${TARGET}.ini

    ## Instalar acceso directo en el menú del escritorio
    desktop.path = $$DATADIR/applications
    desktop.files += $${TARGET}.desktop

    ## Instalar icono de aplicación
    icon32.path = $$DATADIR/icons/hicolor/32x32/apps
    icon32.files += ./data/32x32/$${TARGET}.png

    ## Crear directorio de archivos variables
    vardir.path = $$VARDIR
    vardir.commands = :
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La variable &lt;code&gt;INSTALLS&lt;/code&gt; debe contener una lista de los recursos que queremos que
sean instalados con &lt;code&gt;make install&lt;/code&gt;. De tal forma que cada elemento de la lista
incorpora atributos que proporcionan información sobre dónde van a ser
instalados.&lt;/p&gt;
&lt;p&gt;Por ejemplo, el elemento &lt;code&gt;target&lt;/code&gt; representa a los ficheros resultado de la
construcción del proyecto. Asignando una ruta a &lt;code&gt;target.path&lt;/code&gt; estamos indicando
donde queremos que sean instalados. De forma similar, el elemento &lt;code&gt;icon32&lt;/code&gt;
representa al icono de la aplicación en el escritorio. Asignando un valor a
&lt;code&gt;icon32.path&lt;/code&gt; estamos diciendo donde queremos que sea instalado, mientras que el
valor del atributo &lt;code&gt;icon32.files&lt;/code&gt; indica donde podemos encontrar el archivo o
archivos del icono respecto al directorio del proyecto.&lt;/p&gt;
&lt;h1&gt;Definición de macros del preprocesador&lt;/h1&gt;
&lt;p&gt;Las variables que hemos definido dentro del &lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt; establecen la
ubicación de los recursos del programa tras su instalación. Sería más complicado
cometer errores si en nuestro código fuente usáramos directamente las rutas tal
y como se definen en el &lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html" title="qmake Project Files"&gt;archivo de proyecto&lt;/a&gt;, sin tener que volver a definirlas
en C++. Además eso daría pie a modificar la ruta de los archivos mediante la
redefinición de variables en la línea de comandos de &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt;, sin tener por ello
que modificar el código fuente. Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;qmake &lt;span class="nv"&gt;PREFIX&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/usr
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;ejecuta &lt;a href="http://en.wikipedia.org/wiki/Qmake" title="qmake"&gt;qmake&lt;/a&gt; usando el valor indicado para la variable &lt;code&gt;PREFIX&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Para conseguir esto sólo tenemos que utilizar la variable &lt;code&gt;DEFINES&lt;/code&gt;, que nos
permite listar un conjunto de macros del preprocesador&lt;sup id="fnref:4"&gt;&lt;a class="footnote-ref" href="#fn:4" rel="footnote"&gt;4&lt;/a&gt;&lt;/sup&gt; que queremos que sean
pasadas al compilador.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;unix {          # Esta configuración específica de Linux y UNIX
    # Variables
    #
    isEmpty(PREFIX) {
        PREFIX = /usr/local
    }
    BINDIR  = $$PREFIX/bin
    DATADIR = $$PREFIX/share
    CONFDIR = /etc
    isEmpty(VARDIR) {
        VARDIR  = /var/lib/$${TARGET}
    }

    DEFINES += APP_DATADIR=\\\&amp;quot;$$DATADIR\\\&amp;quot;
    DEFINES += APP_VARDIR=\\\&amp;quot;$$VARDIR\\\&amp;quot;
    DEFINES += APP_CONFFILE=\\\&amp;quot;$$CONFDIR/$${TARGET}.ini\\\&amp;quot;

    # Install
    #
    INSTALLS += target config desktop icon32 vardir

    ## Instalar ejecutable
    target.path = $$BINDIR

    ## Instalar archivo de configuración
    config.path = $$CONFDIR
    config.files += $${TARGET}.ini

    ## Instalar acceso directo en el menú del escritorio
    desktop.path = $$DATADIR/applications
    desktop.files += $${TARGET}.desktop

    ## Instalar icono de aplicación
    icon32.path = $$DATADIR/icons/hicolor/32x32/apps
    icon32.files += ./data/32x32/$${TARGET}.png

    ## Crear directorio de archivos variables
    vardir.path = $$VARDIR
    vardir.commands = :
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Así, por ejemplo, dentro del código fuente se puede usar la macro &lt;code&gt;APP_CONFFILE&lt;/code&gt;
con la ruta al archivo de configuración de la aplicación para acceder a él
mediante &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsettings.html" title="QSettings"&gt;QSettings&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QSettings&lt;/span&gt; &lt;span class="n"&gt;settings&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;APP_CONFFILE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;QSettings&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;IniFormat&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtdoc/qmake-project-files.html"&gt;qmake Project
Files&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://es.wikipedia.org/wiki/Filesystem_Hierarchy_Standard"&gt;Filesystem Hierarchy Standard&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Durante el proceso de construcción de un paquete &lt;code&gt;.deb&lt;/code&gt; el proyecto, una
vez compilado, se instala, pero no en la raíz del sistema donde está teniendo
lugar la compilación, sino que se confina el comando &lt;code&gt;make install&lt;/code&gt; a un
subdirectorio temporal. Así &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt; deposita los archivos en sus ubicaciones
predefinidas (p. ej. &lt;code&gt;/usr/bin&lt;/code&gt;, &lt;code&gt;/usr/lib&lt;/code&gt;, &lt;code&gt;/etc&lt;/code&gt;, &lt;code&gt;/var/lib&lt;/code&gt;, etc.) solo que
relativas a dicho subdirectorio (p .ej. &lt;code&gt;/ruta/al/subdirectorio/usr/bin&lt;/code&gt;,
&lt;code&gt;/ruta/al/subdirectorio/etc&lt;/code&gt;, &lt;code&gt;/ruta/al/subdirectorio/usr/lib&lt;/code&gt;,
&lt;code&gt;/ruta/al/subdirectorio/var/lib&lt;/code&gt;, etc.). Para obtener el contenido del paquete
sólo hace falta tomar el contenido del subdirectorio temporal, evitando que el
proceso de construcción ensucie el sistema donde se está ejecutando.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;GNU Autotools es la herramienta que está detrás de tener que ejecutar
&lt;code&gt;./configure&lt;/code&gt; antes de compilar muchos programas y librerías libres con &lt;a href="&amp;quot;http://es.wikipedia.org/wiki/Make&amp;quot;" title="make"&gt;make&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;En los sistemas Linux, UNIX y derivados éstas ubicaciones vienen definidas
por el &lt;a href="http://es.wikipedia.org/wiki/Filesystem_Hierarchy_Standard" title="Filesystem Hierarchy Standard"&gt;Filesystem Hierarchy Standard&lt;/a&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:4"&gt;
&lt;p&gt;Las macros del preprocesador son aquellas que generalmente se definen en
C/C++ mediante la directiva &lt;code&gt;#define&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:4" rev="footnote" title="Jump back to footnote 4 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="qt"></category><category term="make"></category><category term="qmake"></category><category term="INSTALLS"></category><category term="DEFINES"></category></entry><entry><title>Aplicaciones de consola con Qt</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/aplicaciones-de-consola-con-qt.html" rel="alternate"></link><updated>2013-04-11T00:00:00+01:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-04-11:aplicaciones-de-consola-con-qt.html</id><summary type="html">&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; es un &lt;em&gt;framework&lt;/em&gt; utilizado fundamentalmente para desarrollar aplicaciones
con interfaz gráfica. Sin embargo nada impide que también sea utilizado para crear
aplicaciones de linea de comandos.&lt;/p&gt;
&lt;h1&gt;QCoreApplication&lt;/h1&gt;
&lt;p&gt;Al crear un proyecto de aplicación para consola, el asistente de Qt Creator
crea un archivo &lt;code&gt;main.cpp&lt;/code&gt; con un contenido similar al siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;QCoreApplication&amp;gt;&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QCoreApplication&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt; es una clase que provee un bucle de mensaje para aplicaciones
de consola, mientras que para aplicaciones gráficas lo adecuado es usar &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qapplication.html" title="QApplication"&gt;QApplication&lt;/a&gt;.
El bucle de mensajes es iniciado con la invocación del método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#exec" title="QApplication::exec"&gt;exec&lt;/a&gt;(), que no retorna hasta que la aplicación finaliza.
Por ejemplo cuando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html#quit" title="QApplication::quit"&gt;quit&lt;/a&gt;() es llamado.&lt;/p&gt;
&lt;p&gt;Si la aplicación no necesita de un bucle de mensajes, no es necesario instanciar
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;, pudiendo desarrollarla como cualquier programa convencional
en C++, sólo que beneficiándonos de las facilidades ofrecidas por las clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Las clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; que requieren disponer de un bucle de mensajes son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Controles, ventanas y en general todas las relacionadas con el GUI&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Temporizadores&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Comunicación entre hilos mediante señales&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Red&lt;/strong&gt;. Si se usan los métodos síncronos &lt;code&gt;waitFor*&lt;/code&gt; se puede evitar el uso
del bucle de mensajes, pero hay que tener en cuenta que las clases de comunicaciones
de alto nivel (&lt;code&gt;QHttp&lt;/code&gt;, &lt;code&gt;QFtp&lt;/code&gt;, etc.) no ofrecen dicho API.&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Entrada estándar&lt;/h1&gt;
&lt;p&gt;Muchas aplicaciones de consola interactúan con el usuario a través de la
&lt;em&gt;entrada estándar&lt;/em&gt;, para lo cual se pueden usar tanto las clases de la librería
estándar de C++:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;getline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cint&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;como los flujos de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QTextStream&lt;/span&gt; &lt;span class="n"&gt;qtin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;QString&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;qtin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;readLine&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Sin embargo es necesario tener presente que en ambos casos el hilo principal
se puede bloquear durante la lectura (hasta que hayan datos que leer) lo que
impediría la ejecución del bucle de mensajes.&lt;/p&gt;
&lt;p&gt;Para evitarlo se puede delegar la lectura de la &lt;em&gt;entrada estándar&lt;/em&gt; a otro hilo,
que se comunicaría con el principal para informar de las acciones del usuario
a través del mecanismo de señales y &lt;em&gt;slots&lt;/em&gt; de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;. El procedimiento sería muy
similar al que comentamos en
&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html"&gt;una entrada anterior&lt;/a&gt;, sólo que
para leer la &lt;em&gt;entrada estándar&lt;/em&gt; en lugar de para ordenar un vector de enteros.&lt;/p&gt;
&lt;h1&gt;Manejo de señales&lt;/h1&gt;
&lt;p&gt;Los sistemas operativos compatibles POSIX implementan un tipo de interrupción
por software conocido como &lt;em&gt;señales POSIX&lt;/em&gt;. Estas son enviadas a los procesos
para informar de situaciones excepcionales durante la ejecución del programa, como
por ejemplo:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;SIGSEGV&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Acceso a una dirección de memoria no válida.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGFPE&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Intento de ejecutar una operación aritmética inválida, como por ejemplo una
división por cero.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGILL&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Intento de ejecutar una instrucción ilegal.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGCHLD&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Notificación de terminación de algún proceso hijo.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGTERM&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Notificación de que se ha solicitado la terminación del proceso.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIGINT&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Notificación de que el proceso está controlado por una terminal y el usuario
quiere interrumpirlo. Generalmente esta señal es motivada por la pulsación de
la combinación de teclas &lt;code&gt;Ctrl-C&lt;/code&gt; en la terminal desde la que se controla el
proceso.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Todas éstas sólo son una pequeña muestra de una &lt;a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals"&gt;lista&lt;/a&gt;
mucho más larga.&lt;/p&gt;
&lt;p&gt;Para cada tipo de señal el proceso puede especificar una &lt;a href="http://pubs.opengroup.org/onlinepubs/000095399/functions/xsh_chap02_04.html#tag_02_04_03" title="Signal Actions"&gt;acción&lt;/a&gt; diferente:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;strong&gt;SIG_DFL&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Ejecutar la acción por defecto, lo que en ocasiones implica terminar el proceso.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;SIG_IGN&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Ignorar la señal, lo que no es posible para todos los tipos de señales.&lt;/dd&gt;
&lt;dt&gt;&lt;strong&gt;Invocar un manejador de señal&lt;/strong&gt;&lt;/dt&gt;
&lt;dd&gt;Invocar una función concreta del programa que actua como &lt;em&gt;manejador de la señal&lt;/em&gt;
para realizar las acciones que el programador considere oportunas.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Esto último es interesante porque permite realizar las acciones necesarias para
que el programa termine en condiciones seguras. Por ejemplo: borrar archivos
temporales, asegurar que los datos se escriben en disco y su estructura es
consistente, terminar procesos hijo a los que se les haya delegado parte del
trabajo, etc.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;signum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Señal (&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;signum&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;) recibida.&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// Terminar el programa&lt;/span&gt;
    &lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;signum&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Seguridad respecto a las señales&lt;/h2&gt;
&lt;p&gt;Sin embargo debemos de tener presente que las &lt;em&gt;señales POSIX&lt;/em&gt; pueden llegar en
cualquier momento, interrumpiendo la secuencia normal de instrucciones del
proceso. Por lo tanto los &lt;em&gt;manejadores de señal&lt;/em&gt; son invocados de forma asíncrona
respecto a la ejecución del proceso, lo que introduce problemas de concurrencia
debido al posible acceso del manejador a datos que estén siendo manipulados por
el programa.&lt;/p&gt;
&lt;p&gt;Por ello:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;El estándar POSIX establece que desde una manejador de señal sólo se pueden
invocar funciones seguras respecto a la asincronicidad de las señales:&lt;ul&gt;
&lt;li&gt;Estas funciones son aquellas que o son &lt;em&gt;reentrantes&lt;/em&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; o no interrumpibles&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;
respecto a las señales.&lt;/li&gt;
&lt;li&gt;Sólo &lt;a href="http://en.wikipedia.org/wiki/Unix_signal#POSIX_signals"&gt;unas pocas&lt;/a&gt;
funciones de la librería del sistema cumplen con dicho requisito.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Incluso si se usan variables como banderas para notificar desde el manejador
al programa principal que ha ocurrido una señal, con el objeto de que éste último
ejecute las acciones necesarias, debemos especificar al compilador que no
utilice con esas variables optimizaciones que puedan dar problemas de la
concurrencia.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;volatile&lt;/span&gt; &lt;span class="n"&gt;informa&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;compilador&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="nb"&gt;no&lt;/span&gt; &lt;span class="n"&gt;optimice&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;acceso&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;porque&lt;/span&gt; &lt;span class="n"&gt;su&lt;/span&gt; &lt;span class="n"&gt;valor&lt;/span&gt; &lt;span class="n"&gt;puede&lt;/span&gt; &lt;span class="n"&gt;cambiar&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;cualquier&lt;/span&gt; &lt;span class="n"&gt;momento&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;volatile&lt;/span&gt; &lt;span class="n"&gt;sig_atomic_t&lt;/span&gt; &lt;span class="n"&gt;waitingForQuit&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;signum&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Indicar&lt;/span&gt; &lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;programa&lt;/span&gt; &lt;span class="n"&gt;principal&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="n"&gt;debe&lt;/span&gt; &lt;span class="n"&gt;terminar&lt;/span&gt;
    &lt;span class="n"&gt;waitingForQuit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;waitingForQuit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Configurar&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;
    &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGINT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;signal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGTERM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;signalHandler&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="o"&gt;...&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;waitingForQuit&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Terminar&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;proceso&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;condiciones&lt;/span&gt; &lt;span class="n"&gt;seguras&lt;/span&gt;
            &lt;span class="o"&gt;...&lt;/span&gt;
            &lt;span class="nb"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En programas multihilo cualquier hilo en el que no se haya bloqueado una
señal puede ser utilizado para atenderla. Eso introduce problemas adicionales
de concurrencia que obligan al uso de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;cerrojos, semáforos y otros elementos
de sincronización&lt;/a&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Obviamente no hay seguridad de que las funciones del API de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; cumplan con
los requisitos comentados anteriormente, por lo que no podemos invocarlas
directamente desde los &lt;em&gt;manejadores de señal&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Además &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; no integra ninguna solución que encapsule y simplifique la gestión
de &lt;em&gt;señales POSIX&lt;/em&gt;, puesto que éstas no están disponibles en sistemas operativos
que no soporten dicha especificación.&lt;/p&gt;
&lt;h2&gt;Usando manejadores de señales POSIX con Qt&lt;/h2&gt;
&lt;p&gt;Aun así en la documentación de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; se describe una forma de usar manejadores de
señales POSIX. Realmente basta con que el &lt;em&gt;manejador de señal&lt;/em&gt; haga algo
que provoque que &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; emita una señal y después retorne. Al volver a la
secuencia normal de ejecución del programa, se emitiría la señal de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;
invocando el &lt;em&gt;slot&lt;/em&gt; al que está conectada, desde donde se ejecutarían de forma
segura las operaciones que fueran necesarias.&lt;/p&gt;
&lt;p&gt;Concretamente en el artículo
&lt;a href="http://doc.qt.digia.com/4.7/unix-signals.html"&gt;Calling Qt Functions From Unix Signal Handlers&lt;/a&gt;
se propone lo siguiente:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declarar una clase que contenga los &lt;em&gt;manejadores de señal&lt;/em&gt;, los &lt;em&gt;slots&lt;/em&gt; y
otros elementos que comentaremos a continuación.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;MyDaemon&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="n"&gt;public:&lt;/span&gt;
        &lt;span class="n"&gt;MyDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;MyDaemon&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Manejadores&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;POSIX&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;hupSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;termSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;slots:&lt;/span&gt;
        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Slots&lt;/span&gt; &lt;span class="n"&gt;Qt&lt;/span&gt; &lt;span class="n"&gt;donde&lt;/span&gt; &lt;span class="n"&gt;atender&lt;/span&gt; &lt;span class="n"&gt;las&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;ales&lt;/span&gt; &lt;span class="n"&gt;POSIX&lt;/span&gt;
        &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;handleSigHup&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;handleSigTerm&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;private:&lt;/span&gt;
        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Pares&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;sockets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Un&lt;/span&gt; &lt;span class="n"&gt;par&lt;/span&gt; &lt;span class="n"&gt;por&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;manejar&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Objetos&lt;/span&gt; &lt;span class="n"&gt;para&lt;/span&gt; &lt;span class="n"&gt;monitorizar&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="n"&gt;pares&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;sockets&lt;/span&gt;
        &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sigHupNotifier&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sigTermNotifier&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el constructor, para cada señal que se quiere manejar, se usa la llamada
al sistema &lt;a href="http://linux.die.net/man/2/socketpair" title="socketpair(2)"&gt;socketpair&lt;/a&gt;() para crear una pareja de
&lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;sockets de dominio UNIX&lt;/a&gt; anónimos
conectados entre sí. Al estar conectados desde el principio, lo que se escribe
en uno de los &lt;em&gt;sockets&lt;/em&gt; de la pareja se puede leer en el otro. Además se crea un
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt; para uno de los sockets de cada pareja, con el objeto de
monitorizar cuando hay datos disponibles para ser leidos, en cuyo caso envía
la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html#activated" title="QSocketNotifier::activated()"&gt;activated&lt;/a&gt;().&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;MyDaemon&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Crear&lt;/span&gt; &lt;span class="n"&gt;las&lt;/span&gt; &lt;span class="n"&gt;parejas&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;sockets&lt;/span&gt; &lt;span class="n"&gt;UNIX&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;socketpair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_UNIX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;qFatal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Couldn&amp;#39;t create HUP socketpair&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;socketpair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AF_UNIX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SOCK_STREAM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;qFatal&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Couldn&amp;#39;t create TERM socketpair&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Crear&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="n"&gt;objetos&lt;/span&gt; &lt;span class="n"&gt;para&lt;/span&gt; &lt;span class="n"&gt;monitorizar&lt;/span&gt; &lt;span class="n"&gt;uno&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="nb"&gt;socket&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;cada&lt;/span&gt; &lt;span class="n"&gt;pareja&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
    &lt;span class="n"&gt;sigHupNotifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupFd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="nn"&gt;QSocketNotifier::&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;sigTermNotifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt;
        &lt;span class="nn"&gt;QSocketNotifier::&lt;/span&gt;&lt;span class="n"&gt;Read&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Conectar&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;activated&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;cada&lt;/span&gt; &lt;span class="n"&gt;objeto&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;QSocketNotifier&lt;/span&gt; &lt;span class="n"&gt;con&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;slot&lt;/span&gt; &lt;span class="n"&gt;correspondiente&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Esta&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;ser&lt;/span&gt;&lt;span class="err"&gt;á&lt;/span&gt; &lt;span class="n"&gt;emitida&lt;/span&gt; &lt;span class="n"&gt;cuando&lt;/span&gt; &lt;span class="n"&gt;hayan&lt;/span&gt; &lt;span class="n"&gt;datos&lt;/span&gt; &lt;span class="n"&gt;para&lt;/span&gt; &lt;span class="n"&gt;ser&lt;/span&gt; &lt;span class="n"&gt;leidos&lt;/span&gt; &lt;span class="n"&gt;en&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="nb"&gt;socket&lt;/span&gt; &lt;span class="n"&gt;monitorizado&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupNotifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;activated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handleSigHup&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermNotifier&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;activated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handleSigTerm&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;

    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Entonces los manejadores de señal lo único que tienen que hacer cuando son
invocados es escribir &lt;em&gt;algo&lt;/em&gt; en el &lt;em&gt;socket&lt;/em&gt; correspondiente. Nótese que los
métodos de los manejadores se declaran como &lt;code&gt;static&lt;/code&gt; para que puedan ser pasados
como un puntero de función de C a la llamada al sistema &lt;a href="http://linux.die.net/man/2/sigaction" title="sigaction(2)"&gt;sigaction&lt;/a&gt;(), cuando
va a ser establecido el manejador de cada señal concreta:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGHUP&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;hupSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGTERM&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;termSignalHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Configurar&lt;/span&gt; &lt;span class="n"&gt;los&lt;/span&gt; &lt;span class="n"&gt;manejadores&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt;
&lt;span class="sr"&gt;//&lt;/span&gt;
&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;setupUnixSignalHandlers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;struct&lt;/span&gt; &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigaction&lt;/span&gt; &lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;hupSignalHandler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigemptyset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SA_RESTART&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Establecer&lt;/span&gt; &lt;span class="n"&gt;manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGHUP&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigaction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGHUP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;hup&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_handler&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;termSignalHandler&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigemptyset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sa_flags&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SA_RESTART&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Establecer&lt;/span&gt; &lt;span class="n"&gt;manejador&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;se&lt;/span&gt;&lt;span class="err"&gt;ñ&lt;/span&gt;&lt;span class="n"&gt;al&lt;/span&gt; &lt;span class="n"&gt;SIGTERM&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sigaction&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SIGTERM&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;term&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Finalmente en los &lt;em&gt;slots&lt;/em&gt; a los que conectamos la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html#activated" title="QSocketNotifier::activated()"&gt;activated&lt;/a&gt;()
se lee &lt;em&gt;lo escrito&lt;/em&gt; desde el &lt;em&gt;manejador de señal&lt;/em&gt;, para después hacer todo
aquello que no se puede hacer desde dicho manejador de señal POSIX.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;handleSigHup&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;hupNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigHupSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="n"&gt;tu&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;hupNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MyDaemon::&lt;/span&gt;&lt;span class="n"&gt;handleSigTerm&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;termNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;false&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;char&lt;/span&gt; &lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="nb"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sigTermSd&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="n"&gt;tu&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;termNotifier&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setEnabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qcoreapplication.html" title="QCoreApplication"&gt;QCoreApplication&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qsocketnotifier.html" title="QSocketNotifier"&gt;QSocketNotifier&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://doc.qt.digia.com/4.7/unix-signals.html"&gt;Calling Qt Functions From Unix Signal Handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Unix_signal"&gt;Unix signal&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Una función es reentrante si puede ser interrumpida en medio de su ejecución
y vuelta a llamar con total seguridad. En general una función es reentrante si
no modifica variables estáticas o globales, no modifica su propio código y no
llama a otras funciones que no sean reentrantes.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Una función puede ser no interrumpible respecto a las señales si al entrar
en la función el programa las bloquea, desbloqueándolas antes de salir.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="qt"></category><category term="qcoreapplication"></category><category term="consola"></category><category term="terminal"></category><category term="señales"></category><category term="hilos"></category><category term="signal"></category><category term="sigaction"></category><category term="qsocketnotifier"></category><category term="volatile"></category></entry><entry><title>Uso de la memoria como un dispositivo de E/S</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/uso-de-la-memoria-como-un-dispositivo-de-es.html" rel="alternate"></link><updated>2013-03-13T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-13:uso-de-la-memoria-como-un-dispositivo-de-es.html</id><summary type="html">&lt;p&gt;Algunas libreras se diseñan específicamente para leer y/o escribir datos en
dispositivos de entrada/salida. Por ejemplo, una librería desarrollada en C++ para
codificar y decodificar archivos MP3 recibiría objetos &lt;a href="http://www.cplusplus.com/reference/istream/istream/" title="std::istream"&gt;std::istream&lt;/a&gt; o
&lt;a href="http://www.cplusplus.com/reference/ostream/ostream/" title="std::ostream"&gt;std::ostream&lt;/a&gt; para indicar el flujo del que leer o en el que escribir los datos
respectivamente:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/istream/istream/" title="std::istream"&gt;std::istream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Clase de flujo de entrada. Los objetos de esta clase pueden leer e interpretar
la entrada de datos a partir de secuencias de caracteres.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/ostream/ostream/" title="std::ostream"&gt;std::ostream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Clase de flujo de salida. Los objetos de esta clase pueden escribir secuencias
de caracteres y representar como cadenas otras clases de datos.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Por lo tanto, si deseáramos guardar o recuperar audio codificado en MP3 en un
medio de almacenamiento concreto, necesitaríamos disponer de una clase que nos
ofrezca el acceso al mismo a través de la interfaz de flujos de C++ de
entrada/salida descrita por las clases anteriores.&lt;/p&gt;
&lt;p&gt;Objetos como &lt;a href="http://www.cplusplus.com/reference/iostream/cin/" title="std::cin"&gt;std::cin&lt;/a&gt; y &lt;a href="http://www.cplusplus.com/reference/iostream/cout/" title="std::cout"&gt;std::cout&lt;/a&gt; son instancias de estas clases, lo que
permitiría que nuestra aplicación codificara y decodificara audio hacia y
desde la entrada/salida estándar del proceso. Lo mismo ocurre con
&lt;a href="http://www.cplusplus.com/reference/fstream/ifstream/" title="std::ifstream"&gt;std::ifstream&lt;/a&gt;, &lt;a href="http://www.cplusplus.com/reference/fstream/ofstream/" title="std::ofstream"&gt;std::ofstream&lt;/a&gt; y &lt;a href="http://www.cplusplus.com/reference/fstream/fstream/" title="std::fstream"&gt;std::fstream&lt;/a&gt;; que heredan de las clases
anteriores e implementan la interfaz de flujos de C++ para los archivos. De
esta manera nuestra hipotética librería de MP3 podría codificar y decodificar
datos en este formato hacia y desde dichos archivos.&lt;/p&gt;
&lt;p&gt;En este punto la cuestión que se nos plantea es ¿qué podríamos hacer si,
por ejemplo, quisiéramos codificar el audio para posteriormente transmitirlo
a otro ordenador a través de una red? Teniendo en cuenta lo comentado hasta
ahora, una opción sería codificarlo almacenándolo en un archivo y posteriormente
leer del mismo para transmitir los datos por la red. Obviamente esto dista
de ser ideal ya que sería preferible disponer de una clase que implementara
la interfaz de &lt;a href="http://www.cplusplus.com/reference/ostream/ostream/" title="std::ostream"&gt;std::ostream&lt;/a&gt; para almacenar los datos codificados directamente
en la memoria, evitando tener que dar pasos intermedios como guardarlos y
leerlos de un archivo temporal.&lt;/p&gt;
&lt;p&gt;Por fortuna la librería estándar de C++ nos provee de las clases:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/sstream/istringstream/" title="std::istringstream"&gt;std::istringstream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Flujo de entrada para operar sobre cadenas. Los objetos de esta clase
permiten leer los caracteres del flujo de entrada a partir del contenido
de un objeto &lt;code&gt;std::string&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/sstream/ostringstream/" title="std::ostringstream"&gt;std::ostringstream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Flujo de salida para operar sobre cadenas. Los objetos de esta clase
permiten escribir los caracteres del flujo de salida en un objeto &lt;code&gt;std::string&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://www.cplusplus.com/reference/sstream/stringstream/" title="std::stringstream"&gt;std::stringstream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Flujo para operar sobre cadenas. Los objetos de esta clase permiten leer
y escribir en un objeto &lt;code&gt;std::string&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;ofreciéndonos una forma sencilla de almacenar o leer de la memoria del proceso
los datos codificados en MP3, lo que facilitaría cuaĺquier tarea que quisiéramos
realizar con ellos posteriormente.&lt;/p&gt;
&lt;h2&gt;QIODevice&lt;/h2&gt;
&lt;p&gt;En el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; ocurre algo muy parecido. Todas las clases diseñadas
para acceder a dispositivos de entrada/salida reciben un objeto de la clase
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;. Por ejemplo:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qtextstream.html" title="QTextStream"&gt;QTextStream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz adecuada para leer y escribir datos en
formato texto desde un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qdatastream.html" title="QDataStream"&gt;QDataStream&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz adecuada para leer y escribir datos binarios
desde un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz independiente del formato para leer archivos de
imágenes desde un dispositivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagewriter.html" title="QImageWriter"&gt;QImageWriter&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Proporciona una interfaz independiente del formato para escribir archivos de
imágenes desde un dispositivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/como-usar-qmovie-en-qt.html" title="QMovie"&gt;QMovie&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase diseñada para reproducir películas leidas con &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;
desde un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;La clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; no se instancia directamente para crear objetos, sino que
su función es definir una interfaz genérica válida para todo tipo de
dispositivos de entrada/salida. En el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; diversas clases
heredan de esta, implementando la interfaz &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; para un dispositivo
concreto:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html" title="QTcpSocket"&gt;QTcpSocket&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; que permite establecer una conexión
TCP y transferir flujos de datos a través de ella.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; para leer y escribir archivos de texto
y binarios, así como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/resources.html"&gt;recursos de la aplicación&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html" title="QProcess"&gt;QProcess&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; que permite ejecutar un programa externo
y comunicarnos con él.&lt;/dd&gt;
&lt;dt&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt;&lt;/dt&gt;
&lt;dd&gt;Es una clase heredera de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; que implementa dicha interfaz de
dispositivos sobre un &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbytearray.html" title="QByteArray"&gt;QByteArray&lt;/a&gt;. Ésta es una clase que provee una interfaz
para manipular un &lt;em&gt;array&lt;/em&gt; de bytes en la memoria.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Ejemplos con imágenes&lt;/h2&gt;
&lt;p&gt;Para ilustrar lo comentado vamos a codificar y decodificar una imagen &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;
directamente desde la memoria.&lt;/p&gt;
&lt;h3&gt;Codificando una imagen en la memoria&lt;/h3&gt;
&lt;p&gt;Supongamos que &lt;code&gt;image&lt;/code&gt; es un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt; que queremos codificar en formato
PNG, guardando el resultado en un &lt;em&gt;array&lt;/em&gt; en la memoria para su procesamiento
posterior (p. ej. para transmitirlo a través de una red de comunicaciones).&lt;/p&gt;
&lt;p&gt;Hacerlo es tan sencillo como incorporar las siguientes líneas al programa:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;save&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;png&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como hemos comentado, &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt; es un clase heredada de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;, por lo
que podemos usarla allí donde se requiera un dispositivo de entrada/salida.
Por defecto los objetos de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt; se crean con un &lt;em&gt;buffer&lt;/em&gt; interno de tipo
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbytearray.html" title="QByteArray"&gt;QByteArray&lt;/a&gt;, al que podemos acceder directamente invocando el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html#buffer" title="QBuffer::buffer()"&gt;buffer&lt;/a&gt;(). Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QByteArray&lt;/span&gt; &lt;span class="n"&gt;bytes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Guardamos en un string los primeros 6 bytes de la imagen en PNG&lt;/span&gt;
&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;pngHeader&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;constData&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;cout&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;pngHeader&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;std&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;endl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;lo que mostraría por la salida estándar algo como lo siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="err"&gt;�&lt;/span&gt;&lt;span class="n"&gt;PNG&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta forma de guardar los datos es adecuada cuando no necesitamos más control
sobre las opciones del formato en cuestión. Si por el contrario queremos
controlar el nivel de compresión, el de gamma o algunos otros parámetros
específicos del formato, tendremos que emplear un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagewriter.html" title="QImageWriter"&gt;QImageWriter&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QImageWriter&lt;/span&gt; &lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;jpeg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setCompression&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;70&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;writer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Decodificando una imagen almacenada en la memoria&lt;/h3&gt;
&lt;p&gt;Ahora hagámoslo en sentido inverso. Si tenemos un puntero &lt;code&gt;const char *bytes&lt;/code&gt;
a una zona de memoria con &lt;code&gt;size&lt;/code&gt; bytes donde se almacena una imagen en formato
PNG y queremos cargarla en un objeto &lt;code&gt;QImage&lt;/code&gt;, sólo tenemos que asignar los
datos a un objeto &lt;code&gt;QBuffer&lt;/code&gt; y leer desde el:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QBuffer&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setDevice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setFormat&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;png&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;o lo que es equivalente y mucho más simple:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QByteArray&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bytes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;loadFromData&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;png&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbuffer.html" title="QBuffer"&gt;QBuffer&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qbytearray.html" title="QByteArray"&gt;QByteArray&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimage.html" title="QImage"&gt;QImage&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagewriter.html" title="QImageWriter"&gt;QImageWriter&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="qt"></category><category term="qbuffer"></category><category term="qiodevice"></category><category term="qimagewriter"></category><category term="qimagereader"></category></entry><entry><title>Qt Network</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/qt-network.html" rel="alternate"></link><updated>2013-03-04T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-03-04:qt-network.html</id><summary type="html">&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; proporciona un conjunto de API de comunicaciones a través del módulo
&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt;. Este ofrece tanto clases de bajo nivel para comunicación
mediante protocolos de transporte, como TCP y UDP, como clases de alto nivel que
implementan operaciones usando los protocolos de nivel de aplicación más
communes, como HTTP o FTP.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; incorpora este módulo por dos motivos fundamentales:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Aunque la mayor parte de los sistemas operativos modernos proporcionan un
 API de acceso a red basado en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html"&gt;BSD sockets&lt;/a&gt;,
 algunos introducen funcionalidades adicionales para adaptarlo al modelo
 de programación preferente en el sistema en cuestión. Este, por ejemplo,
 es el caso de Windows y la librería &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html"&gt;Winsock&lt;/a&gt;
 que incorpora. Por tanto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, gracias a su módulo &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt;, nos
 proporciona una forma portable de acceder a los servicios de red de los
 sistemas operativos soportados sin tener que preocuparnos por las
 particularidades de cada uno.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Las operaciones de red suelen requerir mucho tiempo antes de completarse,
 por lo que usarlas en un &lt;em&gt;slot&lt;/em&gt; del hilo principal implica el bloqueo del bucle
 de mensajes de la aplicación. Por fortuna el API &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/bsd-sockets.html"&gt;BSD sockets&lt;/a&gt;
 permite tanto el uso síncrono como asíncrono de la interfaz. Esta última
 forma de utilizarla evita el bloqueo del bucle de mensajes al impedir que las
 llamadas a la interfaz se bloqueen hasta que las operaciones de red son
 completadas. Sin embargo implican una forma de programar mucho más compleja
 para el desarrollador.&lt;/p&gt;
&lt;p&gt;El API de bajo nivel de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; es asíncrono por diseño,
 ocultando toda esa complejidad detrás del bucle de mensajes y del mecanismo
 de señales y &lt;em&gt;slots&lt;/em&gt; común a todo el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;. Aunque el API de bajo
 nivel ofrece métodos para comunicación síncrona (los métodos &lt;code&gt;waitFor*&lt;/code&gt;),
 en cuyo caso no necesitamos bucle de mensajes, su uso no está recomendado
 si no es en un hilo diferente al hilo principal. Además las clases del API
 de alto nivel no ofrecen métodos síncronos, por lo que si se usan es
 obligatorio disponer de un bucle de mensajes.&lt;/p&gt;
&lt;p&gt;Debemos tener en cuenta que las API del módulo &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; se pueden usar
 desde hilos diferentes al hilo principal ya que cada hilo gestionado por la
 clase &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html"&gt;QThread&lt;/a&gt;
 tiene su propio bucle de mensajes, que se inicia automáticamente en el método
 &lt;code&gt;QThread::run()&lt;/code&gt; por defecto.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Funcionalidad&lt;/h2&gt;
&lt;p&gt;El módulo &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; ofrece las siguientes interfaces:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;QNetworkRequest&lt;/code&gt;, &lt;code&gt;QNetworkReply&lt;/code&gt; y &lt;code&gt;QNetworkAccessManager&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Es una colección de clases que proporcionan una abstracción de alto nivel
sobre operaciones y protocolos de comunicación comunes, por ejemplo HTTP y FTP.
Cada instancia de la clase &lt;code&gt;QNetworkRequest&lt;/code&gt; representa una petición u operación
contra un servicio en red, mientras que las instancias de la clase
&lt;code&gt;QNetworkReply&lt;/code&gt; representan la respuesta a esas peticiones. La coordinación
de toda esta actividad es responsabilidad de &lt;code&gt;QNetworkAccessManager&lt;/code&gt;, que
se encarga de entregar a la red las peticiones una vez han sido creadas y de
emitir señales con la respuesta a las mismas cuando son recibidas. También
coordina el uso de &lt;em&gt;cookies&lt;/em&gt;, peticiones de autenticación y el uso de
servidores &lt;em&gt;proxy&lt;/em&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QTcpSocket&lt;/code&gt; y &lt;code&gt;QTcpServer&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;TCP es el protocolo de comunicación utilizado por diversos protocolos de
Internet, como HTTP o FTP. &lt;code&gt;QTcpSocket&lt;/code&gt; proporciona acceso de bajo nivel a
dicho protocolo. Permite establecer una conexión con una dirección IP y puerto
determinados, así como enviar y recibir datos. Estas operaciones son
asíncronas, por lo que no bloquean la ejecución del hilo, siendo la clase la
que notifica mediante señales tanto las condiciones de error como de cuándo
se dispone de nuevos datos para leer. Si lo que se desea es crear una
aplicación que reciba conexiones TCP entrantes (como un servidor), lo
conveniente es utilizar la clase &lt;code&gt;QTcpServer&lt;/code&gt;. Ésta nos permite escuchar en
una dirección IP y puerto concretos y aceptar las conexiones entrantes por parte
de los clientes. Cada vez que se acepta el intento de conexión de un cliente,
se obtiene una instancia de la clase &lt;code&gt;QTcpSocket&lt;/code&gt; con la que podemos
comunicarnos con él.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QUdpSocket&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;UDP es un protocolo de comunicación que también es utilizado por diversos
protocolos de Internet. &lt;code&gt;QUdpSocket&lt;/code&gt; proporciona acceso de bajo nivel a
dicho protocolo. Permite enviar y recibir paquetes de datos a una dirección IP
y puerto concretos, ya que a diferencia de TCP, UDP no provee un flujo continuo
de datos sino que opera mediante el envío de paquetes. Tampoco se provee una
clase específica para escuchar por conexiones entrantes (al estilo de
&lt;code&gt;QTcpServer&lt;/code&gt;), ya que UDP no es un protocolo orientado a conexión. La interfaz
de &lt;code&gt;QUdpSocket&lt;/code&gt; simplemente permite preparar el &lt;em&gt;socket&lt;/em&gt; para aceptar la
recepción de paquetes.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QLocalSocket&lt;/code&gt; y &lt;code&gt;QLocalServer&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Proporcionan una abstracción similar a la de &lt;code&gt;QTcpSocket&lt;/code&gt; y &lt;code&gt;QTcpServer&lt;/code&gt; pero
para &lt;em&gt;sockets&lt;/em&gt; locales. En Windows se implementa haciendo uso de tuberías con
nombre, mientras que en UNIX, Linux y otro sistemas POSIX se utilizan
&lt;a href="http://es.wikipedia.org/wiki/Socket_Unix"&gt;sockets de dominio UNIX&lt;/a&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QHostInfo&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Se utiliza para obtener la dirección IP asignada a un nombre de máquina
concreto a través del servicio DNS (Domain Name Service). Tanto la clase
&lt;code&gt;QTcpSocket&lt;/code&gt; como &lt;code&gt;QUdpSocket&lt;/code&gt; hacen esto automáticamente cuando se indica
un nombre de máquina y no una dirección IP. Sin embargo la clase &lt;code&gt;QHostInfo&lt;/code&gt;
nos permite hacerlo manualmente, si por cualquier motivo fuera necesario.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QNetworkProxy&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Cada instancia de &lt;code&gt;QNetworkProxy&lt;/code&gt; se usa para describir y configurar la
conexión a un servidor &lt;em&gt;proxy&lt;/em&gt;, que pueden dirigir o filtrar el tráfico
entre ambos extremos de una conexión. Un servidor &lt;em&gt;proxy&lt;/em&gt; puede ser activado
para un socket concreto, a través del método &lt;code&gt;QAbstractSocket::setProxy()&lt;/code&gt;,
antes de conectarlo, o a nivel de toda la aplicación a través
de la función &lt;code&gt;QNetworkProxy::setApplicationProxy()&lt;/code&gt;.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QNetworkConfigurationManager&lt;/code&gt; y &lt;code&gt;QNetworkConfiguration&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Estas clases constituyen la interfaz del gestor de portabilidad, que controla
el estado de conectividad del dispositivo, permitiendo iniciar y detener las
interfaces de red así como migrar transparentemente entre puntos de acceso.
La clase &lt;code&gt;QNetworkConfigurationManager&lt;/code&gt; gestiona la lista de configuraciones
de red conocidas por el dispositivo. Una configuración de red describe el
conjunto de parámetros usados al iniciar la interfaz de red y es representada
por instancias de la clase &lt;code&gt;QNetworkConfiguration&lt;/code&gt;.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Utilizar Qt Network&lt;/h2&gt;
&lt;p&gt;Para incorpora el módulo en nuestra aplicación, sólo tenemos que incluir la
declaración de sus clases añadiendo la siguiente directiva en aquellos
archivos donde las vayamos a utilizar:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="c"&gt;#include &amp;lt;QtNetwork&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para enlazar el módulo con el ejecutable de la aplicación, sólo hay que añadir
la siguiente línea al archivo &lt;code&gt;.pro&lt;/code&gt; del proyecto:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QT&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;network&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hecho esto, la mejor forma de aprender a utilizar los recursos del módulo
&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt; es siguiendo los ejemplos disponibles en su documentación:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Ejemplos de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html" title="QTcpSocket"&gt;QTcpSocket&lt;/a&gt; y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpserver.html" title="QTcpServer"&gt;QTcpServer&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/fortuneclient.html"&gt;Fortune Client&lt;/a&gt;
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/fortuneserver.html"&gt;Fortune Server&lt;/a&gt;
muestran como desarrollar una aplicación cliente-servidor sobre TCP.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/blockingfortuneclient.html"&gt;Blocking Fortune Client&lt;/a&gt;
muestra como usar la interfaz síncrona de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qtcpsocket.html" title="QTcpSocket"&gt;QTcpSocket&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/threadedfortuneserver.html"&gt;Threaded Fortune Server&lt;/a&gt;
muestra como desarrollar un servidor multihilo donde cada hilo sirve a un
cliente.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ejemplos de &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/qudpsocket.html" title="QUdpSocket"&gt;QUdpSocket&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/broadcastsender.html"&gt;Broadcast Sender&lt;/a&gt;
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/broadcastreceiver.html"&gt;Broadcast Receiver&lt;/a&gt;
muestran como desarrollar un emisor y un receptor sobre UDP.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/multicastsender.html"&gt;Multicast Sender&lt;/a&gt;
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/multicastreceiver.html"&gt;Multicast Receiver&lt;/a&gt;
muestran como desarrollar aplicaciones que hagan uso de la
&lt;a href="http://es.wikipedia.org/wiki/Multidifusi%C3%B3n"&gt;multidifusión&lt;/a&gt; (o &lt;em&gt;multicast&lt;/em&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtnetwork/" title="Qt Network"&gt;Qt Network&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="qt"></category><category term="comunicaciones"></category><category term="sockets"></category></entry><entry><title>Hilos de trabajo usando señales y slots</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/hilos-de-trabajo-usando-senales-y-slots.html" rel="alternate"></link><updated>2013-02-18T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-18:hilos-de-trabajo-usando-senales-y-slots.html</id><summary type="html">&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; proporciona clases para hilos y mecanismos de sincronización que facilitan
sacar las tareas de larga duración del hilo principal de la aplicación, lo que
de lo contrario bloquearía la interfaz de usuario.&lt;/p&gt;
&lt;p&gt;Una forma práctica de hacerlo la hemos visto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;anteriormente&lt;/a&gt;
utilizando un &lt;em&gt;buffer&lt;/em&gt; compartido. Sin embargo &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; provee a cada hilo de una
cola de mensajes, lo que permite enviar señales a &lt;em&gt;slots&lt;/em&gt; en otros hilos. Esto
nos proporciona una forma sencilla de pasar datos entre los hilos de la
aplicación.&lt;/p&gt;
&lt;p&gt;Si no se indica lo contrario, las señales emitidas desde un hilo a un objeto
en el mismo hilo son entregadas directamente. Es decir, que al emitir la señal
se invoca el &lt;em&gt;slot&lt;/em&gt; como si de un método convencional se tratara. Sin embargo
si el emisor y el receptor residen en hilos diferentes, la señal es insertada
en la cola de mensajes del hilo del objeto de destino. Así el &lt;em&gt;slot&lt;/em&gt;
correspondiente será invocado en el hilo receptor desde su bucle de mensajes.&lt;/p&gt;
&lt;p&gt;En la actualidad esta es la forma recomendada de usar hilos en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; ya que
permite evitar el uso de de mecanismos de sincronización como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;,
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;, etc.&lt;/p&gt;
&lt;h2&gt;El ejemplo. Ordenar números enteros&lt;/h2&gt;
&lt;p&gt;El ejemplo que vamos a seguir básicamente consiste en ordenar
un vector de enteros en un hilo de trabajo distinto al hilo principal.&lt;/p&gt;
&lt;p&gt;Como se puede observar en la figura utilizaremos dos objetos, uno vinculado
al hilo principal (clase &lt;code&gt;Sorter&lt;/code&gt;) y otro al hilo de trabajo
(clase &lt;code&gt;SorterWorker&lt;/code&gt;). En una aplicación gráfica convencional con &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; la
clase &lt;code&gt;Sorter&lt;/code&gt; podría ser una ventana o cualquier otro control que
quiera ceder una tarea al hilo de trabajo. Aquí no lo haremos así para
que el ejemplo sea lo más sencillo posible.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://docs.google.com/drawings/d/1tZ0CMTNJoLsbHx3TjgecQuRXGEM5hf3pYwm9_s1R8bI/pub?w=960&amp;amp;h=720" alt="Ejemplo de comunicación entre hilos en Qt" class="centered"&gt;&lt;/p&gt;
&lt;p&gt;En &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; un objeto se dice que vive en el hilo en el que es creado. Esto se
puede cambiar utilizando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#moveToThread" title="QObject::moveToThread()"&gt;moveToThread&lt;/a&gt;() que tienen todas las
clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;.&lt;/p&gt;
&lt;h2&gt;La clase Sorter&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Sorter&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="o"&gt;~&lt;/span&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="c1"&gt;// Ordenar asíncronamente un vector en el hilo de trabajo&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sortAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="nl"&gt;signals:&lt;/span&gt;
        &lt;span class="c1"&gt;// Señal para comunicarnos con el hilo de trabajo&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;sortingRequested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nl"&gt;slots:&lt;/span&gt;
        &lt;span class="c1"&gt;// Slot para saber cuando el vector ha sido ordenado&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;private&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="c1"&gt;// Clase del hilo de trabajo&lt;/span&gt;
        &lt;span class="n"&gt;QThread&lt;/span&gt; &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="c1"&gt;// Clase que hace el ordenamiento&lt;/span&gt;
        &lt;span class="n"&gt;SorterWorker&lt;/span&gt; &lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;La propia clase &lt;code&gt;Sorter&lt;/code&gt; se hará cargo de crear el hilo de trabajo, que por
defecto lo único que hace es iterar en su propio bucle de mensajes. Todos
los detalles acerca de la creación de hilos ya los vimos
&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;anteriormente&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;La clase &lt;code&gt;Sorter&lt;/code&gt; provee un método &lt;code&gt;sortAsync()&lt;/code&gt; que podrá ser llamado por
los clientes para ordenar un vector de números enteros. Puesto que la operación
es asíncrona, necesitamos definir un &lt;em&gt;slot&lt;/em&gt; &lt;code&gt;vectorSorted()&lt;/code&gt; para ser
notificados cuando el ordenamiento haya finalizado con éxito.&lt;/p&gt;
&lt;p&gt;La implementación de esta clase sería la siguiente:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Q_FUNC_INFO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThreadId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="c1"&gt;// Registrar los parámetros de la señales. Necesitamos registrar&lt;/span&gt;
    &lt;span class="c1"&gt;// QList&amp;lt;int&amp;gt; porque no es un tipo conocido por el sistema de&lt;/span&gt;
    &lt;span class="c1"&gt;// meta-objetos de Qt.&lt;/span&gt;
    &lt;span class="n"&gt;qRegisterMetaType&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;QVector&amp;lt;int&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Pasar la petición de ordenar a la instancia de SorterWorker&lt;/span&gt;
    &lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sortingRequested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
        &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;doSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
    &lt;span class="c1"&gt;// Ser notificado cuando el vector haya sido ordenado&lt;/span&gt;
    &lt;span class="n"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;

    &lt;span class="c1"&gt;// Migrar la instancia de SorterWorker al hilo de trabajo&lt;/span&gt;
    &lt;span class="n"&gt;sorterWorker_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;moveToThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// Iniciar el hilo de trabajo&lt;/span&gt;
    &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::~&lt;/span&gt;&lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Le decimos al bucle de mensajes del hilo que se detenga&lt;/span&gt;
    &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;quit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="c1"&gt;// Ahora esperamos a que el hilo de trabajo termine&lt;/span&gt;
    &lt;span class="n"&gt;workingThread_&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;sortAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Q_FUNC_INFO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThreadId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;emit&lt;/span&gt; &lt;span class="n"&gt;sortingRequested&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Sorter&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se puede observar, en el constructor de &lt;code&gt;Sorter&lt;/code&gt; se usa el método
&lt;code&gt;qRegisterMetaType()&lt;/code&gt;, antes de conectar las señales, para registrar el tipo
&lt;code&gt;QVector&amp;lt;int&amp;gt;&lt;/code&gt;. Esto debe hacerse porque cuando una señal es encolada sus
parámetros deben ser de tipos conocidos para &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, de forma que pueda
almacenar los argumentos en la cola.&lt;/p&gt;
&lt;p&gt;Por otro lado en el destructor de &lt;code&gt;Sorter&lt;/code&gt; tenemos cuidado de detener
el hilo de trabajo en condiciones seguras cuando ya no va a ser necesario.
Si no lo hacemos así, el hilo podría ser destruido por el sistema operativo
en cualquier punto de la secuencia de instrucciones al termina la aplicación,
lo que podría dejar los datos en uso en un estado indeterminado.&lt;/p&gt;
&lt;h2&gt;La clase SorterWorker&lt;/h2&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SorterWorker&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QObject&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="nl"&gt;signals:&lt;/span&gt;
        &lt;span class="c1"&gt;// Señal emitida cuando el vector ha sido ordenado&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nl"&gt;slots:&lt;/span&gt;
        &lt;span class="c1"&gt;// Método encargado del ordenamiento&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;doSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;qDebug&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;Q_FUNC_INFO&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;currentThreadId&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

            &lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;list_sorted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;qSort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list_sorted&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;emit&lt;/span&gt; &lt;span class="n"&gt;vectorSorted&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list_sorted&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Como usar el ejemplo&lt;/h2&gt;
&lt;p&gt;Para usar el ejemplo sólo necesitamos crear una instancia de &lt;code&gt;Sorter&lt;/code&gt; y
llamar a su método &lt;code&gt;sortAsync()&lt;/code&gt; para pedir que ordene el vector especificado.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QCoreApplication&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;Sorter&lt;/span&gt; &lt;span class="n"&gt;sorter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;sorter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sortAsync&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QVector&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html"&gt;Introducción al uso de hilos en Qt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://cdumez.blogspot.com.es/2011/03/worker-thread-in-qt-using-signals-slots.html"&gt;Worker Thread in Qt using Signals &amp;amp; Slots&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Todas las clases de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; tienen como clase base &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html" title="QObject"&gt;QObject&lt;/a&gt; donde se
implementan algunos métodos comunes como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html" title="QObject"&gt;QObject&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qobject.html#moveToThread" title="QObject::moveToThread()"&gt;moveToThread&lt;/a&gt;()&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="qt"></category><category term="hilos"></category><category term="señales"></category><category term="slots"></category></entry><entry><title>Introducción al uso de hilos en Qt</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/introduccion-al-uso-de-hilos-en-qt.html" rel="alternate"></link><updated>2013-02-16T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-16:introduccion-al-uso-de-hilos-en-qt.html</id><summary type="html">&lt;p&gt;Debido a la existencia del bucle de mensajes, no se pueden ejecutar tareas de
larga duración en los &lt;em&gt;slots&lt;/em&gt;. Si lo hiciéramos la ejecución tardaría en
volver al bucle de mensajes, retrasando el momento en el que la aplicación puede
procesar nuevos eventos de los usuarios.&lt;/p&gt;
&lt;p&gt;Por eso lo habitual es que desde los &lt;em&gt;slots&lt;/em&gt; se deleguen esas tareas a hilos de
trabajo —o &lt;em&gt;worker thread&lt;/em&gt;— de tal manera que se ejecuten mientras el hilo
principal sigue procesando los eventos que llegen a la aplicación.&lt;/p&gt;
&lt;h2&gt;Crear hilos&lt;/h2&gt;
&lt;p&gt;Para usar hilos en &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; se utiliza la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;, donde cada instancia de
dicha clase representa a un hilo de la aplicación.&lt;/p&gt;
&lt;p&gt;Crear un hilo es tan sencillo como heredar la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt; y reimplementar
el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run" title="QThread::run()"&gt;run&lt;/a&gt;() insertando el código que queremos que ejecute el hilo.
En este sentido el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run" title="QThread::run()"&gt;run&lt;/a&gt;() es para el hilo lo que la función
&lt;code&gt;main()&lt;/code&gt; es para la aplicación.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;MyThread&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="k"&gt;protected&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MyThread&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Aquí el código a ejecutar en el hilo...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Una vez instanciada la clase, iniciar el nuevo hilo es tan sencillo como
invocar el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#start" title="QThread::start()"&gt;start&lt;/a&gt;().&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;MyThread&lt;/span&gt; &lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kr"&gt;thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El hilo terminará cuando la ejecución retorne de su método MyThread::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#run" title="QThread::run()"&gt;run&lt;/a&gt;()
o si desde el código del hilo se invocan los métodos &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html" title="QThread"&gt;QThread&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qthread.html#exit" title="QThread::exit()"&gt;exit&lt;/a&gt;() o&lt;/p&gt;
&lt;h2&gt;Problema del buffer finito&lt;/h2&gt;
&lt;p&gt;Generalmente los hilos no se crean directamente en los &lt;em&gt;slots&lt;/em&gt; en los que son
necesarios, sino en la función &lt;code&gt;main()&lt;/code&gt;, en el constructor de la clase de la
ventana que los va a utilizar o en otros sitios similares. Eso se así por una
cuestión de eficiencia, ya que crear y destruir hilos según cuando son
necesarios tiene cierto coste.&lt;/p&gt;
&lt;p&gt;La única cuestión es que entonces un &lt;em&gt;slot&lt;/em&gt; debe poder entregar la tarea
al hilo correspondiente que ha sido creado previamente. Como todos los hilos
comparten la memoria del proceso, esto no debe ser un problema, pero realmente
entraña ciertas dificultades relacionadas con la concurrencia.&lt;/p&gt;
&lt;p&gt;Para ilustrarlo supongamos que hemos abierto un archivo de vídeo para procesarlo
y que un &lt;em&gt;slot&lt;/em&gt; de la clase de la ventana es invocado cada vez que se dispone
de un nuevo &lt;em&gt;frame&lt;/em&gt;. La función del &lt;em&gt;slot&lt;/em&gt; sería la de transferir al hilo
el &lt;em&gt;frame&lt;/em&gt; para que se haga cargo de su procesamiento. Teniendo esto en cuenta,
el problema al que nos enfrentamos podría ser descrito de la siguiente manera:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;El &lt;em&gt;slot&lt;/em&gt; obtiene los &lt;em&gt;frames&lt;/em&gt; por lo que sería nuestro &lt;em&gt;productor&lt;/em&gt;. Como
 se ejecuta desde la bomba de mensajes sabemos que siempre lo hace dentro
 del hilo principal del proceso.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;El hilo de trabajo encargado del procesamiento sería nuestro &lt;em&gt;consumidor&lt;/em&gt;,
 ya que toma los &lt;em&gt;frames&lt;/em&gt; entregados por el productor.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Ambos comparten un &lt;em&gt;buffer&lt;/em&gt; de &lt;em&gt;frames&lt;/em&gt; de tamaño fijo que se usa a modo
 de cola. El &lt;em&gt;productor&lt;/em&gt; insertaría los &lt;em&gt;frames&lt;/em&gt; en la cola mientras el
 &lt;em&gt;consumidor&lt;/em&gt; los extraería.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Para evitar que el &lt;em&gt;productor&lt;/em&gt; añada más &lt;em&gt;frames&lt;/em&gt; de los que caben en la
 cola y que el &lt;em&gt;consumidor&lt;/em&gt; intente extraer más cuando ya no queden,
 ambos comparten un contador con el número de &lt;em&gt;frames&lt;/em&gt; almacenados.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Para que todo esto funcione correctamente vamos a necesitar una serie de
elementos de sincronización que ayuden a ambos hilos a coordinarse:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Un cerrojo —o &lt;em&gt;mutex&lt;/em&gt;— de exclusión mutua &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt; que serialice la
  ejecución del código en ambos hilos que manipulan la cola y su contador. La
  idea es que mientras uno de los hilos esté manipulando la cola, el otro tenga
  que esperar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Una condición de espera &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt; para que el &lt;em&gt;productor&lt;/em&gt; pueda
  dormir —o descartar los nuevos &lt;em&gt;frames&lt;/em&gt;— mientras la cola esté llena. La
  siguiente vez que el consumidor extraiga un &lt;em&gt;frame&lt;/em&gt; de la cola, utilizaría la
  condición de espera para notificar al productor que puede volver a insertar
  &lt;em&gt;frames&lt;/em&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Una condición de espera &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt; para que el &lt;em&gt;consumidor&lt;/em&gt; pueda
  dormir mientras la cola esté vacía. La siguiente vez que el productor
  inserte un &lt;em&gt;frame&lt;/em&gt; en la cola, utilizaría la condición de espera para
  notificar al consumidor que puede volver a extraerlos.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Teniendo todo esto presente, a continuación desarrollamos un posible solución.&lt;/p&gt;
&lt;h3&gt;Variables globales&lt;/h3&gt;
&lt;p&gt;Como ya hemos comentado, ambos hilos deben compartir la cola, el contador y
una serie de elementos de sincronización:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="c1"&gt;// Tamaño de la cola&lt;/span&gt;
&lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;       &lt;span class="c1"&gt;// Cola de frames como array de C&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="c1"&gt;// Contador de frames en la cola&lt;/span&gt;

&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="n"&gt;bufferNotEmpty&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="n"&gt;bufferNotFull&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QMutex&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;El productor&lt;/h3&gt;
&lt;p&gt;El código del &lt;em&gt;productor&lt;/em&gt; en el &lt;em&gt;slot&lt;/em&gt; podría tener el siguiente aspecto:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;MyWindow&lt;/span&gt;&lt;span class="o"&gt;::&lt;/span&gt;&lt;span class="n"&gt;on_video_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;           &lt;span class="c1"&gt;// Posición último frame insertado&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// Bloquear el cerrojo&lt;/span&gt;
    &lt;span class="c1"&gt;// El código del productor a partir de este punto y hasta&lt;/span&gt;
    &lt;span class="c1"&gt;// el unlock() no se ejecutará si el consumidor ha bloqueado el&lt;/span&gt;
    &lt;span class="c1"&gt;// cerrojo primero.&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="c1"&gt;// ¿Cola llena?&lt;/span&gt;
        &lt;span class="n"&gt;bufferNotFull&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// Dormir hasta que haya sitio&lt;/span&gt;
                                        &lt;span class="c1"&gt;// en la cola.&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;

    &lt;span class="c1"&gt;// Insertar el frame en la cola&lt;/span&gt;
    &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;currentImage&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// Bloquear el cerrojo&lt;/span&gt;
    &lt;span class="c1"&gt;// El código del productor a partir de este punto y hasta&lt;/span&gt;
    &lt;span class="c1"&gt;// el unlock() no se ejecutará si el consumidor ha bloqueado el&lt;/span&gt;
    &lt;span class="c1"&gt;// cerrojo primero.&lt;/span&gt;

    &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;bufferNotEmpty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wakeAll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// Despertar al consumidor si&lt;/span&gt;
                                    &lt;span class="c1"&gt;// esperaba por más frames.&lt;/span&gt;

    &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Donde la instancia &lt;code&gt;mutex&lt;/code&gt; de la clase &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt; sirve para evitar que el
&lt;em&gt;productor&lt;/em&gt; y el &lt;em&gt;consumidor&lt;/em&gt; accedan al contador compartido al mismo tiempo.
Concretamente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;El primero en llegar al método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html#lock" title="QMutex::lock()"&gt;lock&lt;/a&gt;() obtiene el cerrojo. Si
un segundo hilo llega a ese método mientras el otro tiene el cerrojo,
simplemente se duerme a la espera de que el cerrojo sea liberado por el primero.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Con el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html#unlock" title="QMutex::unlock()"&gt;unlock&lt;/a&gt;() se libera el cerrojo. En ese momento
uno de los hilos que espera en &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html" title="QMutex"&gt;QMutex&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qmutex.html#lock" title="QMutex::lock()"&gt;lock&lt;/a&gt;() se despierta y obtiene
el cerrojo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Por otro lado las instancias de condiciones de espera &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt; permiten
dormir un hilo hasta que se de una condición determinada. En nuestro ejemplo el
&lt;em&gt;productor&lt;/em&gt; utiliza el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html#wait" title="QWaitCondition::wait()"&gt;wait&lt;/a&gt;() para dormir si la
cola está llena. Antes de hacerlo libera temporalmente el cerrojo &lt;code&gt;mutex&lt;/code&gt;,
permitiendo que el &lt;em&gt;consumidor&lt;/em&gt; se pueda ejecutar en el código que protege.&lt;/p&gt;
&lt;p&gt;Como se verá a continuación, el &lt;em&gt;consumidor&lt;/em&gt; utiliza el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html#weakAll" title="QWaitCondition::weakAll()"&gt;weakAll&lt;/a&gt;() después de extraer un elemento con el objeto
de despertar al productor. Obviamente este deberá bloquear el cerrojo &lt;code&gt;mutex&lt;/code&gt;
antes de volver del método &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html" title="QWaitCondition"&gt;QWaitCondition&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qwaitcondition.html#wait" title="QWaitCondition::wait()"&gt;wait&lt;/a&gt;().&lt;/p&gt;
&lt;h3&gt;El consumidor&lt;/h3&gt;
&lt;p&gt;El código del consumidor podría tener el siguiente aspecto, que es muy similar
al del productor:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;FrameProcessingThread&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Q_OBJECT&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;

        &lt;span class="n"&gt;FrameProcessingThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QThread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{}&lt;/span&gt;

        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;     &lt;span class="c1"&gt;// Posición último frame extraido&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// Bloqueamos el cerrojo&lt;/span&gt;
            &lt;span class="c1"&gt;// El código del consumidor a partir de este punto y&lt;/span&gt;
            &lt;span class="c1"&gt;// hasta el unlock() no se ejecutará si el productor ha&lt;/span&gt;
            &lt;span class="c1"&gt;// bloqueado el cerrojo primero.&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;     &lt;span class="c1"&gt;// ¿Cola vacía?...&lt;/span&gt;
                &lt;span class="n"&gt;bufferNotEmpty&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// Dormir si es así&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;

            &lt;span class="n"&gt;QImage&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;BufferSize&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                    &lt;span class="c1"&gt;// Bloquear el cerrojo&lt;/span&gt;
            &lt;span class="c1"&gt;// El código del consumidor a partir de este punto y&lt;/span&gt;
            &lt;span class="c1"&gt;// hasta el unlock() no se ejecutará si el productor ha&lt;/span&gt;
            &lt;span class="c1"&gt;// bloqueado el cerrojo primero.&lt;/span&gt;

            &lt;span class="o"&gt;--&lt;/span&gt;&lt;span class="n"&gt;numUsedBufferItems&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;bufferNotFull&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;wakeAll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Despertar al productor si&lt;/span&gt;
                                        &lt;span class="c1"&gt;// esperaba por un hueco.&lt;/span&gt;

            &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// Liberar el cerrojo&lt;/span&gt;

            &lt;span class="c1"&gt;// Aquí va el código para procesar el frame...&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;La función principal&lt;/h3&gt;
&lt;p&gt;Finalmente es en la función principal del programa &lt;code&gt;main()&lt;/code&gt; donde debe crearse
el hilo encargado del procesamiento de los &lt;em&gt;frames&lt;/em&gt;. Es decir, nuestro
consumidor.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QApplication&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;FrameProcessingThread&lt;/span&gt; &lt;span class="n"&gt;frameProcessingThread&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;frameProcessingThread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;MyWindow&lt;/span&gt; &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;show&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exec&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h1&gt;Referencias&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/threads-starting.html"&gt;Starting Threads with QThread&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-4.8/threads-waitconditions.html"&gt;Wait Conditions Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Wikipedia - &lt;a href="http://en.wikipedia.org/wiki/Producer-consumer_problem"&gt;Producer-consumer problem&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="qt"></category><category term="hilos"></category><category term="mutex"></category><category term="condición de espera"></category><category term="variables de condición"></category><category term="productor-consumidor"></category><category term="buffer finito"></category></entry><entry><title>Layouts en Qt. Organización de controles</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/layouts-en-qt-organizacion-de-controles.html" rel="alternate"></link><updated>2013-02-15T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-15:layouts-en-qt-organizacion-de-controles.html</id><summary type="html">&lt;p&gt;El sistema de &lt;em&gt;layouts&lt;/em&gt; de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; proporcionar una manera sencilla de organizar
los controles dentro de otros controles o ventanas, asegurando el mejor
aprovechamiento del espacio disponible.&lt;/p&gt;
&lt;p&gt;La idea es describir como deben organizarse los controles, dejando que después
sean posicionados automáticamente por &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; en función del espacio disponible,
incluso cuando este cambia por el redimensionado de la ventana o control que
los contiene.&lt;/p&gt;
&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;p&gt;Dentro de &lt;em&gt;Qt Creator&lt;/em&gt;, en cualquier control, incluidas las ventanas
principales y cuadros de diálogo, se puede seleccionar la organización de los
controles que contiene mediante la opción &lt;em&gt;Lay Out&lt;/em&gt; del menú contexual que
se despliega al pulsar con el botón derecho del ratón.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Menú Lay Out en Qt Creator" src="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/static/images/menu-lay-out.png" /&gt;&lt;/p&gt;
&lt;p&gt;Las opciones disponibles permiten organizar los controles en disposiciones tales
como:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Columnas en horizontal.&lt;/li&gt;
&lt;li&gt;Filas en vertical.&lt;/li&gt;
&lt;li&gt;En una rejilla bidimensional, permitiendo que un mismo control ocupe varias
celdas.&lt;/li&gt;
&lt;li&gt;Como un formulario, con dos colunmas donde a la izquierda se sitúan las
etiquetas descriptivas de los campos de la derecha.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Todas están comentadas en la documentación del proyecto sobre el
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/layout.html" title="Layout Management"&gt;Layout Management&lt;/a&gt; de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt;, donde además se muestran algunos ejemplos.&lt;/p&gt;
&lt;h2&gt;Anidamiento de layouts&lt;/h2&gt;
&lt;p&gt;Una organización de controles se puede anidar dentro de otra. Para eso existen
unos controles especiales (uno por cada uno de los tipos de organización comentados
anteriormente) cuya única función es contener otros controles para organizarlos
de una manera concreta:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;&lt;code&gt;QHBoxLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contiene en columnas en horizontal.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QVBoxLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contiene en filas en vertical.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QGridLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contiene en una rejilla bidimensional.&lt;/dd&gt;
&lt;dt&gt;&lt;code&gt;QFormLayout&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;Organiza los controles que contienen como un formulario, con dos columnas.&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;Estos controles se pueden crear dentro de otro, de tal forma que su ubicación
final dependerá de la organización configurada en el padre.&lt;/p&gt;
&lt;h2&gt;Espaciadores&lt;/h2&gt;
&lt;p&gt;Otro elemento clave en la organización de los controles son los &lt;em&gt;espaciadores&lt;/em&gt;.
Estos controles funcionan como muelles que separan los controles en horizontal
o en vertical, según su orientación.&lt;/p&gt;
&lt;p&gt;Por ejemplo, permiten mantener los controles lo más separados posible entre
sí o pegarlos a los extremos de las ventanas, incluso aunque estas sean
redimensionadas.&lt;/p&gt;
&lt;h2&gt;Tamaño de los controles&lt;/h2&gt;
&lt;p&gt;Cuando se añaden controles a un &lt;em&gt;layout&lt;/em&gt; este procede de la siguiente manera:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A todos los controles se les asigna una cantidad de espacio de acuerdo
 con su &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt;&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt; y su &lt;code&gt;QWidget::sizeHint()&lt;/code&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;.&lt;/li&gt;
&lt;li&gt;Si alguno de los controles tiene un &lt;em&gt;factor de estiramiento&lt;/em&gt;&lt;sup id="fnref:3"&gt;&lt;a class="footnote-ref" href="#fn:3" rel="footnote"&gt;3&lt;/a&gt;&lt;/sup&gt; con valor
 mayor  que cero, entonces se les asigna espacio en proporción a dicho factor.&lt;/li&gt;
&lt;li&gt;Si alguno de los controles tiene un &lt;em&gt;factor de estiramiento&lt;/em&gt; igual a cero,
 entonces sólo recibirá más espacio si ningún otro control lo reclama. De todos
 estos primero se asigna el espacio a los que tienen una propiedad
 &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt; configurada como &lt;em&gt;Expanding&lt;/em&gt;.&lt;/li&gt;
&lt;li&gt;A cualquier control al que se le ha asignado menos espacio que su tamaño mínimo
 (o el tamaño mínimo aconsejado&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt;, si no se ha especificado un tamaño mínimo concreto)
 se le asigna ese espacio que necesita.&lt;/li&gt;
&lt;li&gt;A cualquier control al que se le ha asignado más espacio que su tamaño máximo
 se le asigna ese espacio máximo.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;El &lt;em&gt;factor de estiramiento&lt;/em&gt;, que por lo general es cero, es un mecanismo para
dar a unos controles más espacio en relación a otros. Si por ejemplo tenemos
tres controles iguales en organización horizontal y sin &lt;em&gt;factor de estiramiento&lt;/em&gt;,
todos obtendrá el mismo espacio. Pero si aplicamos un &lt;em&gt;factor de estiramiento&lt;/em&gt;
su tamaño cambiará en proporción a la relación de dicho factor entre los distintos
controles.&lt;/p&gt;
&lt;p&gt;Otro elemento clave en la asignación del espacio es la política fijada en la
propiedad &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt;. Los valores posibles son:&lt;/p&gt;
&lt;dl&gt;
&lt;dt&gt;Fixed&lt;/dt&gt;
&lt;dd&gt;El tamaño del control viene determinado por &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; y no puede cambiarse.&lt;/dd&gt;
&lt;dt&gt;Minimum&lt;/dt&gt;
&lt;dd&gt;El tamaño del control indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es el mínimo posible.
No puede encogerse pero si hacerse más grande, según sea necesario.&lt;/dd&gt;
&lt;dt&gt;Maximum&lt;/dt&gt;
&lt;dd&gt;El tamaño del control indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es el máximo posible.
No puede agrandarse pero si encogerse, según sea necesario.&lt;/dd&gt;
&lt;dt&gt;Preferred&lt;/dt&gt;
&lt;dd&gt;El mejor tamaño posible es el indicado por &lt;code&gt;QWidget::sizeHint()&lt;/code&gt;, pero el
control puede tanto agrandarse como encogerse, según sea necesario.&lt;/dd&gt;
&lt;dt&gt;Expanding&lt;/dt&gt;
&lt;dd&gt;El mejor tamaño posible es el indicado por &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; pero el
control, de encogerse, seguiría siendo útil. Si sobra espacio, el control
debe hacerse todo lo grande que sea posible.&lt;/dd&gt;
&lt;dt&gt;MinimumExpanding&lt;/dt&gt;
&lt;dd&gt;El tamaño del control indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es el mínimo posible.
No puede agrandarse pero si sobra espacio, el control debe hacerse todo lo
grande que sea posible.&lt;/dd&gt;
&lt;dt&gt;Ignored&lt;/dt&gt;
&lt;dd&gt;El tamaño indicado en &lt;code&gt;QWidget::sizeHint()&lt;/code&gt; debe ignorarse y el control
debe hacerse todo lo grande que sea posible.&lt;/dd&gt;
&lt;/dl&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/layout.html" title="Layout Management"&gt;Layout Management&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;&lt;code&gt;QWidget::sizePolicy()&lt;/code&gt; es una propiedad de cada control donde
se fija la política que desea que se siga para asignarle espacio.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;&lt;code&gt;QWidget::sizeHint()&lt;/code&gt; es una propiedad de cada control donde se indica
el espacio recomendado que debe ocupar.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:3"&gt;
&lt;p&gt;El &lt;em&gt;factor de estiramiento del control&lt;/em&gt; se indica a través de su
propiedad &lt;code&gt;QWidget::sizePolicy()&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:3" rev="footnote" title="Jump back to footnote 3 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="qt"></category><category term="gui"></category><category term="layouts"></category></entry><entry><title>Como usar QMovie en Qt</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/como-usar-qmovie-en-qt.html" rel="alternate"></link><updated>2013-02-13T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-13:como-usar-qmovie-en-qt.html</id><summary type="html">&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; trae una clase denominada &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; que facilita mostrar pequeñas
animaciones sin mucho esfuerzo.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; está diseñada para ser independiente del formato de archivo pero como
internamente depende de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;, sólo puede utilizarse con los que esta
última soporta (véase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#supportedFormats" title="QMovie::supportedFormats()"&gt;supportedFormats&lt;/a&gt;()). Esto incluye GIF
animados, archivos MNG y MJPEG. Para mostrar vídeo y otros contenidos
multimedia, es mejor utilizar el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtmultimedia/multimediaoverview.html" title="Qt Multimedia"&gt;Qt Multimedia&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Primeros pasos&lt;/h2&gt;
&lt;p&gt;La forma más sencilla de usar &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; es asignar un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; a un
control &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; usando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setMovie" title="QLabel::setMovie()"&gt;setMovie&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QMovie&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;video.mjpeg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;donde &lt;code&gt;ui&lt;/code&gt; es el miembro de la clase que tiene asignada la instancia de la
ventana creada previamente con Qt Creator.&lt;/p&gt;
&lt;h2&gt;Nombre de archivo especificado por el usuario&lt;/h2&gt;
&lt;p&gt;No siempre ocurre que el nombre del archivo a reproducir se conozca de antemano
al desarrollar el programar. Si por ejemplo se pretende que el usuario lo
escoja de entre los disponibles en su disco duro podemos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crear un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;, guardarlo en un miembro de la clase (manteniendo
 así un puntero al mismo que nos permita referenciarlo más adelante&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;) y asignar
 dicho objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; a &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;MovieViewerWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QWidget&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QMainWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nn"&gt;Ui::&lt;/span&gt;&lt;span class="n"&gt;MovieViewerWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt; &lt;span class="n"&gt;otro&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;inicializaci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;instancia&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;movie_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el slot de la acción que abre el cuadro de diálogo &lt;em&gt;abrir archivo&lt;/em&gt;,
 asignar al objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; el nombre escogido por el usuario mediante el
 método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#setFileName" title="QMovie::setFileName()"&gt;setFileName&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;on_actionOpen_triggered&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="n"&gt;abre&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;cuadro&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;di&lt;/span&gt;&lt;span class="err"&gt;á&lt;/span&gt;&lt;span class="n"&gt;logo&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;comprueba&lt;/span&gt; &lt;span class="n"&gt;si&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;usuario&lt;/span&gt; &lt;span class="n"&gt;seleccion&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt; &lt;span class="n"&gt;alg&lt;/span&gt;&lt;span class="err"&gt;ú&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;archivo&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;QString&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;QFileDialog::&lt;/span&gt;&lt;span class="n"&gt;getFileName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;

    &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setFileName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isValid&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;QMessageBox::&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="nb"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No se pudo abrir el archivo o el formato&amp;quot;&lt;/span&gt;
               &lt;span class="s"&gt;&amp;quot; es inválido&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Iniciar&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;reproducci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;animaci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se puede observar es conveniente utilizar el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#isValid" title="QMovie::isValid()"&gt;isValid&lt;/a&gt;()
para comprobar si el archivo pudo ser abierto y tiene uno de los formatos soportados.&lt;/p&gt;
&lt;p&gt;Para distinguir entre ambos tipos de error, con el objeto de mostrar al usuario
un mensaje diferente según el caso, podemos emplear el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#device" title="QMovie::device()"&gt;device&lt;/a&gt;().
Este devuelve el objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; (realmente una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; que es la clase
base de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; y de todas clases que representan dispositivos de E/S) vinculado con
la instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;. Así podemos comprobar mediante el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html#isOpen" title="QFile::isOpen()"&gt;isOpen&lt;/a&gt;() si el archivo se pudo abrir con éxito o no.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Control de la reproducción&lt;/h2&gt;
&lt;p&gt;El control de la reproducción se puede hacer mediante los &lt;em&gt;slots&lt;/em&gt;
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() y &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#stop" title="QMovie::stop()"&gt;stop&lt;/a&gt;().&lt;/p&gt;
&lt;p&gt;En el ejemplo anterior se puede observar como el &lt;em&gt;slot&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;()
es invocado exactamente de la misma manera que un método convencional para
iniciar la reproducción de la animación. Sin embargo el hecho de que los
desarrolladores de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; lo hayan declarado como un &lt;em&gt;slot&lt;/em&gt; y no como un
método nos permitiría conectarlo a una señal emitida desde otro control.&lt;/p&gt;
&lt;p&gt;Por ejemplo, si tuvieramos un botón de &lt;em&gt;play&lt;/em&gt; podríamos conectar su señal
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qabstractbutton.html#clicked" title="QAbstractButton::clicked"&gt;clicked&lt;/a&gt;() al slot &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;playButton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clicked&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;de forma que al pulsar dicho botón se inicie automáticamente la reproducción.&lt;/p&gt;
&lt;p&gt;Otro detalle a tener en cuenta es que los &lt;em&gt;slots&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;()
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#stop" title="QMovie::stop()"&gt;stop&lt;/a&gt;() indican a la instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; que inicie o detengan
la reproducción pero, una vez hecho, vuelven inmediatamente. Es decir, que no
se quedan a la espera de que la animación se reproduzca o esperan a que termine.&lt;/p&gt;
&lt;p&gt;Este es un detalle importante porque al &lt;em&gt;slot&lt;/em&gt; &lt;code&gt;on_actionOpen_triggered()&lt;/code&gt; de
nuestro ejemplo se llega a través del bucle de mensajes, cuando el sistema de
ventanas notifica a la aplicación un &lt;em&gt;click&lt;/em&gt; sobre la acción correspondiente. Si
en el &lt;em&gt;slot&lt;/em&gt; introduciésemos tareas de larga duración, la ejecución tardaría en
volver al bucle de mensajes, retrasando el momento en el que la aplicación puede
procesar nuevos eventos de los usuarios. Es decir, que si
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() se quedara a la espera y añadiéramos un botón para detener
la reproducción, este nunca funcionaría porque la aplicación no volvería al bucle
de mensajes hasta que la reproducción no hubiera terminado.&lt;/p&gt;
&lt;p&gt;Podemos comprobar esto añadiendo una espera justo después de invocar el
&lt;em&gt;slot&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QMutex&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Espera&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;segundos&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Debido a los efectos desastrosos que este tipo de esperas tienen en las aplicaciones
dirigidas por eventos, &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; no incluye funciones del tipo de &lt;code&gt;sleep()&lt;/code&gt;, &lt;code&gt;delay()&lt;/code&gt;,
&lt;code&gt;usleep()&lt;/code&gt; y &lt;code&gt;nanosleep()&lt;/code&gt;, que muchos sistemas operativos sí soportan.&lt;/p&gt;
&lt;h2&gt;Procesando la imagen frame a frame&lt;/h2&gt;
&lt;p&gt;Aunque &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; se hace cargo de mostrar la animación sin que tengamos que intervenir
de ninguna otra manera, en ocasiones puede ser interesante tener acceso a los
&lt;em&gt;frames&lt;/em&gt; de manera individualizada para poder procesarlos antes de que sean mostrados.
Por ese motivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; emite una señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;() cada vez que el &lt;em&gt;frame&lt;/em&gt;
actual cambia.&lt;/p&gt;
&lt;p&gt;Para aprovechar eso:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declaramos un &lt;em&gt;slot&lt;/em&gt; para que reciba la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;slots:&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Otros&lt;/span&gt; &lt;span class="n"&gt;slots&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;on_actionOpen_triggered&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definimos el código del &lt;em&gt;slot&lt;/em&gt; para que al ser invocado actualice la
imagen mostrada por el control &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;. En ese sentido el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setPixmap" title="QLabel::setPixmap()"&gt;setPixmap&lt;/a&gt;() permite indicar al objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; que imagen queremos
mostrar. Mientras que &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#currentPixmap" title="QMovie::currentPixmap()"&gt;currentPixmap&lt;/a&gt;() nos permite obtener el último
&lt;em&gt;frame&lt;/em&gt; del objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; en formato &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QPixmap&lt;/span&gt; &lt;span class="n"&gt;pixmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;currentPixmap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setPixmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pixmap&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Suprimimos el uso del método &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setMovie" title="QLabel::setMovie()"&gt;setMovie&lt;/a&gt;(), para que el
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; no sepa nada de nuestra animación, y conectamos la señal
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;() con nuestro nuevo slot:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;movie_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ahora podríamos introducir en el &lt;em&gt;slot&lt;/em&gt; todo aquello que nos interese hacer
sobre los &lt;em&gt;frames&lt;/em&gt; antes de mostrarlos.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; Class Reference.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/widgets-movie.html"&gt;Moviel Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/widgets-imageviewer.html"&gt;Image Viewer Example&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Sin olvidarnos de que es necesario para liberar la memoria en el destructor de la clase &lt;code&gt;MovieViewerWindow&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Esta clase es la base de todos los dispositivos de E/S, incluidos los archivos. Su
misión es proporcionar una interfaz común; mediante métodos como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html#open" title="QFile::open()"&gt;open&lt;/a&gt;(),
&lt;code&gt;close()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;seek()&lt;/code&gt;, etc.; con la que acceder a cualquier
dispositivo. De &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; heredan clases como &lt;code&gt;QBuffer&lt;/code&gt;, &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html" title="QProcess"&gt;QProcess&lt;/a&gt; o &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; que
proporcionan implementaciones concretas para cada tipo de dispositivo en particular.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="qt"></category><category term="gui"></category><category term="qmovie"></category></entry></feed>