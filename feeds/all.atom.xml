<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Sistema de Videovigilancia from Scratch</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/" rel="alternate"></link><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/feeds/all.atom.xml" rel="self"></link><id>http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/</id><updated>2013-02-13T00:00:00+00:00</updated><entry><title>Como usar QMovie en Qt</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/como-usar-qmovie-en-qt.html" rel="alternate"></link><updated>2013-02-13T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-02-13:como-usar-qmovie-en-qt.html</id><summary type="html">&lt;p&gt;&lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; trae una clase denominada &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; que facilita mostrar pequeñas
animaciones sin mucho esfuerzo.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; está diseñada para ser independiente del formato de archivo pero como
internamente depende de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qimagereader.html" title="QImageReader"&gt;QImageReader&lt;/a&gt;, sólo puede utilizarse con los que esta
última soporta (véase &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#supportedFormats" title="QMovie::supportedFormats()"&gt;supportedFormats&lt;/a&gt;()). Esto incluye GIF
animados, archivos MNG y MJPEG. Para mostrar vídeo y otros contenidos
multimedia, es mejor utilizar el &lt;em&gt;framework&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtmultimedia/multimediaoverview.html" title="Qt Multimedia"&gt;Qt Multimedia&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Primeros pasos&lt;/h2&gt;
&lt;p&gt;La forma más sencilla de usar &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; es asignar un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; a un
control &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; usando el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setMovie" title="QLabel::setMovie()"&gt;setMovie&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QMovie&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;video.mjpeg&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;donde &lt;code&gt;ui&lt;/code&gt; es el miembro de la clase que tiene asignada la instancia de la
ventana creada previamente con Qt Creator.&lt;/p&gt;
&lt;h2&gt;Nombre de archivo especificado por el usuario&lt;/h2&gt;
&lt;p&gt;No siempre ocurre que el nombre del archivo a reproducir se conozca de antemano
al desarrollar el programar. Si por ejemplo se pretende que el usuario lo
escoja de entre los disponibles en su disco duro podemos:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Crear un objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;, guardarlo en un miembro de la clase (manteniendo
 así un puntero al mismo que nos permita referenciarlo más adelante&lt;sup id="fnref:1"&gt;&lt;a class="footnote-ref" href="#fn:1" rel="footnote"&gt;1&lt;/a&gt;&lt;/sup&gt;) y asignar
 dicho objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; a &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;MovieViewerWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;QWidget&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;QMainWindow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parent&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
      &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nn"&gt;Ui::&lt;/span&gt;&lt;span class="n"&gt;MovieViewerWindow&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt; &lt;span class="n"&gt;otro&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;inicializaci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;instancia&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;movie_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;En el slot de la acción que abre el cuadro de diálogo &lt;em&gt;abrir archivo&lt;/em&gt;,
 asignar al objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; el nombre escogido por el usuario mediante el
 método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#setFileName" title="QMovie::setFileName()"&gt;setFileName&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;on_actionOpen_triggered&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Aqu&lt;/span&gt;&lt;span class="err"&gt;í&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;digo&lt;/span&gt; &lt;span class="n"&gt;que&lt;/span&gt; &lt;span class="n"&gt;abre&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;cuadro&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;di&lt;/span&gt;&lt;span class="err"&gt;á&lt;/span&gt;&lt;span class="n"&gt;logo&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="n"&gt;comprueba&lt;/span&gt; &lt;span class="n"&gt;si&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;el&lt;/span&gt; &lt;span class="n"&gt;usuario&lt;/span&gt; &lt;span class="n"&gt;seleccion&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt; &lt;span class="n"&gt;alg&lt;/span&gt;&lt;span class="err"&gt;ú&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;archivo&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;QString&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nn"&gt;QFileDialog::&lt;/span&gt;&lt;span class="n"&gt;getFileName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;

    &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setFileName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;isValid&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nn"&gt;QMessageBox::&lt;/span&gt;&lt;span class="n"&gt;critical&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Error&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
            &lt;span class="nb"&gt;tr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No se pudo abrir el archivo o el formato es inválido&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Iniciar&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;reproducci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="n"&gt;la&lt;/span&gt; &lt;span class="n"&gt;animaci&lt;/span&gt;&lt;span class="err"&gt;ó&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como se puede observar es conveniente utilizar el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#isValid" title="QMovie::isValid()"&gt;isValid&lt;/a&gt;()
para comprobar si el archivo pudo ser abierto y tiene uno de los formatos soportados.&lt;/p&gt;
&lt;p&gt;Para distinguir entre ambos tipos de error, con el objeto de mostrar al usuario
un mensaje diferente según el caso, podemos emplear el método &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#device" title="QMovie::device()"&gt;device&lt;/a&gt;().
Este devuelve el objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; (realmente una instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;&lt;sup id="fnref:2"&gt;&lt;a class="footnote-ref" href="#fn:2" rel="footnote"&gt;2&lt;/a&gt;&lt;/sup&gt; que es la clase
base de &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; y de todas clases que representan dispositivos de E/S) vinculado con
la instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;. Así podemos comprobar mediante el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html#isOpen" title="QFile::isOpen()"&gt;isOpen&lt;/a&gt;() si el archivo se pudo abrir con éxito o no.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Control de la reproducción&lt;/h2&gt;
&lt;p&gt;El control de la reproducción se puede hacer mediante los &lt;em&gt;slots&lt;/em&gt;
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() y &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#stop" title="QMovie::stop()"&gt;stop&lt;/a&gt;().&lt;/p&gt;
&lt;p&gt;En el ejemplo anterior se puede observar como el &lt;em&gt;slot&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;()
es invocado exactamente de la misma manera que un método convencional para
iniciar la reproducción de la animación. Sin embargo el hecho de que los
desarrolladores de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; lo hayan declarado como un &lt;em&gt;slot&lt;/em&gt; y no como un
método nos permitiría conectarlo a una señal emitida desde otro control.&lt;/p&gt;
&lt;p&gt;Por ejemplo, si tuvieramos un botón de &lt;em&gt;play&lt;/em&gt; podríamos conectar su señal
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qabstractbutton.html#clicked" title="QAbstractButton::clicked"&gt;clicked&lt;/a&gt;() al slot &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;playButton&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clicked&lt;/span&gt;&lt;span class="p"&gt;()),&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;()));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;de forma que al pulsar dicho botón se inicie automáticamente la reproducción.&lt;/p&gt;
&lt;p&gt;Otro detalle a tener en cuenta es que los &lt;em&gt;slots&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;()
y &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#stop" title="QMovie::stop()"&gt;stop&lt;/a&gt;() indican a la instancia de &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; que inicie o detengan
la reproducción pero, una vez hecho, vuelven inmediatamente. Es decir, que no
se quedan a la espera de que la animación se reproduzca o esperan a que termine.&lt;/p&gt;
&lt;p&gt;Este es un detalle importante porque al &lt;em&gt;slot&lt;/em&gt; &lt;code&gt;on_actionOpen_triggered()&lt;/code&gt; de
nuestro ejemplo se llega a través del bucle de mensajes, cuando el sistema de
ventanas notifica a la aplicación un &lt;em&gt;click&lt;/em&gt; sobre la acción correspondiente. Si
en el &lt;em&gt;slot&lt;/em&gt; introduciésemos tareas de larga duración, la ejecución tardaría en
volver al bucle de mensajes, retrasando el momento en el que la aplicación puede
procesar nuevos eventos de los usuarios. Es decir, que si
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;() se quedara a la espera y añadiéramos un botón para detener
la reproducción, este nunca funcionaría porque la aplicación no volvería al bucle
de mensajes hasta que la reproducción no hubiera terminado.&lt;/p&gt;
&lt;p&gt;Podemos comprobar esto añadiendo una espera justo después de invocar el
&lt;em&gt;slot&lt;/em&gt; &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#start" title="QMovie::start()"&gt;start&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;QWaitCondition&lt;/span&gt; &lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;QMutex&lt;/span&gt; &lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="nb"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mutex&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Espera&lt;/span&gt; &lt;span class="n"&gt;de&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;segundos&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Debido a los efectos desastrosos que este tipo de esperas tienen en las aplicaciones
dirigidas por eventos, &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" title="Proyecto Qt"&gt;Qt&lt;/a&gt; no incluye funciones del tipo de &lt;code&gt;sleep()&lt;/code&gt;, &lt;code&gt;delay()&lt;/code&gt;,
&lt;code&gt;usleep()&lt;/code&gt; y &lt;code&gt;nanosleep()&lt;/code&gt;, que muchos sistemas operativos sí soportan.&lt;/p&gt;
&lt;h2&gt;Procesando la imagen frame a frame&lt;/h2&gt;
&lt;p&gt;Aunque &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; se hace cargo de mostrar la animación sin que tengamos que intervenir
de ninguna otra manera, en ocasiones puede ser interesante tener acceso a los
&lt;em&gt;frames&lt;/em&gt; de manera individualizada para poder procesarlos antes de que sean mostrados.
Por ese motivo &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; emite una señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;() cada vez que el &lt;em&gt;frame&lt;/em&gt;
actual cambia.&lt;/p&gt;
&lt;p&gt;Para aprovechar eso:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Declaramos un &lt;em&gt;slot&lt;/em&gt; para que reciba la señal &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;():&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;slots:&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;Otros&lt;/span&gt; &lt;span class="n"&gt;slots&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;on_actionOpen_triggered&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt;
    &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Definimos el código del &lt;em&gt;slot&lt;/em&gt; para que al ser invocado actualice la
imagen mostrada por el control &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;. En ese sentido el método
&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setPixmap" title="QLabel::setPixmap()"&gt;setPixmap&lt;/a&gt;() permite indicar al objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; que imagen queremos
mostrar. Mientras que &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#currentPixmap" title="QMovie::currentPixmap()"&gt;currentPixmap&lt;/a&gt;() nos permite obtener el último
&lt;em&gt;frame&lt;/em&gt; del objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; en formato &lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qpixmap.html" title="QPixmap"&gt;QPixmap&lt;/a&gt;:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="nn"&gt;MovieViewerWindow::&lt;/span&gt;&lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;QPixmap&lt;/span&gt; &lt;span class="n"&gt;pixmap&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;currentPixmap&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setPixmap&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pixmap&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Suprimimos el uso del método &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html#setMovie" title="QLabel::setMovie()"&gt;setMovie&lt;/a&gt;(), para que el
objeto &lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/qlabel.html" title="QLabel"&gt;QLabel&lt;/a&gt; no sepa nada de nuestra animación, y conectamos la señal
&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt;::&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html#updated" title="QMovie::updated()"&gt;updated&lt;/a&gt;() con nuestro nuevo slot:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;    &lt;span class="n"&gt;movie_&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QMovie&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="sr"&gt;//&lt;/span&gt; &lt;span class="n"&gt;ui&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setMovie&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;connect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;movie_&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;this&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SLOT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;on_movie_updated&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;const&lt;/span&gt; &lt;span class="n"&gt;QRect&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Ahora podríamos introducir en el &lt;em&gt;slot&lt;/em&gt; todo aquello que nos interese hacer
sobre los &lt;em&gt;frames&lt;/em&gt; antes de mostrarlos.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtgui/qmovie.html" title="QMovie"&gt;QMovie&lt;/a&gt; Class Reference.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/widgets-movie.html"&gt;Moviel Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/doc/qt-5.0/qtwidgets/widgets-imageviewer.html"&gt;Image Viewer Example&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="footnote"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn:1"&gt;
&lt;p&gt;Sin olvidarnos de que es necesario para liberar la memoria en el destructor de la clase &lt;code&gt;MovieViewerWindow&lt;/code&gt;.&amp;#160;&lt;a class="footnote-backref" href="#fnref:1" rev="footnote" title="Jump back to footnote 1 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id="fn:2"&gt;
&lt;p&gt;Esta clase es la base de todos los dispositivos de E/S, incluidos los archivos. Su
misión es proporcionar una interfaz común; mediante métodos como &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html#open" title="QFile::open()"&gt;open&lt;/a&gt;(),
&lt;code&gt;close()&lt;/code&gt;, &lt;code&gt;read()&lt;/code&gt;, &lt;code&gt;write()&lt;/code&gt;, &lt;code&gt;seek()&lt;/code&gt;, etc.; con la que acceder a cualquier
dispositivo. De &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qiodevice.html" title="QIODevice"&gt;QIODevice&lt;/a&gt; heredan clases como &lt;code&gt;QBuffer&lt;/code&gt;, &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qprocess.html" title="QProcess"&gt;QProcess&lt;/a&gt; o &lt;a href="http://qt-project.org/doc/qt-5.0/qtcore/qfile.html" title="QFile"&gt;QFile&lt;/a&gt; que
proporcionan implementaciones concretas para cada tipo de dispositivo en particular.&amp;#160;&lt;a class="footnote-backref" href="#fnref:2" rev="footnote" title="Jump back to footnote 2 in the text"&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</summary><category term="qt"></category><category term="gui"></category><category term="qmovie"></category></entry><entry><title>Proyecto Qt. Framework de desarrollo de aplicaciones</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/proyecto-qt-framework-de-desarrollo-de-aplicaciones.html" rel="alternate"></link><updated>2013-01-29T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-29:proyecto-qt-framework-de-desarrollo-de-aplicaciones.html</id><summary type="html">&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; es una &lt;em&gt;framework&lt;/em&gt; multiplataforma en C++ de desarrollo de aplicaciones. Se
utiliza fundamentalmente para desarrollar aplicaciones con interfaz gráfica,
gracias al conjunto de controles independientes de la plataforma que ofrece,
aunque también es usado para crear herramientas de linea de comando o consolas
de gestión para servicios.&lt;/p&gt;
&lt;p&gt;Esto último es debido a que el API de la librería cuenta con clases para:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acceso a bases de datos mediante SQL.&lt;/li&gt;
&lt;li&gt;Procesamiento de XML.&lt;/li&gt;
&lt;li&gt;Gestión de hilos.&lt;/li&gt;
&lt;li&gt;Comunicaciones por red.&lt;/li&gt;
&lt;li&gt;Manejo de archivos.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;a parte de las clases ya mencionadas para el desarrollo de aplicaciones con
interfaz gráfica. Todo esto convierte a &lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; en un &lt;em&gt;framework&lt;/em&gt; muy valorado a la
hora de desarrollar aplicaciones multiplataforma en C++.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; está disponible para sistemas tipo UNIX (Linux, BSD, UNIX, etc.) con
servidor gráfico X Window System, Apple Mac OS X, Microsoft Windows y sistemas
Linux embebidos. Además se puede hacer uso de la librería desde lenguajes
diferentes a C++ gracias al empleo de &lt;a href="http://es.wikipedia.org/wiki/Bindings"&gt;bindings&lt;/a&gt;:
Python, Java, Ruby, Ada, Pascal, Perl, PHP, Haskell, Lua, D, .NET, etc.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://qt-project.org/" title="Qt Proyect"&gt;Qt&lt;/a&gt; está disponible bajo licencias GPLv3, LGPLv2 y privativa comercial.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://qt-project.org/"&gt;Qt Proyect&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://en.wikipedia.org/wiki/Qt_(framework)"&gt;Wikipedia&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="qt"></category><category term="gui"></category></entry><entry><title>Crea tu propia distro de Linux con Yocto</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/crea-tu-propia-distro-de-linux-con-yocto.html" rel="alternate"></link><updated>2013-01-22T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-22:crea-tu-propia-distro-de-linux-con-yocto.html</id><summary type="html">&lt;p&gt;El objetivo de este artículo es explicar paso a paso como se puede utilizar
el proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; para crear nuestra propia distribución de Linux. Primero
construiremos una para ejecutarla en &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt; y después otra para nuestra
Raspberry Pi.&lt;/p&gt;
&lt;h2&gt;Inicio rápido&lt;/h2&gt;
&lt;p&gt;El inicio rápido con el proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; está perfectamente documentado en
&lt;a href="http://www.yoctoproject.org/docs/1.0/yocto-quick-start/yocto-project-qs.html" title="Yocto Project Quick Start"&gt;Yocto Project Quick Start&lt;/a&gt;. En cualquier caso aquí resumiremos los pasos
deteniéndonos en los de mayor importancia.&lt;/p&gt;
&lt;h3&gt;Requisitos&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Una distribución de Linux.&lt;/strong&gt; En nuestro caso, por simplicidad, cualquiera
de las basadas en Debian.&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Paquetes de desarrollo.&lt;/strong&gt; En el sistema deben estar instalados una serie
de paquetes utilizados habitualmente en tareas de desarrollo. En un sistema
basado en Debian deberían poder instalarse con el siguiente comando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;install&lt;/span&gt; &lt;span class="n"&gt;sed&lt;/span&gt; &lt;span class="n"&gt;wget&lt;/span&gt; &lt;span class="n"&gt;cvs&lt;/span&gt; &lt;span class="n"&gt;subversion&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;core&lt;/span&gt; &lt;span class="n"&gt;coreutils&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;unzip&lt;/span&gt; &lt;span class="n"&gt;texi2html&lt;/span&gt; &lt;span class="n"&gt;texinfo&lt;/span&gt; &lt;span class="n"&gt;libsdl1&lt;/span&gt;&lt;span class="mf"&gt;.2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;docbook&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utils&lt;/span&gt; &lt;span class="n"&gt;gawk&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;python&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pysqlite2&lt;/span&gt; &lt;span class="n"&gt;diffstat&lt;/span&gt; &lt;span class="n"&gt;help2man&lt;/span&gt; &lt;span class="n"&gt;make&lt;/span&gt; &lt;span class="n"&gt;gcc&lt;/span&gt; &lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt; &lt;span class="n"&gt;desktop&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;utils&lt;/span&gt; &lt;span class="n"&gt;chrpath&lt;/span&gt; &lt;span class="n"&gt;libgl1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mesa&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="n"&gt;libglu1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;mesa&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;dev&lt;/span&gt; &lt;span class="o"&gt;\&lt;/span&gt;
&lt;span class="n"&gt;mercurial&lt;/span&gt; &lt;span class="n"&gt;autoconf&lt;/span&gt; &lt;span class="n"&gt;automake&lt;/span&gt; &lt;span class="n"&gt;groff&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Una versión del proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt;.&lt;/strong&gt; Las distintas versiones pueden
descargarse desde la dirección:&lt;/p&gt;
&lt;p&gt;&lt;a href="http://downloads.yoctoproject.org/releases/yocto/"&gt;http://downloads.yoctoproject.org/releases/yocto/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Construir una imagen de sistema Linux&lt;/h3&gt;
&lt;p&gt;El proceso de construir una imagen genera una distribución de Linux completa,
incluyendo las herramienta de desarrollo para la misma:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Descargar el sistema de construcción &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Poky&lt;/a&gt; de la última versión del
proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; y descomprimirla:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;wget&lt;/span&gt; &lt;span class="n"&gt;http:&lt;/span&gt;&lt;span class="sr"&gt;//&lt;/span&gt;&lt;span class="n"&gt;downloads&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;yoctoproject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;org&lt;/span&gt;&lt;span class="sr"&gt;/releases/&lt;/span&gt;&lt;span class="n"&gt;yocto&lt;/span&gt;&lt;span class="sr"&gt;/yocto-1.3/&lt;/span&gt;&lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bz2&lt;/span&gt;
&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;tar&lt;/span&gt; &lt;span class="n"&gt;jxf&lt;/span&gt; &lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tar&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bz2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Crear el directorio &lt;code&gt;raspberry-pi-build&lt;/code&gt; donde construir la imagen y
configurar las variables de entorno necesarias:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;source&lt;/span&gt; &lt;span class="n"&gt;poky&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;danny&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;oe&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;env&lt;/span&gt; &lt;span class="n"&gt;raspberry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Como las variables de entorno configuradas por este comando se pierden al
 cerrar la shell, en caso de que eso ocurra o de abandonar la sesión sería
 necesario volver a ejecutar este comando antes de continuar.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construir la imagen:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;bitbake&lt;/span&gt; &lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;minimal&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;La imagen construida puede ejecutarse en &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt; de la siguiente manera:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;runqemu&lt;/span&gt; &lt;span class="n"&gt;qemux86&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y en unos segundos tendremos acceso a la consola de nuestra nueva distribución.&lt;/p&gt;
&lt;h3&gt;Optimizando la construcción&lt;/h3&gt;
&lt;p&gt;En el archivo &lt;code&gt;conf/local.conf&lt;/code&gt; del directorio &lt;code&gt;raspberry-pi-build&lt;/code&gt; se pueden
definir algunos parámetros que pueden reducir el tiempo necesario para
construir la imagen si se dispone de un sistema multi-núcleo.&lt;/p&gt;
&lt;p&gt;Si se tienen &lt;code&gt;N&lt;/code&gt; núcleos, es conveniente descomentar las variables &lt;code&gt;BB_NUMBER_THREADS&lt;/code&gt;
y &lt;code&gt;PARALLEL_MAKE&lt;/code&gt; y asignarle &lt;code&gt;N + 1&lt;/code&gt;. Por ejemplo, con 8 núcleos el valor
debería ser 9:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;BB_NUMBER_THREADS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;9&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;PARALLEL_MAKE&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;-j 9&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Crear una distribución para Raspberry Pi&lt;/h2&gt;
&lt;p&gt;El ejemplo estándar del proyecto &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Yocto&lt;/a&gt; se construye por defecto para la arquitectura
&lt;strong&gt;qemux86&lt;/strong&gt;. En el caso de querer compilar para otro sistema sólo es necesario añadir
una capa que incorpore los archivos de configuración necesarios.&lt;/p&gt;
&lt;p&gt;En nuestro caso dicha capa es &lt;strong&gt;meta-raspberrypi&lt;/strong&gt;, una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; que agrupa todos los
metadatos necesarios para construir para dispositivos Raspberry Pi. Fundamentalmente
contiene configuraciones para el núcleo y opciones para la arquitectura.&lt;/p&gt;
&lt;p&gt;Estos son los pasos para incorporarla a nuestro proyecto:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Clonar localmente el repositorio &lt;strong&gt;meta-raspberrypi&lt;/strong&gt; fuera del directorio
&lt;code&gt;raspberry-pi-build&lt;/code&gt;.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;git&lt;/span&gt; &lt;span class="n"&gt;clone&lt;/span&gt; &lt;span class="n"&gt;https:&lt;/span&gt;&lt;span class="sr"&gt;//gi&lt;/span&gt;&lt;span class="n"&gt;thub&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="sr"&gt;/djwillis/m&lt;/span&gt;&lt;span class="n"&gt;eta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;raspberrypi&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;git&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cambiar a la rama &lt;strong&gt;danny&lt;/strong&gt; que es la de la versión de &lt;a href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" title="Yocto, Poky y BitBake"&gt;Poky&lt;/a&gt; que estamos usando:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;meta&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;raspberrypi&lt;/span&gt;
&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;git&lt;/span&gt; &lt;span class="n"&gt;checkout&lt;/span&gt; &lt;span class="n"&gt;danny&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buscar la variable &lt;code&gt;BBLAYERS&lt;/code&gt; en &lt;code&gt;raspberry-pi-build/conf/bblayers.conf&lt;/code&gt; y añadir
al final la ruta hasta el repositorio de la capa &lt;strong&gt;meta-raspberrypi&lt;/strong&gt; para incluirla
en el proceso de construcción. Por ejemplo:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;BBLAYERS&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot; \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/poky-danny-8.0/meta \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/poky-danny-8.0/meta-yocto \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/poky-danny-8.0/meta-yocto-bsp \&lt;/span&gt;
&lt;span class="s"&gt;  /home/usuario/meta-raspberry-pi \&lt;/span&gt;
&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Buscar la variable &lt;code&gt;MACHINE&lt;/code&gt; en &lt;code&gt;raspberry-pi-build/conf/local.conf&lt;/code&gt; e indicar que
la máquina de destino de la imagen es &lt;code&gt;raspberrypi&lt;/code&gt;&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="n"&gt;MACHINE&lt;/span&gt; &lt;span class="p"&gt;?&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;raspberrypi&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Construir la imagen:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;raspberry&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;build&lt;/span&gt;
&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;bitbake&lt;/span&gt; &lt;span class="n"&gt;rpi&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;basic&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Esta imagen incluye un servidor &lt;strong&gt;SSH&lt;/strong&gt; y un &lt;em&gt;splash&lt;/em&gt; de Raspberry Pi durante el arranque.
Mientras que la imagen alternativa &lt;code&gt;rpi-hwup-image&lt;/code&gt; no contiene ninguna de las dos cosas.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transferir la imagen construida a la tarjeta SD.&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$&lt;/span&gt; &lt;span class="nv"&gt;sudo&lt;/span&gt; &lt;span class="n"&gt;dd&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;tmp&lt;/span&gt;&lt;span class="sr"&gt;/deploy/im&lt;/span&gt;&lt;span class="n"&gt;ages&lt;/span&gt;&lt;span class="sr"&gt;/rpi-basic-image-raspberrypi.rpi-sdimg of=/&lt;/span&gt;&lt;span class="n"&gt;ruta&lt;/span&gt;&lt;span class="sr"&gt;/a/&lt;/span&gt;&lt;span class="n"&gt;la&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;sd&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;y probarla en el dispositivo.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/yocto-quick-start/yocto-project-qs.html"&gt;Yocto Project Quick Start&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://pokylinux.org/doc/poky-handbook.html"&gt;Poky HandBook&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.pimpmypi.com/blog/blogPost.php?blogPostID=7"&gt;Build a Custom Raspberry Pi Distro with OpenEmbedded &amp;amp; Yocto&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="yocto"></category><category term="poky"></category><category term="distribución"></category></entry><entry><title>Cámara CF7670C-V2</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/camara-cf7670c-v2.html" rel="alternate"></link><updated>2013-01-13T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:camara-cf7670c-v2.html</id><summary type="html">&lt;p&gt;Los módulos de cámara CF7670C y CF7670C-V2 combinan el sensor CMOS &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt;
con una memoria FIFO &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fV3gyQ3dfTkRETDg/edit" title="FIFO Averlogic AL422"&gt;Averlogic AL422&lt;/a&gt; de 3Mb.&lt;/p&gt;
&lt;p&gt;&lt;img src="https://drive.google.com/uc?export=download&amp;confirm=&amp;id=0B4Cklvu_Zw9fS20tR1lnYmFHZVk" width="300" style="float:right;margin:0 0px 10px 0"&gt;&lt;/p&gt;
&lt;p&gt;La idea es que las imágenes capturadas por el sensor se almacenen en la memoria FIFO,
dando tiempo a la CPU externa a recuperarlas al ritmo que le sea posible.&lt;/p&gt;
&lt;p&gt;Las principales características del sensor &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt; son:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolución de 640x480 pixels (VGA).&lt;/li&gt;
&lt;li&gt;Hasta 30 fps para resolución VGA.&lt;/li&gt;
&lt;li&gt;Formatos de salida (8 bits):&lt;ul&gt;
&lt;li&gt;&lt;a href="http://es.wikipedia.org/wiki/YUV" title="YUV"&gt;YUV&lt;/a&gt;/&lt;a href="http://es.wikipedia.org/wiki/YCbCr" title="YCbCr"&gt;YCbCr&lt;/a&gt; 4:2:2&lt;/li&gt;
&lt;li&gt;RGB 565/555/444&lt;/li&gt;
&lt;li&gt;GRB 4:2:2&lt;/li&gt;
&lt;li&gt;Raw RGB Data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Modo de &lt;a href="http://es.wikipedia.org/wiki/Escaneo_progresivo"&gt;escaneo progresivo&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;Interfaz de control mediante &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fTThIUmdRYUw4TXM/edit" title="Serial Camera Control Bus"&gt;SCCB&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tal y como se puede observar en el &lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNFJ3QTdaY284Znc/edit" title="CF7670C-V2 Camera Module Schematic"&gt;esquemático&lt;/a&gt; del módulo, tanto el bus
&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fTThIUmdRYUw4TXM/edit" title="Serial Camera Control Bus"&gt;SCCB&lt;/a&gt; (que prácticamente es un &lt;a href="http://es.wikipedia.org/wiki/I2C" title="I²C (Inter-Integrated Circuit)"&gt;I2C&lt;/a&gt;) como las líneas del OV7670 que informan
del barrido vertical (VSYNC) y horizontal (HREF) están disponibles para que
sean accesibles a una CPU externa.&lt;/p&gt;
&lt;p&gt;Por el contrario, las líneas de datos del OV7670 están conectadas al AL422
para almacenar en el la imagen capturada. Es la salida de esta memoria FIFO,
así como las líneas necesarias para controlar la lectura de la misma, las que
son  accesibles desde el conector del módulo.&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fanZqcWUyVUQxaTg/edit" title="Sensor CMOS OmniVision OV7670"&gt;OmniVision OV7670&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fV3gyQ3dfTkRETDg/edit" title="FIFO Averlogic AL422"&gt;Averlogic AL422&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNFJ3QTdaY284Znc/edit"&gt;Esquemático del módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9fNzFIbml0dHNXaTQ/edit"&gt;Pines del módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/uc?export=download&amp;amp;confirm=&amp;amp;id=0B4Cklvu_Zw9fS3c4VTRTNHJvMEU"&gt;Controlador de ejemplo para el módulo CF7670C-V2&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/a/isaatc.ull.es/file/d/0B4Cklvu_Zw9feEVCU3BzZHY4SEk/edit"&gt;OV7670 Implementation Guide&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;</summary><category term="cf7670c"></category><category term="i2c"></category><category term="ov7670"></category><category term="al422"></category></entry><entry><title>LCD 1.8" SPI (ST7735)</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/lcd-18-spi-st7735.html" rel="alternate"></link><updated>2013-01-13T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:lcd-18-spi-st7735.html</id><summary type="html">&lt;p&gt;El módulo en cuestión tiene las siguientes características:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://drive.google.com/uc?export=download&amp;confirm=&amp;id=0B4Cklvu_Zw9fUmF1d0YzNzMwNG8" style="float:right;margin:0 0px 10px 0"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Resolución de 128x160 pixels.&lt;/li&gt;
&lt;li&gt;262K colores.&lt;/li&gt;
&lt;li&gt;Retro-iluminación LED.&lt;/li&gt;
&lt;li&gt;Interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; a través del chip controlador ST7735R.&lt;/li&gt;
&lt;li&gt;Compatible con lógica TTL de 3.3 y 5v.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El corazón del módulo es el chip controlador ST7735. Este se conecta por un lado
a la LCD propiamente dicha y por el otro ofrece una interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; a la que
se puede conectar una CPU externa. Los datos a mostrar se pueden almacenar
en una RAM interna con capacidad para 132x162x18 bits.&lt;/p&gt;
&lt;p&gt;Las aplicaciones pueden acceder directamente al módulo a través de la
interfaz de programación &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; que el núcleo puede hacer pública al espacio de
usuario. Sin embargo una de las características más interesantes de este
módulo es la existencia de un &lt;a href="http://es.wikipedia.org/wiki/Framebuffer" title="Framebuffer"&gt;controlador de vídeo&lt;/a&gt; para sistemas
Linux. Haciendo uso del mismo las aplicaciones pueden utilizar la pantalla LCD
como si de una tarjeta gráfica convencional se trata, ignorando la interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/file/d/0B4Cklvu_Zw9fMmM3U0I2NU53Y3c/edit"&gt;Hoja de datos Sitronix ST7735 262K Color Single-Chip TFT Controller/Driver&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://drive.google.com/uc?export=download&amp;amp;confirm=&amp;amp;id=0B4Cklvu_Zw9fT2hjVmpIQ2x0NVU"&gt;Librería para Arduino y programas de ejemplo&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ohporter/linux-am33x/blob/st7735fb/drivers/video/st7735fb.c"&gt;FB driver for ST7735 LCD controller&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="lcd"></category><category term="spi"></category><category term="st7735"></category></entry><entry><title>Raspberry Pi</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/raspberry-pi.html" rel="alternate"></link><updated>2013-01-13T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-13:raspberry-pi.html</id><summary type="html">&lt;p&gt;Una Raspberry Pi es una placa computadora (&lt;a href="http://en.wikipedia.org/wiki/Single-board_computer" title="Single-board Computer"&gt;SBC&lt;/a&gt;) de bajo coste que incluye:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://upload.wikimedia.org/wikipedia/commons/thumb/3/3d/RaspberryPi.jpg/320px-RaspberryPi.jpg" style="float:right;margin:0 0px 10px 0"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Un &lt;a href="http://es.wikipedia.org/wiki/System_on_a_chip" title="System on a Chip"&gt;SOC&lt;/a&gt; Broadcom BCM2835, que contiene una CPU &lt;a href="http://en.wikipedia.org/wiki/ARM11" title="ARM11"&gt;ARM11&lt;/a&gt;76JZF-S a 700 MHz y
una GPU &lt;a href="http://en.wikipedia.org/wiki/VideoCore" title="VideoCore"&gt;VideoCore&lt;/a&gt; IV.&lt;/li&gt;
&lt;li&gt;512 MB de memoria RAM (en la versión B de Raspberry Pi, 256 MB en la versión A)
instalada sobre la CPU.&lt;/li&gt;
&lt;li&gt;Una ranura de tarjetas SD/MMC/SDIO para el almacenamiento no volátil.&lt;/li&gt;
&lt;li&gt;1 puerto Ethernet de 10/100Mb.&lt;/li&gt;
&lt;li&gt;2 puertos USB 2.0.&lt;/li&gt;
&lt;li&gt;1 puerto micro USB de alimentación.&lt;/li&gt;
&lt;li&gt;1 puerto tipo A de salida HDMI 1.3.a&lt;/li&gt;
&lt;li&gt;1 conector RCA de salida de vídeo compuesto.&lt;/li&gt;
&lt;li&gt;1 conector jack estéreo de 3.5mm para la salida de audio.&lt;/li&gt;
&lt;li&gt;1 conector de expansión de 26 pines con:&lt;ul&gt;
&lt;li&gt;8 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;2 puertos seriales (&lt;a href="http://es.wikipedia.org/wiki/Universal_Asynchronous_Receiver-Transmitter" title="Universal Asynchronous Receiver-Transmitter"&gt;UART&lt;/a&gt;) a 3.3v TTL o 2 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;1 interfaz &lt;a href="http://es.wikipedia.org/wiki/I2C" title="I²C (Inter-Integrated Circuit)"&gt;I2C&lt;/a&gt; (3.3v) o 2 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;1 interfaz &lt;a href="http://es.wikipedia.org/wiki/SPI" title="Serial Peripheral Interface"&gt;SPI&lt;/a&gt; (3.3v) o 5 puertos &lt;a href="http://en.wikipedia.org/wiki/General_Purpose_Input/Output" title="General-Purpose Input/Output"&gt;GPIO&lt;/a&gt; a 3.3v.&lt;/li&gt;
&lt;li&gt;Diversos pines a 3.3v, 5v y tierra (GND).&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;entre otros componentes. En la web del proyecto colaborativo &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt;
hay disponible más información sobre todo este &lt;a href="http://elinux.org/RPi_Hardware" title="RPi Hardware"&gt;hardware&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Respecto al software la &lt;a href="http://www.raspberrypi.org/about" title="Raspberry Pi Foundation"&gt;Fundación Raspberry Pi&lt;/a&gt; da soporte para las distribuciones
&lt;a href="http://www.raspbian.org/" title="Raspbian"&gt;Raspbian&lt;/a&gt; (derivada de Debian), &lt;a href="http://es.wikipedia.org/wiki/RISC_OS"&gt;RISC OS&lt;/a&gt;
y Arch Linux y promueve principalmente el aprendizaje de los lenguajes de
programación &lt;a href="http://es.wikipedia.org/wiki/Python" title="Lenguage de programación Python"&gt;Python&lt;/a&gt; y &lt;a href="http://es.wikipedia.org/wiki/Scratch_(lenguaje_de_programaci%C3%B3n)" title="Lenguage de programación Scratch"&gt;Scratch&lt;/a&gt; con &lt;a href="http://www.raspberrypi.org/archives/2965"&gt;fines educativos&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Otra organización que se ha volcado en Raspberry Pi es &lt;a href="http://www.adafruit.com/blog/category/raspberry-pi/" title="Adafruit - Raspberry Pi"&gt;Adafruit&lt;/a&gt;. Esta compañía
en la actualidad provee &lt;a href="https://www.adafruit.com/raspberrypi"&gt;productos&lt;/a&gt; relacionados,
&lt;a href="http://learn.adafruit.com/category/raspberry-pi"&gt;formación&lt;/a&gt;, su propia
distribución &lt;a href="http://learn.adafruit.com/adafruit-raspberry-pi-educational-linux-distro"&gt;Adafruit Raspberry Pi Educational Linux Distro&lt;/a&gt;,
que tiene algunas ventajas respecto a las oficiales, y el
entorno de desarrollo &lt;a href="http://learn.adafruit.com/webide/"&gt;Raspberry Pi WebIDE&lt;/a&gt;
basado en web para crear fácilmente aplicaciones en &lt;a href="http://es.wikipedia.org/wiki/Python" title="Lenguage de programación Python"&gt;Python&lt;/a&gt;, Ruby o JavaScript.&lt;/p&gt;
&lt;h2&gt;Referencias adicionales&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://downloads.raspberrypi.org/Raspberry_Pi_Education_Manual.pdf"&gt;Raspberry Pi Educational Manual&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/RPi_Hardware" title="RPi Hardware"&gt;RPi Hardware&lt;/a&gt; en &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/RPi_Low-level_peripherals"&gt;RPi Low-level periperals&lt;/a&gt; en &lt;a href="http://elinux.org/RPi_Hub" title="RPi Hub"&gt;Raspberry Pi Wiki&lt;/a&gt; (incluye el detalle del conector de expasión).&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf"&gt;BCM2835 ARM Peripherals&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://infocenter.arm.com/help/topic/com.arm.doc.ddi0301h/DDI0301H_arm1176jzfs_r0p7_trm.pdf"&gt;ARM1176JZF-S Technical Reference Manual&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.raspberrypi.org/wp-content/uploads/2012/10/Raspberry-Pi-R2.0-Schematics-Issue2.2_027.pdf"&gt;Raspberry Pi 2.0 Schematics&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="rpi"></category><category term="raspberry pi"></category><category term="arm"></category><category term="gpio"></category><category term="videocore"></category><category term="broadcom"></category></entry><entry><title>Yocto, Poky y BitBake</title><link href="http://ull-etsii-sistemas-operativos.github.com/videovigilancia-blog/yocto-poky-y-bitbake.html" rel="alternate"></link><updated>2013-01-10T00:00:00+00:00</updated><author><name>Jesús Torres</name></author><id>tag:ull-etsii-sistemas-operativos.github.com/videovigilancia-blog,2013-01-10:yocto-poky-y-bitbake.html</id><summary type="html">&lt;p&gt;El proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; proporciona a los desarrolladores de sistemas empotrados
Linux un punto de partida para generar distribuciones personalizadas para
sus productos. Una de las piezas clave del proyecto es el sistema de
construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, que a su vez se apoya en &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt;, una herramienta de
construcción de paquetes al estilo de
&lt;a href="http://es.wikipedia.org/wiki/Portage_(software)"&gt;Portage&lt;/a&gt; de
&lt;a href="http://www.gentoo.org/"&gt;Gentoo&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;El proyecto Yocto&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; está financiado por la &lt;a href="http://www.linuxfoundation.org/"&gt;Linux Foundation&lt;/a&gt;.
Su principal objetivo es desarrollar herramientas que ayuden a los desarrolladores
a crear sus propias distribuciones de Linux, sea cual sea el hardware sobre el que
van a correr. Entre los proyectos desarrollados en el seno de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; están:
el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;, el sistema de
&lt;a href="http://es.wikipedia.org/wiki/Integraci%C3%B3n_continua"&gt;integración continua&lt;/a&gt;
&lt;a href="http://autobuilder.yoctoproject.org/"&gt;Autobuiler&lt;/a&gt; y la librería de sistema
&lt;a href="http://www.eglibc.org/"&gt;Embedded GLIBC (EGLIBC)&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Además, cuando se crea una distribución con &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, la herramienta de construcción
crea un SDK de desarrollo de aplicaciones adaptado a dicha distribución. Este
SDK puede conectarse al IDE &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; o puede usarse desde la línea de comandos.&lt;/p&gt;
&lt;h2&gt;El sistema de construcción Poky&lt;/h2&gt;
&lt;p&gt;Uno de los componentes centrales de &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; es el sistema de construcción &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.
Su responsabilidad fundamental es la construcción de imágenes de sistemas de
archivos de sistemas Linux. Estos pueden incluir diferentes productos de software:
Linux, X11, Matchbox, GTK+, Pimlico, Clutter, D-BUS, etc.&lt;/p&gt;
&lt;p&gt;Aunque se pueden generar diferentes tipos de imágenes según el dispositivo donde
va a ser almacenada, el proyecto ejemplo estándar lo hace para el emulador &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;
y para placas de referencia reales de los fabricantes, para cada una de las
arquitecturas soportadas. Esta habilidad de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; lo hace especialmente
apropiado como plataforma de pruebas y de desarrollo de software para empotrados.&lt;/p&gt;
&lt;p&gt;Un proyecto similar a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, que también es un sistema de construcción
para sistemas Linux empotrados. &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; deriva de un proyecto para crear
una rama estabilizada de &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, limitando el software disponible a unos
pocos paquetes, de entre los miles de los que dispone &lt;a href="http://www.openembedded.org/" title="OpenEmbedded"&gt;OpenEmbedded&lt;/a&gt;, así como el número
de arquitecturas soportadas. Con el tiempo esta rama evolucionó añadiendo
el componente de &lt;a href="http://www.eclipse.org/" title="Eclipse IDE"&gt;Eclipse&lt;/a&gt; y la generación de imágenes para &lt;a href="http://wiki.qemu.org/" title="QEMU"&gt;QEMU&lt;/a&gt;, entre otras cosas.
Esto dio origen a &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;El núcleo central de &lt;a href="http://www.pokylinux.org/" title="Poky Plataform Builder"&gt;Poky&lt;/a&gt; es la herramienta de construcción &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; junto
con una colección de archivos de configuración de diversos tipos que definen
todo lo necesario para construir la imagen del sistema Linux.&lt;/p&gt;
&lt;h2&gt;La herramienta de construcción BitBake&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; es básicamente un ejecutor de tareas. Su función es leer los archivos
de configuración que definen el proyecto; establecer que tareas deben ser realizadas
y en que orden, obviamente en función de las dependencias y para maximizar la eficiencia
(por ejemplo primero se intentan ejecutar las que son dependencias comunes a otras tareas)
y finalmente ejecutarlas.&lt;/p&gt;
&lt;p&gt;Los tipos de archivos de configuración que maneja &lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; son:&lt;/p&gt;
&lt;dl&gt;
 &lt;dt&gt;Recetas (.bb)&lt;/dt&gt;
 &lt;dd&gt;Contienen información acerca de un componente de software concreto. Entre
 dicha información, por ejemplo, podemos destacar: desde donde descargar los
 parches para las fuentes, que configuraciones deben ser aplicadas antes de
 la compilación, como se compila el componente y como se empaqueta el resultado.&lt;/dd&gt;
 &lt;dt&gt;Clases (.bbclass)&lt;/dt&gt;
 &lt;dd&gt;Contienen información que es interesante compartir entre distintas recetas.
 Por ejemplo la clase **autotools**, que contiene configuraciones comunes para
 cualquier aplicación que utiliza la herramienta **autotools**.&lt;/dd&gt;
 &lt;dt&gt;Configuraciones (.conf)&lt;/dt&gt;
 &lt;dd&gt;Define diversas variables de configuración que controlan lo que Poky va
 a hacer. Esto incluye configuraciones específicas de la maquina, opciones de
 configuración de la distribución, ajustes del compilador, configuraciones de
 usuario, etc.&lt;/dd&gt;
&lt;/dl&gt;

&lt;p&gt;&lt;a href="http://en.wikipedia.org/wiki/BitBake" title="BitBake"&gt;BitBake&lt;/a&gt; puede combinar varios de estos archivos en los se denomina como &lt;strong&gt;capas&lt;/strong&gt;.
Una capa es un agrupamiento de recetas que proporciona algún tipo de funcionalidad
adicional. Pueden ser un &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para un nuevo dispositivo, tipos de imágenes
adicionales o software no incluido en Poky.&lt;/p&gt;
&lt;p&gt;Los mismos metadatos principales del proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt;, &lt;strong&gt;meta-yocto&lt;/strong&gt;, son por si
mismos una capa aplicada sobre la capa de metadatos OE-Core que añade software
adicional y tipos de imágenes a esta última.&lt;/p&gt;
&lt;p&gt;Un ejemplo de como funciona esto se puede ver al crear un dispositivo &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;
(Network-attached Storage) para la CPU Intel E660
(&lt;a href="http://www.intel.com/p/es_XL/embedded/hwsw/hardware/atom-e6xx/overview"&gt;Crown Bay&lt;/a&gt;)
usando x32, el nuevo &lt;a href="http://en.wikipedia.org/wiki/Application_binary_interface" title="Application binary interface"&gt;ABI&lt;/a&gt; nativo de 32 bits para procesadores x86-64:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;En el nivel más bajo colocaríamos una capa &lt;a href="http://en.wikipedia.org/wiki/Board_support_package" title="Board Support Package"&gt;BSP&lt;/a&gt; para Crown Bay que activaría
 funcionalidades específicas del hardware de estos procesadores.
 Esta capa, por ejemplo, incluiría los drivers de vídeo.&lt;/li&gt;
&lt;li&gt;Como queremos utilizar x32, añadiríamos posteriormente la capa &lt;strong&gt;meta-x32&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;La funcionalidad de &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt; se incorporaría añadiendo la capa &lt;strong&gt;meta-bayron&lt;/strong&gt;,
 que el mismo proyecto &lt;a href="https://www.yoctoproject.org/" title="Yocto Project"&gt;Yocto&lt;/a&gt; nos ofrece como ejemplo.&lt;/li&gt;
&lt;li&gt;Finalmente incorporaríamos una capa, que imaginariamente llamaremos
 &lt;strong&gt;meta-myproject&lt;/strong&gt;, para proveer el software y la configuraciones necesarias
 para crear una interfaz gráfica de usuario de configuración del &lt;a href="http://es.wikipedia.org/wiki/Network-attached_storage" title="Network-attached storage"&gt;NAS&lt;/a&gt;.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Como hemos comentado, cada una de estas capas estaría formada por uno o más
archivos de configuración de los tipos indicados anteriormente.&lt;/p&gt;
&lt;h2&gt;Referencias&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://www.aosabook.org/en/yocto.html"&gt;The Yocto Proyect&lt;/a&gt;.
 &lt;a href="http://www.aosabook.org/"&gt;The Architecture of Open Source Applications&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="https://wiki.yoctoproject.org/wiki/FAQ"&gt;Yocto Proyect FAQ&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.yoctoproject.org/docs/1.0/poky-ref-manual/poky-ref-manual.html"&gt;Poky HandBook&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="yocto"></category><category term="poky"></category><category term="bitbake"></category><category term="empotrado"></category><category term="linux"></category><category term="openembedded"></category></entry></feed>